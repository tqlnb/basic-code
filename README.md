# basic-code
学习java  来自“黑马程序员”
自己学着写的一些代码和笔记
www.bilibili.com/video/BV17F411T

===================================================================
ASCII码表
![image](https://user-images.githubusercontent.com/88382462/191399708-bb773f47-edba-4dc2-bd5e-e0a0f3a02a49.png)


===================================================================
StringBulider
![image](https://user-images.githubusercontent.com/88382462/191155163-0dd85d31-26d6-4895-b6db-71f2d8e48e37.png)
![image](https://user-images.githubusercontent.com/88382462/191155287-762282d0-aa3b-4bdd-914f-8a16fd8168b6.png)


====================================================================================
以下是StringJoiner的用法
![image](https://user-images.githubusercontent.com/88382462/191153955-746ade56-8bb6-4977-a477-283ca3bc60a8.png)
![image](https://user-images.githubusercontent.com/88382462/191154100-0753ce4d-bed5-4464-90f6-6e571ac6a467.png)

==================================================================
String 原理
![image](https://user-images.githubusercontent.com/88382462/191155697-a474ae17-1173-4f39-b7e1-50ad72a37499.png)
![image](https://user-images.githubusercontent.com/88382462/191155904-e568b602-ad33-4c75-878e-065b95103c9d.png)

在涉及变量的拼接：
![image](https://user-images.githubusercontent.com/88382462/191156880-ece65d93-e280-4cec-bf0f-25e77dac2d1d.png)

![image](https://user-images.githubusercontent.com/88382462/191157706-1e27a209-d65a-46c9-bb26-355eb8a9a50d.png)
![image](https://user-images.githubusercontent.com/88382462/191157852-7e1150a1-6dc9-41c2-a8f1-c083fe3ed9d1.png)

![image](https://user-images.githubusercontent.com/88382462/191158030-5208296e-7707-43b3-8512-1b8b639d74b2.png)

=================================================
集合
集合和数组的区别
![image](https://user-images.githubusercontent.com/88382462/191681113-d181f93b-dc67-463e-9b6d-de873e11c33d.png)

创建集合
![image](https://user-images.githubusercontent.com/88382462/191681168-12a4df9e-556c-4890-99c0-425ee8b83e4a.png)
ArrayList成员方法
![image](https://user-images.githubusercontent.com/88382462/191681202-a6828d87-5eac-4c7d-9125-196664de8416.png)

![image](https://user-images.githubusercontent.com/88382462/191681249-8ae97d4b-f69d-4d5c-b8b2-a8f252fdf324.png)
![image](https://user-images.githubusercontent.com/88382462/191681279-d47458c5-8cc2-4f5c-b31d-10c501e768a0.png)
基本数据类型的包装类
![image](https://user-images.githubusercontent.com/88382462/191681309-dbce7e0d-16d5-4614-835a-a61f72a16740.png)
![image](https://user-images.githubusercontent.com/88382462/191681357-4e1e2a00-12bc-4f50-a64b-504f986c4408.png)

==============================================================================================================
当循环嵌套时想退出外面的循环
![image](https://user-images.githubusercontent.com/88382462/191693489-485ca7dc-03ff-4051-9732-f7c087ecbdff.png)


==============================================================================================================
static关键字

![image](https://user-images.githubusercontent.com/88382462/192304073-f85684a5-954f-4247-94ed-fd353dc365c5.png)
![image](https://user-images.githubusercontent.com/88382462/192304670-74834351-597c-419f-81ae-a937055c4527.png)
![image](https://user-images.githubusercontent.com/88382462/192304854-b2bc9c63-b6af-40a4-97dd-7702be041948.png)
![image](https://user-images.githubusercontent.com/88382462/192305802-505213c1-8d53-464e-aaa1-3dad22fde0fb.png)


===================================================================================================
工具类
![image](https://user-images.githubusercontent.com/88382462/192308437-5af3525f-8043-4630-884f-09229393036d.png)
![image](https://user-images.githubusercontent.com/88382462/192309085-c3b4002e-7258-40f9-96b9-6c6544032a8d.png)
![image](https://user-images.githubusercontent.com/88382462/192316588-29ac02f0-db94-4db4-9e70-36f0d0739e66.png)
![image](https://user-images.githubusercontent.com/88382462/192316904-a425d31f-c6b4-4136-ae32-9f9706334dc3.png)


===================================================================================================
封装
![image](https://user-images.githubusercontent.com/88382462/192415469-a34ea306-7f65-4740-a7f8-a45de43af7d6.png)

![image](https://user-images.githubusercontent.com/88382462/192416569-a9f9a1c5-1e18-40b9-93c6-d66e6796cab8.png)

![image](https://user-images.githubusercontent.com/88382462/192416738-f0a01b2a-2978-47e7-a9a8-44a8f0367ab3.png)

![image](https://user-images.githubusercontent.com/88382462/192416905-b47ee3e4-53af-4321-947e-32c27edff7d6.png)

![image](https://user-images.githubusercontent.com/88382462/192417934-f56a5bfe-5ad1-42a5-aa6b-70eba4e3608e.png)

![image](https://user-images.githubusercontent.com/88382462/192418395-a71d9e29-980e-41d6-a9e1-dafb78cdb9f5.png)

![image](https://user-images.githubusercontent.com/88382462/192470608-a3ab47c5-96f0-410c-b124-2aad27d55e94.png)

![image](https://user-images.githubusercontent.com/88382462/192729991-69d7e9e4-02f7-4055-9c1f-014acd9bf3b7.png)

![image](https://user-images.githubusercontent.com/88382462/192730532-b4b46699-12e4-45f4-8e87-8c03b445ca37.png)

![image](https://user-images.githubusercontent.com/88382462/192733170-5553bda4-2439-49e5-b234-2851ef02bf16.png)

![image](https://user-images.githubusercontent.com/88382462/192733283-923e1df5-c625-4112-a248-e74e5a94cfcb.png)

![image](https://user-images.githubusercontent.com/88382462/192735006-f4046805-d193-4dc9-bbda-5903fc419dfd.png)

![image](https://user-images.githubusercontent.com/88382462/192735504-55e535e9-eee0-49fe-a52a-f2b3108a3d1d.png)

![image](https://user-images.githubusercontent.com/88382462/192736250-1be90fd5-642c-4b35-91a7-76ad5f3419d4.png)

![image](https://user-images.githubusercontent.com/88382462/192742068-11b7d9a9-1d72-4f36-afd8-be42e9f89454.png)

![image](https://user-images.githubusercontent.com/88382462/192742588-5d1e408a-ae98-44f2-89ce-a75ba33267d8.png)

![image](https://user-images.githubusercontent.com/88382462/192744675-ac244198-c158-4cab-827a-8151e9766c6e.png)

![image](https://user-images.githubusercontent.com/88382462/192746319-824bdb7d-011a-41a3-ad74-2950e53495c3.png)

![image](https://user-images.githubusercontent.com/88382462/192746886-4d33f32a-db60-4a65-a6da-3ce87af066e9.png)

==========================================================================================
多态

![image](https://user-images.githubusercontent.com/88382462/193443335-096a6f91-f6f7-4176-a72d-c11d7d5d0ef4.png)

![image](https://user-images.githubusercontent.com/88382462/193443788-4539d724-0449-4690-b311-4defa0559bdb.png)

![image](https://user-images.githubusercontent.com/88382462/193443816-72ea183c-721b-44b7-b120-0baeb34adcf4.png)

调用成员变量:编译看左边，运行也看左边
编译看左边: javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。
运行也看左边: java运行代码的时候，实际获取的就是左边父类中成员变量的值

调用成员方法:编译看左边，运行看右边
编译看左边: javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。
运行看右边: java运行代码的时候，实际上运行的是子类中的方法。

![image](https://user-images.githubusercontent.com/88382462/193444370-6abd8aba-8969-4499-85c4-4a866aa16d8e.png)

多态的弊端
不能调用子类的特有功能
报错的原因?
当调用成员方法的时候，编译看左边，运行看右边
那么在编译的时候会先检查左边的父类中有没有这个方法，如果没有直接报错。
解决方案:
变回子类类型就可以了（可以用强制转换）（但是瞎转转成其他的对象就会报错）
可以用instanceof来判断对象是什么类型的
![image](https://user-images.githubusercontent.com/88382462/193444895-5379e9b7-707e-4bd1-bda4-1df4ff106bb9.png)

![image](https://user-images.githubusercontent.com/88382462/193445015-6ce2109b-6a93-47dd-84ae-2c35afcd67bf.png)

![image](https://user-images.githubusercontent.com/88382462/193445071-d6231b8c-3518-44cf-b915-22fab0dc3d17.png)

![image](https://user-images.githubusercontent.com/88382462/193445126-da9512d4-5399-4961-9c7f-af2eb7e1876c.png)


=============================================================================================
包
![image](https://user-images.githubusercontent.com/88382462/193446805-7f347726-8623-455a-aa3f-488d0baeec2a.png)
导包
![image](https://user-images.githubusercontent.com/88382462/193446840-70b0a958-a83c-4b3a-9698-3b907a67be27.png)
![image](https://user-images.githubusercontent.com/88382462/193446859-b8d12557-8e98-47a1-9795-2f6e17670ac5.png)
![image](https://user-images.githubusercontent.com/88382462/193447098-53feddfa-3c23-4920-bf77-2f6459d4fe41.png)


=============================================================================================
final
![image](https://user-images.githubusercontent.com/88382462/193462016-7ec4148f-427c-45f8-b036-cc376f876385.png)

![image](https://user-images.githubusercontent.com/88382462/193462339-431f325e-516d-4dd2-a834-eaf93fc3dcc9.png)

![image](https://user-images.githubusercontent.com/88382462/194689623-3bc7be28-2a4c-4f96-b9fe-a8ef5b5b9c7d.png)
 
![image](https://user-images.githubusercontent.com/88382462/194888059-6035f9b8-c882-4d9a-ad46-316fc4566c7f.png)

![image](https://user-images.githubusercontent.com/88382462/194889136-d35f4f08-620b-4d4b-8868-6d54f440fe3d.png)

但是构造代码块很少使用，如果多个构造方法有一些相同的代码可以用以下的方式
![image](https://user-images.githubusercontent.com/88382462/194890863-95023260-7f07-44ee-b90c-26ffe50786f6.png)

![image](https://user-images.githubusercontent.com/88382462/194895174-20e9d72a-646d-4411-b7a8-6b1451143d6c.png)

![image](https://user-images.githubusercontent.com/88382462/194896373-61105c1f-8748-42fd-988a-8b181332aba0.png)

![image](https://user-images.githubusercontent.com/88382462/194896523-1654cc9a-df52-4efa-a152-1e091bdefc1a.png)
 
 ![image](https://user-images.githubusercontent.com/88382462/194897297-542c908f-421d-4a3c-a74a-865f9d02dc19.png)

 ===============================================================================
 接口
 ![image](https://user-images.githubusercontent.com/88382462/195065577-fbdf768a-5060-4811-a685-61abccaeec94.png)

 ![image](https://user-images.githubusercontent.com/88382462/195073694-05c38cc1-a574-41c3-9e9a-86dce0e12e99.png)

![image](https://user-images.githubusercontent.com/88382462/195078798-3681c96d-6718-4f16-8291-82278773fe14.png)

![image](https://user-images.githubusercontent.com/88382462/195083063-26424218-1de6-4d89-bb2e-9d469f7b8402.png)

![image](https://user-images.githubusercontent.com/88382462/195088563-1fb53c54-045b-48d8-b510-7ccb82b32e49.png)

![image](https://user-images.githubusercontent.com/88382462/195090214-7be3fda3-19a7-4f11-a869-0a65d41d6142.png)

![image](https://user-images.githubusercontent.com/88382462/195091618-c05e421b-0d9b-433b-bf9b-51433cbedb00.png)
 
![image](https://user-images.githubusercontent.com/88382462/195093990-dc58c43b-025e-44dc-9c97-7dc6ce19d777.png)

![image](https://user-images.githubusercontent.com/88382462/195094439-fb2cb0da-d8d9-4d97-8323-c15e7721e7de.png)
  
 ![image](https://user-images.githubusercontent.com/88382462/195094808-f6a4c0c4-1903-41bb-a94b-bfac6c4f9589.png)

![image](https://user-images.githubusercontent.com/88382462/195252965-d6816991-33a0-441d-8502-e849aa031a6f.png)
当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。
![image](https://user-images.githubusercontent.com/88382462/195253161-c69b1e31-1e7a-4a97-a587-78dff5b2e33f.png)

![image](https://user-images.githubusercontent.com/88382462/195254134-50fc1e71-96f5-4cb4-a337-f9bce80aa09e.png)
========================================================================================
内部类
![image](https://user-images.githubusercontent.com/88382462/195254292-1a41f7e2-ab97-48f3-b150-018170f2d1ed.png)

![image](https://user-images.githubusercontent.com/88382462/195254397-53904668-9f72-4e0b-9434-6cb4d413520c.png)

![image](https://user-images.githubusercontent.com/88382462/195254619-7c654814-f7a8-489a-8f24-be07ca01de38.png)

![image](https://user-images.githubusercontent.com/88382462/195256185-7aef5fc1-85d2-4be1-907a-c49d9dca4596.png)
![image](https://user-images.githubusercontent.com/88382462/195256696-9eb4026c-fa5c-4693-bb03-22065e2bcd6f.png)
![image](https://user-images.githubusercontent.com/88382462/195256859-66e2ceea-ce8e-4ea3-bef8-2f9baea508eb.png)
![image](https://user-images.githubusercontent.com/88382462/195257342-e49f4f13-ddea-443d-bec8-5c89d630ffad.png)
![image](https://user-images.githubusercontent.com/88382462/195263171-1bfd870d-b798-4901-a7d8-e9d752a3a8f3.png)
![image](https://user-images.githubusercontent.com/88382462/195263454-432b485c-6c2c-40c0-97ea-c0e13d9dbe15.png)
![image](https://user-images.githubusercontent.com/88382462/195263693-86c89bbe-33aa-4625-8743-70fd6a976428.png)
![image](https://user-images.githubusercontent.com/88382462/195792742-0a970046-f7eb-4283-a96e-036502c5f61d.png)

========================================================================================
匿名内部类
![image](https://user-images.githubusercontent.com/88382462/195794365-d429243f-b87e-4bce-a16a-5c23d8af1cf6.png)
![image](https://user-images.githubusercontent.com/88382462/195796546-a7d68049-352a-4c40-8e2c-baa1bd8fe3c4.png)
![image](https://user-images.githubusercontent.com/88382462/196916464-8b47eaca-d82d-4964-8244-40bc1494f54d.png)
![image](https://user-images.githubusercontent.com/88382462/196920860-7b162a88-584f-419f-8055-182fb4d5a757.png)


========================================================================================
GUI
![image](https://user-images.githubusercontent.com/88382462/196923244-775afbb2-8060-4180-9380-1359fe8f6c9f.png)
![image](https://user-images.githubusercontent.com/88382462/197311400-95c798c7-8aef-4889-9161-9ddabb3bd62c.png)
![image](https://user-images.githubusercontent.com/88382462/197311393-a51119d9-8f19-4c12-8f15-ab97719ec90a.png)
![image](https://user-images.githubusercontent.com/88382462/197311465-67557037-1e27-440f-9f19-568d9efe1dd1.png)
![image](https://user-images.githubusercontent.com/88382462/197311490-e726f93c-595d-4631-8b37-d5393f15b2e8.png)
![image](https://user-images.githubusercontent.com/88382462/197316325-30d3b4e3-e44f-4368-805f-d7172e3508d5.png)
![image](https://user-images.githubusercontent.com/88382462/197316480-e1679369-d7b3-423c-842e-05a8ed6855f7.png)
![image](https://user-images.githubusercontent.com/88382462/197980394-ac2e4889-8a87-4f15-b355-911d259c8e1a.png)
![image](https://user-images.githubusercontent.com/88382462/197989772-d1602dde-ca13-4023-a284-58ad0c24227e.png)
![image](https://user-images.githubusercontent.com/88382462/197989820-81550170-7a16-4654-adb8-16b06dbb5062.png)
![image](https://user-images.githubusercontent.com/88382462/197994468-5dc80479-3257-438a-8f06-4c8e6e8ff296.png)
![image](https://user-images.githubusercontent.com/88382462/197994598-977efe20-8e35-455b-aee9-612fd103364a.png)

=========================================================================================
MATH
![image](https://user-images.githubusercontent.com/88382462/200764190-add2f3ff-7071-4071-b3dc-d7459cfad150.png)
![image](https://user-images.githubusercontent.com/88382462/201478751-88158b35-9573-4560-8666-e6d6a60d3f9a.png)
![image](https://user-images.githubusercontent.com/88382462/201479007-4d835e91-944c-4cfd-9d09-63902ce8fbd0.png)

SYSTEM
![image](https://user-images.githubusercontent.com/88382462/201480948-747235d7-4ee7-4247-8323-ea8e334bb10a.png)
![image](https://user-images.githubusercontent.com/88382462/201480916-681590ad-dfc9-4f01-b29b-7edf57f5a6a6.png)
![image](https://user-images.githubusercontent.com/88382462/201482246-f7a516da-df49-456a-b281-d3617273214a.png)

RUNTIME
![image](https://user-images.githubusercontent.com/88382462/201514149-0d7deccb-1cc6-4e42-b0bc-8b6bd64125cd.png)
![image](https://user-images.githubusercontent.com/88382462/201514159-35c94581-09c1-45b9-b09c-8536a88b4b61.png)

OBJECT
![image](https://user-images.githubusercontent.com/88382462/201514278-3ac501be-4849-409f-b462-496bd1682f7c.png)
![image](https://user-images.githubusercontent.com/88382462/201514302-75ea8fa9-2a31-4df3-93f3-37b2ceab4338.png)
 ![image](https://user-images.githubusercontent.com/88382462/201514715-57b9d985-4a52-4457-a2bf-d5c6ad72b670.png)
![image](https://user-images.githubusercontent.com/88382462/201514989-434ce7c2-7c42-4f75-883f-7c168386e60d.png)
![image](https://user-images.githubusercontent.com/88382462/201515215-4164c423-e8f8-45d1-adab-7f0e079b6771.png)
![image](https://user-images.githubusercontent.com/88382462/201515557-bad20d9e-b956-473e-bea1-6dba832f6a0c.png)
![image](https://user-images.githubusercontent.com/88382462/201515746-d5ce739d-7abf-4033-a68c-d34d22e2060c.png)
![image](https://user-images.githubusercontent.com/88382462/201516056-5640170d-598f-447d-93d9-42b2f6e18310.png)
![image](https://user-images.githubusercontent.com/88382462/201516124-5bf37ad7-e7a6-4a9d-a0ae-10d8b105e285.png)
![image](https://user-images.githubusercontent.com/88382462/201516181-544615e3-a52f-445d-afe6-bf347922bf86.png)
![image](https://user-images.githubusercontent.com/88382462/201516200-a6203523-0440-44f4-9c9b-6d48a1b6db4d.png)
![image](https://user-images.githubusercontent.com/88382462/201516281-18aa38a7-d90d-41f0-992b-92ec1464736c.png)
![image](https://user-images.githubusercontent.com/88382462/201516765-cb35da72-235e-4658-b6e0-a7002a3be0f3.png)
![image](https://user-images.githubusercontent.com/88382462/201516792-8fc81685-3c07-4076-a7f3-591ec34126f3.png)

OBJECTS
![image](https://user-images.githubusercontent.com/88382462/201690011-372cf37d-0e12-447c-b798-77ce08830a97.png)
![image](https://user-images.githubusercontent.com/88382462/201691646-428c632f-4839-42b0-9922-d7d0dcb3cae2.png)

BigInteger
![image](https://user-images.githubusercontent.com/88382462/201692963-c96f9e39-0412-4c6b-bef3-da4ffa52da7e.png)
![image](https://user-images.githubusercontent.com/88382462/201699816-16fd12bf-1f51-4e0d-a4d0-a4bb4c4a6bbc.png)
![image](https://user-images.githubusercontent.com/88382462/201700211-fc75ea3e-d7ea-450b-b6a4-8e3b93f4e562.png)


BigDecimal
![image](https://user-images.githubusercontent.com/88382462/201882203-a45ba5d2-f136-4b7b-b15c-00548dc1809e.png)
![image](https://user-images.githubusercontent.com/88382462/201885104-d50ef8b8-c98a-40c6-b3c5-957b8f1c30bc.png)
![image](https://user-images.githubusercontent.com/88382462/201885266-1bd73863-eb04-4777-a8f9-17b8164b2b92.png)
![image](https://user-images.githubusercontent.com/88382462/201888770-8783e06d-f643-48a9-be1e-928c8f94ed7b.png)

Regex:正则表达式  Date Calendar
![image](https://user-images.githubusercontent.com/88382462/201891646-35a26245-721d-41a6-babe-cd7b72d0846c.png)
![image](https://user-images.githubusercontent.com/88382462/201895122-97145d02-c0a1-4726-816d-e8c99c234f19.png)
![image](https://user-images.githubusercontent.com/88382462/201907062-e2d2178f-c424-49e8-8488-046e336ecab9.png)
![image](https://user-images.githubusercontent.com/88382462/201907135-ab359d3e-e114-4059-bbef-d7096e851079.png)
![image](https://user-images.githubusercontent.com/88382462/202378983-caf2d3ff-5b28-49da-aa9f-44ce40229342.png)
![image](https://user-images.githubusercontent.com/88382462/202379282-b9b949e9-f4e5-4c19-83d5-7ca6f15b59f3.png)
![image](https://user-images.githubusercontent.com/88382462/202381946-5fdf2a68-de36-4952-b9d0-cb4728429b3d.png)
![image](https://user-images.githubusercontent.com/88382462/202381707-ff552fba-6ed7-4209-adcf-f860bc6cdc6c.png)
![image](https://user-images.githubusercontent.com/88382462/202384021-835bf7eb-50f7-4147-b6c0-7a8061ddbeb3.png)
![image](https://user-images.githubusercontent.com/88382462/202396066-fa97c7c4-063f-4b4e-946e-36793d139985.png)
![image](https://user-images.githubusercontent.com/88382462/202397774-ac59c0d8-6a75-437b-a06c-93ae2920ae64.png)
![image](https://user-images.githubusercontent.com/88382462/202397837-a7d8be09-8e71-498c-a359-74739af8d980.png)
 ![image](https://user-images.githubusercontent.com/88382462/202402297-a0f728a0-8611-4c6c-8ee8-4fb8a7a38f75.png)
![image](https://user-images.githubusercontent.com/88382462/202896767-c63628d6-7b28-45eb-8a7a-9ace7a9778b8.png)
![image](https://user-images.githubusercontent.com/88382462/202897128-e32b547c-b209-4337-a7af-57e5a12888b2.png)
![image](https://user-images.githubusercontent.com/88382462/202897150-d2d0c30b-c247-45c6-bdc5-baf392e0180e.png)
![image](https://user-images.githubusercontent.com/88382462/202897249-10cfb18a-caa6-4a0f-b681-4c4661dd3d2f.png)
![image](https://user-images.githubusercontent.com/88382462/202897296-9d4f2289-76b4-4e29-9dde-0f06e5baac57.png)
![image](https://user-images.githubusercontent.com/88382462/202897438-7488ebcd-f9bc-46f7-be2a-e15f5bd07a19.png)
![image](https://user-images.githubusercontent.com/88382462/202897519-4ec553e9-35da-4ca9-b5e3-e39077141c72.png)
![image](https://user-images.githubusercontent.com/88382462/202897625-7919bea0-732b-4f10-a493-4be8d0fcaca2.png)
![image](https://user-images.githubusercontent.com/88382462/202899396-8a052354-fc84-47ee-8f19-9e935d86af34.png)
![image](https://user-images.githubusercontent.com/88382462/202899912-18fea89a-87f4-47c6-b44d-e24a4acd6950.png)
![image](https://user-images.githubusercontent.com/88382462/202899960-babd0bab-95a3-4fb4-b063-4be4679a7a47.png)
![image](https://user-images.githubusercontent.com/88382462/202900038-d3f8f862-561f-49dc-ab6c-f18d80b43447.png)
 ![image](https://user-images.githubusercontent.com/88382462/202900074-2bdac03f-ae4d-49f7-b7f8-56c84d3505f0.png)
![image](https://user-images.githubusercontent.com/88382462/202900513-78ecfe63-b42e-40f3-818e-bdac7df157b8.png)
![image](https://user-images.githubusercontent.com/88382462/202900516-43fc6521-2c63-45b7-a704-7e96d02acfb5.png)
![image](https://user-images.githubusercontent.com/88382462/202901290-f3639bf6-54a1-4ba0-be06-cf003098f28f.png)
 ![image](https://user-images.githubusercontent.com/88382462/202901362-473c798f-a850-4d74-8617-6ffb22119f7b.png)
![image](https://user-images.githubusercontent.com/88382462/202901698-05eabdb5-2053-4593-b96f-cfecbb2134dc.png)
![image](https://user-images.githubusercontent.com/88382462/202902188-746bb30a-6127-47cf-833e-e57464239a08.png)
![image](https://user-images.githubusercontent.com/88382462/202902498-f8ed29ef-4580-4544-a0d2-23f4122327cb.png)
![image](https://user-images.githubusercontent.com/88382462/202902519-75dcc771-1d28-4578-9ec4-fb775e4b553d.png)
![image](https://user-images.githubusercontent.com/88382462/202902569-9819cbd4-f0b2-4453-b8af-f4d0eb0ae724.png)
![image](https://user-images.githubusercontent.com/88382462/202902578-302921e8-6423-4ea5-99d7-ac0bf4bb246a.png)
![image](https://user-images.githubusercontent.com/88382462/202902982-4d5f9175-d64d-4b6f-8073-cc14e07d3752.png)
![image](https://user-images.githubusercontent.com/88382462/202903027-4fb5cb6e-66c0-4f73-ae6e-754b30789bfa.png)
![image](https://user-images.githubusercontent.com/88382462/202903553-1250c6e6-9c23-47b4-b283-0c64e30c862a.png)
![image](https://user-images.githubusercontent.com/88382462/202903594-5f38298d-d683-44b0-80d3-9fb6a06aac2b.png)
![image](https://user-images.githubusercontent.com/88382462/202903883-a41d9760-b0be-44e0-aed6-1c858f0bc47e.png)
![image](https://user-images.githubusercontent.com/88382462/202903984-ba2bc7af-d687-4013-9e74-1b5d574a3083.png)
![image](https://user-images.githubusercontent.com/88382462/202903989-3e048940-bb5c-4da4-a1c7-b5d4c4195b87.png)
![image](https://user-images.githubusercontent.com/88382462/203062932-e0db39e1-a8a6-4427-882e-1e680379d5cb.png)
![image](https://user-images.githubusercontent.com/88382462/203067139-14949efd-d5d6-48f6-bcc5-cf6cd01afa7a.png)
![image](https://user-images.githubusercontent.com/88382462/203067711-89ac5ade-b35c-46fe-95ee-4c3470e073ce.png)
![image](https://user-images.githubusercontent.com/88382462/203068644-2aa13d94-21f0-4f07-ac95-9c442b85ce00.png)


包装类
![image](https://user-images.githubusercontent.com/88382462/203069149-21c93513-2bec-4107-800b-f822cf8b6dff.png)
![image](https://user-images.githubusercontent.com/88382462/203070078-edbcfe8b-290b-40cb-8e0d-8fd1af4dc5c7.png)
![image](https://user-images.githubusercontent.com/88382462/203071231-3a79771a-bcb3-4d58-9818-5ee5c531eb79.png)
![image](https://user-images.githubusercontent.com/88382462/203071418-57ff286a-4e93-4abd-8c42-c81b9eaf6d57.png)
![image](https://user-images.githubusercontent.com/88382462/203071642-4c31716d-0150-4492-b93c-8b215265d65d.png)
![image](https://user-images.githubusercontent.com/88382462/203071759-b534efe5-d69a-4228-9d29-dcb017e830f0.png)
![image](https://user-images.githubusercontent.com/88382462/203072800-9f54bcba-f358-44b3-9559-5d758ffdf046.png)
键盘录入更规范的写法
![image](https://user-images.githubusercontent.com/88382462/203073493-8a53cfa2-c812-49e8-bf02-6d87fe6b2462.png)

练习
![image](https://user-images.githubusercontent.com/88382462/203094884-4ec17fd0-63d1-4d1c-a735-acfdf5d132ce.png)
![image](https://user-images.githubusercontent.com/88382462/203094789-03a71d43-3914-4aa0-b784-1dc978f9d607.png)

====================================================================================
查找
![image](https://user-images.githubusercontent.com/88382462/203272542-b0860da3-10c5-43ac-ad50-b9d472cd718b.png)
![image](https://user-images.githubusercontent.com/88382462/203273128-bb9b0a2b-9458-41d2-9c3c-e0efebb7685e.png)
![image](https://user-images.githubusercontent.com/88382462/203274122-60f823c0-6c78-4559-88f2-b6582b676d3e.png)
![image](https://user-images.githubusercontent.com/88382462/203276350-00e33a09-164c-493a-a60e-25e54d4c2746.png)
![image](https://user-images.githubusercontent.com/88382462/203276840-b9e801c8-4f2d-494d-8dd3-8534ae2faa22.png)
![image](https://user-images.githubusercontent.com/88382462/203277104-1939a944-e8f1-473d-adb6-974e3f174721.png)
![image](https://user-images.githubusercontent.com/88382462/203277398-33d58c8a-99b1-4cba-a8f4-8b2f239ebf35.png)
![image](https://user-images.githubusercontent.com/88382462/203277952-d6d1a2f0-7cf6-4751-9f88-97fe985c118d.png)
![image](https://user-images.githubusercontent.com/88382462/203280577-960902ae-985e-4029-b315-d099fe1ca836.png)
![image](https://user-images.githubusercontent.com/88382462/203281332-267a683a-8a38-4a0c-8adb-70e68dd0d522.png)
![image](https://user-images.githubusercontent.com/88382462/203281476-6d25d58b-b998-4ac2-9790-82318be9ed3a.png)


=========================================================================
排序
![image](https://user-images.githubusercontent.com/88382462/204125316-0fea450a-efc3-4653-a8e1-ea9136c5147a.png)
![image](https://user-images.githubusercontent.com/88382462/204125441-8a380509-07f8-443d-ab95-d3887dd7e1c6.png)
![image](https://user-images.githubusercontent.com/88382462/204125608-b4049365-926b-4e13-9a51-a5c49d96352e.png)
![image](https://user-images.githubusercontent.com/88382462/204125779-e2556b86-4247-4bc9-8fc0-4b020f5c2b38.png)
![image](https://user-images.githubusercontent.com/88382462/204126092-bcb803a5-3781-4c06-8893-47b3caa5d02f.png)
递归
![image](https://user-images.githubusercontent.com/88382462/204126188-d4d1fec1-a095-48ae-b5b7-27242e6d6d8b.png)
![image](https://user-images.githubusercontent.com/88382462/204126218-9e7b8468-2c80-4b7c-ab00-7ed91274e81b.png)
![image](https://user-images.githubusercontent.com/88382462/204126447-f7c01fee-3ec3-4544-b947-4b0ba751fd68.png)
![image](https://user-images.githubusercontent.com/88382462/204126604-d6f5cd47-d5d5-4380-8040-d22a6180e829.png)
![image](https://user-images.githubusercontent.com/88382462/204126791-6564be36-508b-4c8e-a5e4-69921f2de601.png)
![image](https://user-images.githubusercontent.com/88382462/204128602-ac11012e-0486-4f81-869e-fcc4d42c4452.png)
![image](https://user-images.githubusercontent.com/88382462/204128653-c75cf7cf-edb2-4d5c-ba00-fb0ddc33175d.png)

Arrays
![image](https://user-images.githubusercontent.com/88382462/204129419-2c2990fe-ecd9-434e-a642-0397bbb63549.png)
![image](https://user-images.githubusercontent.com/88382462/212838345-b5df044a-c7f0-4987-8758-0a85a3f40fc4.png)
![image](https://user-images.githubusercontent.com/88382462/212838577-6c0f78ee-a296-485a-95dd-13d66b733cc9.png)
![image](https://user-images.githubusercontent.com/88382462/212840022-05df4f80-1740-40d0-887d-e66a1941d416.png)
![image](https://user-images.githubusercontent.com/88382462/212841260-4843be3b-938d-4066-bae3-195775ba72cc.png)
![image](https://user-images.githubusercontent.com/88382462/212843080-3344b9e5-1e09-4d7d-9b2a-e5ced56a77ef.png)
=============================
Lambda表达式
![image](https://user-images.githubusercontent.com/88382462/212844111-18b06548-a878-471b-87f4-894c2965c257.png)
![image](https://user-images.githubusercontent.com/88382462/212844491-e2585351-7c52-47d4-a41d-72dc36b01929.png)
![image](https://user-images.githubusercontent.com/88382462/212844821-312a043d-cfe7-4e08-9a12-524b2b7691f2.png)
![image](https://user-images.githubusercontent.com/88382462/212846790-87b04796-d288-499d-9b06-24e390d604bf.png)
![image](https://user-images.githubusercontent.com/88382462/212846834-4a9a184a-873d-46ab-a2b5-bab380d2a37f.png)
![image](https://user-images.githubusercontent.com/88382462/212846974-1b2780e0-8f0a-474d-93ff-4eef4da674a3.png)
![image](https://user-images.githubusercontent.com/88382462/212847403-ef1b6ee4-3396-49f6-88d3-48cb08b5b018.png)
![image](https://user-images.githubusercontent.com/88382462/212847886-5f52aa37-6322-499b-aa7b-04c215adf758.png)
![image](https://user-images.githubusercontent.com/88382462/212848511-b143a293-219f-4d98-90b4-d77b1cd86244.png)
![image](https://user-images.githubusercontent.com/88382462/212850833-ec22ddc5-b582-4d90-9875-cc6e1802fbe0.png)

![image](https://user-images.githubusercontent.com/88382462/213338212-f465bea6-6138-4ff0-b4bd-1b97160efe7e.png)

========================================================================
集合进阶 迭代器
![image](https://user-images.githubusercontent.com/88382462/216255773-8767ecee-e2c0-496e-8ae7-8d1f83fb36e9.png)
![image](https://user-images.githubusercontent.com/88382462/216256092-b126e33c-6113-4340-854b-f23a78dd2ae6.png)
![image](https://user-images.githubusercontent.com/88382462/216256372-243aa9f5-39d4-41b1-bff8-af549627d4af.png)
![image](https://user-images.githubusercontent.com/88382462/216264717-872ce773-53b6-481e-a456-86ef27d1c4fe.png)
![image](https://user-images.githubusercontent.com/88382462/219992068-0b791076-6178-46e2-b2ba-777f776c1ce5.png)
![image](https://user-images.githubusercontent.com/88382462/219992083-1537850c-11dd-44ad-9366-194b265c77ab.png)
![image](https://user-images.githubusercontent.com/88382462/219992435-020faff8-1778-4115-842f-d817575c7eda.png)
![image](https://user-images.githubusercontent.com/88382462/219992689-84aaea5c-50f8-495a-9b38-cf969119d9b4.png)
![image](https://user-images.githubusercontent.com/88382462/219993400-3e620c3e-2fca-4725-ae00-ebc4f17f30f9.png)
![image](https://user-images.githubusercontent.com/88382462/219993565-83b9b82d-d667-4361-a943-22ce3e514c72.png)
![image](https://user-images.githubusercontent.com/88382462/219993693-a31ea552-5484-45d8-b369-967ab5150c29.png)
![image](https://user-images.githubusercontent.com/88382462/219995025-e929098d-7ba4-4f51-80cb-f6737eb51e87.png)
![image](https://user-images.githubusercontent.com/88382462/219995141-8a890ec6-eaad-44fa-90b7-143aff9273c9.png)
![image](https://user-images.githubusercontent.com/88382462/219996316-29f7c66c-4233-4fc8-817f-c2c432454569.png)
![image](https://user-images.githubusercontent.com/88382462/219996961-2bf8b440-148b-4873-ada2-6dbb23acd9c4.png)
![image](https://user-images.githubusercontent.com/88382462/219997025-6f13b13c-f790-4166-8f86-5db02aac3f79.png)

增强for遍历
![image](https://user-images.githubusercontent.com/88382462/219997360-cf27e5a1-6876-4209-9e4d-cd161c82a0d6.png)
![image](https://user-images.githubusercontent.com/88382462/219997562-9924c26f-1836-4550-a22e-b56e1446bf69.png)
![image](https://user-images.githubusercontent.com/88382462/219998454-e59fad6e-18bc-45f2-9ecc-0664acf0fa1c.png)

lambda表达式遍历
![image](https://user-images.githubusercontent.com/88382462/219998998-d200c272-aaa1-415b-98c8-a9cd82ef6ea5.png)
![image](https://user-images.githubusercontent.com/88382462/219999476-31d36b56-b155-4010-add3-d2efe674a982.png)
![image](https://user-images.githubusercontent.com/88382462/219999888-9ea24500-925e-48bd-8f9d-b4d43959137d.png)

list
![image](https://user-images.githubusercontent.com/88382462/220021481-4ef87a57-3a2d-47a0-8a80-80ba90cf587e.png)

```
        List系列集合独有的方法：
            void add(int index,E element)       在此集合中的指定位置插入指定的元素
            E remove(int index)                 删除指定索引处的元素，返回被删除的元素
            E set(int index,E element)          修改指定索引处的元素，返回被修改的元素
            E get(int index)                    返回指定索引处的元素
```

```ruby
        //1.创建一个集合(接口多态)
        List<String> list = new ArrayList<>();

        //2.添加元素
        list.add("aaa");
        list.add("bbb");//1
        list.add("ccc");

        list.add(1,"ddd"); 

        //E remove(int index)                 
        // 删除指定索引处的元素，返回被删除的元素
        String remove = list.remove(0);
        System.out.println(remove);//aaa


        //E set(int index,E element)         
        //修改指定索引处的元素，返回被修改的元素
        String result = list.set(0, "QQQ");   //aaa
        System.out.println(result);

        // E get(int index)                   
        //返回指定索引处的元素
        String s = list.get(0);
        System.out.println(s);


        //3.打印集合
        System.out.println(list);
```

list.remove 删除的小细节

```ruby
//List系列集合中的两个删除的方法
        //1.直接删除元素
        //2.通过索引进行删除

        //1.创建集合并添加元素
        List<Integer> list = new ArrayList<>();

        list.add(1);
        list.add(2);
        list.add(3);


        //2.删除元素
        //请问：此时删除的是1这个元素，还是1索引上的元素？
        //为什么？
        //因为在调用方法的时候，如果方法出现了重载现象
        //优先调用，实参跟形参类型一致的那个方法。

        list.remove(1);


        //手动装箱，手动把基本数据类型的1，变成Integer类型
        Integer i = Integer.valueOf(1);

        list.remove(i);

        System.out.println(list);
```

list集合的5种遍历方式

```
  1.迭代器
  2.列表迭代器
  3.增强for
  4.Lambda表达式
  5.普通for循环
```

1.迭代器

```ruby
 Iterator<String> it = list.iterator();
  while(it.hasNext()){
      String str = it.next();
      System.out.println(str);
  }
        
```

2.增强for

```ruby
 //2.增强for
 //下面的变量s，其实就是一个第三方的变量而已。
 //在循环的过程中，依次表示集合中的每一个元素
 for (String s : list) {
     System.out.println(s);
 }

```

3.lambda表达式

```ruby
 //3.Lambda表达式
 //forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素
 //并把每一个元素传递给下面的accept方法
 //accept方法的形参s，依次表示集合中的每一个元素
 list.forEach(s->System.out.println(s) );

```
4.普通for循环

```ruby
 //4.普通for循环
 //size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素
 for (int i = 0; i < list.size(); i++) {
     //i:依次表示集合中的每一个索引
     String s = list.get(i);
     System.out.println(s);
 }

```

5.列表迭代器

```ruby
 // 5.列表迭代器
 //获取一个列表迭代器的对象，里面的指针默认也是指向0索引的

 //额外添加了一个方法：在遍历的过程中，可以添加元素
 ListIterator<String> it = list.listIterator();
 while(it.hasNext()){
     String str = it.next();
     if("bbb".equals(str)){
         //qqq
         it.add("qqq");
     }
 }
 System.out.println(list);

```

![image](https://user-images.githubusercontent.com/88382462/220029603-96efbf8d-b49b-4974-ac78-47342988b7ea.png)

list的实现类

数据结构
![image](https://user-images.githubusercontent.com/88382462/220030693-20573337-597f-4131-bed8-a05af3cd3f1a.png)
![image](https://user-images.githubusercontent.com/88382462/220030845-183ccf5b-9267-4139-8172-f0e05a51830f.png)

栈
![image](https://user-images.githubusercontent.com/88382462/220031566-16336ede-14de-4606-bb63-0f60e507b623.png)
![image](https://user-images.githubusercontent.com/88382462/220031700-a1310d5a-eafa-4eab-98e0-f0c598013b8d.png)

队列
![image](https://user-images.githubusercontent.com/88382462/220031941-63421719-1488-49ae-b291-c8d88008b9f9.png)

数组
![image](https://user-images.githubusercontent.com/88382462/220032502-f43751fa-6224-454a-82c7-996be2313b05.png)

链表
![image](https://user-images.githubusercontent.com/88382462/220033617-ca82eb99-5c0e-4a98-b59b-47fae0ce2c42.png)
![image](https://user-images.githubusercontent.com/88382462/220033748-714670e0-3521-4bf9-97fd-94733303eb71.png)
![image](https://user-images.githubusercontent.com/88382462/220033952-4e2de156-0361-4c9d-9872-2aba86982a1a.png)
![image](https://user-images.githubusercontent.com/88382462/220034119-77170c52-3e1e-4e88-b0b5-47a2b67bad49.png)

树
![image](https://user-images.githubusercontent.com/88382462/220077681-0adc38c2-a15f-46c3-bb6b-6bea0e51b1ec.png)
![image](https://user-images.githubusercontent.com/88382462/220077745-b0d9cf38-bf54-4bdc-b829-027490b8546d.png)

二叉树
![image](https://user-images.githubusercontent.com/88382462/220077871-70d5e10f-8474-4236-956a-ae099f74267d.png)
![image](https://user-images.githubusercontent.com/88382462/220077976-756e4654-5a5b-4b3d-bee3-dd4fd7414232.png)

二叉查找树（排序树/搜索树）
![image](https://user-images.githubusercontent.com/88382462/220078162-cd7913eb-c1f1-4675-b930-9f62ef5b8e2e.png)
![image](https://user-images.githubusercontent.com/88382462/220078242-b93266b1-1217-4f09-bb40-4b9f4bc2111f.png)

二叉查找树遍历方式
![image](https://user-images.githubusercontent.com/88382462/220078399-84bb6ff5-e67e-4280-95d1-f5d08753e613.png)
1、前序遍历
![image](https://user-images.githubusercontent.com/88382462/220078578-53edca32-361d-47c0-b44b-5db96da491c3.png)
2、中序遍历
![image](https://user-images.githubusercontent.com/88382462/220078664-01927b26-94f0-47a6-a0f2-29ba418f7800.png)
3、后序遍历
![image](https://user-images.githubusercontent.com/88382462/220078967-4921a529-30f2-47ad-a7cf-81801d567505.png)

4、层序遍历
![image](https://user-images.githubusercontent.com/88382462/220079228-ea6102ae-a273-4cc6-a579-c48f71a3dd0a.png)

![image](https://user-images.githubusercontent.com/88382462/220079280-1bbf7c32-a25d-400c-94b2-69197d116cf6.png)

二叉查找树弊端
![image](https://user-images.githubusercontent.com/88382462/220080659-5e0b85bc-8289-4ebb-9c9c-4551c700a645.png)

平衡二叉树
![image](https://user-images.githubusercontent.com/88382462/220081164-ac9b47b2-b06c-4e9a-bafe-aeccd276cce3.png)
![image](https://user-images.githubusercontent.com/88382462/220081346-8424b556-649a-4b43-a1f3-e79cbf2323a3.png)
![image](https://user-images.githubusercontent.com/88382462/220081701-ead02489-5b0a-41fe-a199-91555ba3b47a.png)

平衡二叉树旋转机制
![image](https://user-images.githubusercontent.com/88382462/220082023-19fab3df-bbc4-4272-a7c2-d43558096cbd.png)
![image](https://user-images.githubusercontent.com/88382462/220082481-3cfb93f3-0cbf-47ca-9d66-8d441fef2f4e.png)
![image](https://user-images.githubusercontent.com/88382462/220082692-3d10d1dc-32c7-469a-8f11-57e16d3d1f16.png)
![image](https://user-images.githubusercontent.com/88382462/220083019-f18f2656-1219-47c1-a204-ad40f2f3742d.png)
![image](https://user-images.githubusercontent.com/88382462/220083899-eef0faac-75dd-447a-8e2e-3353d943b40f.png)
![image](https://user-images.githubusercontent.com/88382462/220084067-cdfef676-5899-44df-9a53-d87fd0262aa5.png)

平衡二叉树需要旋转的四种情况
1.左左 - 一次右旋
![image](https://user-images.githubusercontent.com/88382462/220085041-a28807fb-1b8f-4c76-8fa3-90433bd510b2.png)
2.左右-先局部左旋，再整体右旋
![image](https://user-images.githubusercontent.com/88382462/220092710-7063af79-2d44-4512-a728-2261391229c6.png)
![image](https://user-images.githubusercontent.com/88382462/220092811-8592dca1-e9d1-4f50-98c1-2ef720b348e6.png)
3.右右-一次左旋
![image](https://user-images.githubusercontent.com/88382462/220093359-9c282351-204c-4e2b-ba44-5a264e6b2aea.png)
4.右左-先局部右旋，再整体左旋
![image](https://user-images.githubusercontent.com/88382462/220093685-02f7c131-c4a1-4a60-9baa-b33562a501a1.png)
![image](https://user-images.githubusercontent.com/88382462/220093846-31340ca7-a4cb-406d-aa94-5e8234b9d08f.png)

![image](https://user-images.githubusercontent.com/88382462/220093950-07bf92d7-8603-4aa3-b758-591886a7b055.png)
![image](https://user-images.githubusercontent.com/88382462/220093992-f13e770e-b693-4505-8e34-1ee3379825f7

红黑树
![image](https://user-images.githubusercontent.com/88382462/220095287-0a6e24a3-80d9-4ea8-9353-5e1d6d7da9a6.png)
![image](https://user-images.githubusercontent.com/88382462/220095732-87425e79-a880-4f76-bc5e-62b4dcc80068.png)
红黑树添加节点的规则
![image](https://user-images.githubusercontent.com/88382462/220097996-294dee22-873d-43b6-b74e-9cafebcdc24e.png)



LinkedList
以下几种方法不常用
![image](https://user-images.githubusercontent.com/88382462/220034890-e337f11e-aeb4-4e2f-a9f9-7e9e4197b339.png)

泛型

泛型概述
![image](https://user-images.githubusercontent.com/88382462/220035567-477f2fe9-0972-4331-a11b-8117c199203a.png)

没有泛型的时候，集合如何存储数据？
    结论：
    如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型
    此时可以往集合添加任意的数据类型。
    **带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。**
    此时推出了泛型，可以在添加数据的时候就把类型进行统一。
    而且我们在获取数据的时候，也省的强转了，非常的方便。
    
没有泛型时
```ruby
 //1.创建集合的对象
 ArrayList<String> list = new ArrayList<>();

 //2.添加数据
 list.add(123);
 list.add("aaa");
 list.add(new Student("zhangsan",123));


 //3.遍历集合获取里面的每一个元素
 Iterator<String> it = list.iterator();
 while(it.hasNext()){
     String str = it.next();
     //多态的弊端是不能访问子类的特有功能
     //obj.length();
     //str.length();
     System.out.println(str);
 }
```

**泛型的好处**
1.统一数据类型。
2.把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。

Java里的泛型是伪泛型

**泛型的细节**
1.泛型中不能写基本数据类型
2.指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型
3.如果不写泛型，类型默认是Object

![image](https://user-images.githubusercontent.com/88382462/220038439-d0f7d5d2-35c8-4812-9be1-9c163b700ab8.png)

泛型类
![image](https://user-images.githubusercontent.com/88382462/220038644-5e32c8e9-8082-4d31-8366-53952503563a.png)

编写泛型类
```ruby
/*
*       当我在编写一个类的时候，如果不确定类型，那么这个类就可以定义为泛型类。
* */
public class MyArrayList<E> {

    Object[] obj = new Object[10];
    int size;

    /*
    E : 表示是不确定的类型。该类型在类名后面已经定义过了。
    e：形参的名字，变量名
    * */
    public boolean add(E e){
        obj[size] = e;
        size++;
        return true;
    }


    public E get(int index){
        return (E)obj[index];
    }


    @Override
    public String toString() {
        return Arrays.toString(obj);
    }
}

```
对应的实现方法
```ruby
MyArrayList<String> list = new MyArrayList<>();

list.add("aaa");
list.add("bbb");
list.add("ccc");


System.out.println(list);


MyArrayList<Integer> list2 = new MyArrayList<>();
list2.add(123);
list2.add(456);
list2.add(789);


int i = list2.get(0);
System.out.println(i);


System.out.println(list2);
```


泛型方法
![image](https://user-images.githubusercontent.com/88382462/220041595-e08bfa9b-b8da-44fe-9383-7d65c55d454e.png)
![image](https://user-images.githubusercontent.com/88382462/220041741-bc760f8d-61d8-4be7-9817-d667e1020726.png)

定义一个工具类：ListUtil
类中定义一个静态方法addAll，用来添加多个集合的元素。

```ruby
public class ListUtil {
    private ListUtil(){}

    //类中定义一个静态方法addAll，用来添加多个集合的元素。


    /*
    *   参数一：集合
    *   参数二~最后：要添加的元素
    *
    * */
    public static<E> void addAll(ArrayList<E> list, E e1,E e2,E e3,E e4){
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
    }

/*    public static<E> void addAll2(ArrayList<E> list, E...e){
        //e为可变参数
        for (E element : e) {
            list.add(element);
        }
    }*/


    public void show(){
        System.out.println("阿玮");
    }
}

```
实现类
```ruby
public class GenericsDemo3 {
    public static void main(String[] args) {

        ArrayList<String> list1 = new ArrayList<>();
        ListUtil.addAll(list1, "aaa", "bbb", "ccc", "ddd");
        System.out.println(list1);


        ArrayList<Integer> list2 = new ArrayList<>();
        ListUtil.addAll(list2,1,2,3,4);
        System.out.println(list2);

    }
}
```

泛型接口

![image](https://user-images.githubusercontent.com/88382462/220043693-99882c7d-baa6-4f11-9844-917edc7f0135.png)

泛型接口的两种使用方式：
   1.实现类给出具体的类型
   2.实现类延续泛型，创建实现类对象时再确定类型
   
```ruby
//1.实现类给出具体的类型
public class MyArrayList2 implements List<String> {}
//2.实现类延续泛型，创建实现类对象时再确定类型
public class MyArrayList3<E> implements List<E>{}
```

**泛型的继承和通配符**
泛型不具备继承性，数据具备继承性

```ruby
public  static <E> void method(ArrayList<E> list) {

}
```

需求： 定义一个方法，形参是一个集合，但是集合中的数据类型不确定。
 
```ruby
 /*
     * 此时，泛型里面写的是什么类型，那么只能传递什么类型的数据。
     * 弊端：
     *      利用泛型方法有一个小弊端，此时他可以接受任意的数据类型
     *      Ye  Fu   Zi    Student
     *
     * 希望：本方法虽然不确定类型，但是以后我希望只能传递Ye Fu Zi
     *
     * 此时我们就可以使用泛型的通配符：
     *      ?也表示不确定的类型
     *      他可以进行类型的限定
     *      ? extends E: 表示可以传递E或者E所有的子类类型
     *      ? super E:表示可以传递E或者E所有的父类类型
     *
     * 应用场景：
     *      1.如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。
     *      2.如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符
     * 泛型的通配符：
     *      关键点：可以限定类型的范围。
     *
     * */
```

```ruby
public static void method(ArrayList<? super Fu> list) {

}
```

set
![image](https://user-images.githubusercontent.com/88382462/220497939-72e2b8c5-3436-4f30-baa7-0d42f8a49ae9.png)

```ruby
/*
   利用Set系列的集合，添加字符串，并使用多种方式遍历。
    迭代器
    增强for
    Lambda表达式

*/


//1.创建一个Set集合的对象（接口多态）
Set<String> s = new HashSet<>();

//2,添加元素
//如果当前元素是第一次添加，那么可以添加成功，返回true
//如果当前元素是第二次添加，那么添加失败，返回false
System.out.println(s.add("张三"));    //true
System.out.println(s.add("张三"));    //false
s.add("李四");
s.add("王五");

//3.打印集合
//无序
//System.out.println(s);//[李四, 张三, 王五]

//迭代器遍历
Iterator<String> it = s.iterator();
while (it.hasNext()){
    String str = it.next();
    System.out.println(str);
}


//增强for
 for (String str : s) {
    System.out.println(str);
}

// Lambda表达式
s.forEach( str->System.out.println(str));
```
 
HashSet
![image](https://user-images.githubusercontent.com/88382462/220499392-81665b21-31f3-448b-80cd-c4cd42f44065.png)

哈希值
![image](https://user-images.githubusercontent.com/88382462/220499720-4abae5b3-82dd-4e6c-aa25-75babbb5955c.png)

```ruby
/*
   哈希值：
       对象的整数表现形式
       1. 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
       2. 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
       3. 但是在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）

*/

//1.创建对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("zhangsan",23);

//2.如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
//  如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
System.out.println(s1.hashCode());//-1461067292
System.out.println(s2.hashCode());//-1461067292


//在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。
//哈希碰撞
System.out.println("abc".hashCode());//96354
System.out.println("acD".hashCode());//96354
```

JDK8以前的HashSet
![image](https://user-images.githubusercontent.com/88382462/220501348-36f12f78-f097-47f9-bdff-ee6db3ff9386.png)
![image](https://user-images.githubusercontent.com/88382462/220501183-2980e9b7-4fc6-457f-ab9b-b018c888a11c.png)

**扩容时机：当数组存了0.75*当前的数组长度时，数组长度加倍 （0.75为加载因子）**

**JDK8以后当链表长度大于等于8且数组长度大于等于64时链表转换为红黑树。**

![image](https://user-images.githubusercontent.com/88382462/220502690-ea1b960f-7900-4f60-af0d-554a40431f82.png)

**重写Equals一定要重写HashCode**

```ruby
/* 需求：创建一个存储学生对象的集合，存储多个学生对象。
            使用程序实现在控制台遍历该集合。
            要求：学生对象的成员变量值相同，我们就认为是同一个对象

*/
  //1.创建三个学生对象
  Student s1 = new Student("zhangsan",23);
  Student s2 = new Student("lisi",24);
  Student s3 = new Student("wangwu",25);
  Student s4 = new Student("zhangsan",23);


  //2.创建集合用来添加学生
  HashSet<Student> hs = new HashSet<>();

  //3.添加元素，重写hashCode和equals方法后true，true，true，false
  System.out.println(hs.add(s1));
  System.out.println(hs.add(s2));
  System.out.println(hs.add(s3));
  System.out.println(hs.add(s4));

  //4.打印集合
  System.out.println(hs);
```

LinkedHashSet
比HashSet多了一条双向链表用来存顺序
![image](https://user-images.githubusercontent.com/88382462/220504932-f7348ac5-e5d8-4433-95cd-e1cd36b39f61.png)

```ruby
 //1.创建4个学生对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("lisi",24);
Student s3 = new Student("wangwu",25);
Student s4 = new Student("zhangsan",23);

//2.创建集合的对象
LinkedHashSet<Student> lhs = new LinkedHashSet<>();

//3.添加元素
System.out.println(lhs.add(s3));    //true
System.out.println(lhs.add(s2));    //true
System.out.println(lhs.add(s1));    //true
System.out.println(lhs.add(s4));    //false

//4.打印集合
System.out.println(lhs); //顺序打印
```

![image](https://user-images.githubusercontent.com/88382462/220505517-879f648c-7d87-41ab-9f4d-e16480a89725.png)

TreeSet
![image](https://user-images.githubusercontent.com/88382462/220505662-e807d99a-b997-44d8-8e17-c4b891a2918a.png)

```ruby
/*
*
*       需求：利用TreeSet存储整数并进行排序
*
* */

//1.创建TreeSet集合对象
TreeSet<Integer> ts = new TreeSet<>();

//2.添加元素
ts.add(4);
ts.add(5);
ts.add(1);
ts.add(3);
ts.add(2);

//3.打印集合
System.out.println(ts);   //1,2,3,4,5(存入时自动排序，从小到大)

//4.遍历集合（三种遍历）
//迭代器
Iterator<Integer> it = ts.iterator();
while(it.hasNext()){
    int i = it.next();
    System.out.println(i);
}

System.out.println("--------------------------");
//增强for
for (int t : ts) {
    System.out.println(t);
}
System.out.println("--------------------------");
//lambda
ts.forEach( integer -> System.out.println(integer));
```

![image](https://user-images.githubusercontent.com/88382462/220507628-ff46df59-386b-40c5-aff7-fba84b4c1124.png)

自定义排序规则

```ruby
需求：创建TreeSet集合，并添加3个学生对象
            学生对象属性：
                姓名，年龄。
                要求按照学生的年龄进行排序
                同年龄按照姓名字母排列（暂不考虑中文）
                同姓名，同年龄认为是同一个人

            方式一：
                默认的排序规则/自然排序
                Student实现Comparable接口，重写里面的抽象方法，再指定比较规则
```

**实现Comparable接口，重写里面的抽象方法，再指定比较规则**
**存到TreeSet不用重写hashCode和eauals 因为TreeSet底层没有使用HashSet而是红黑树.
如果要往TreeSet存入自定义对象，要重写compareTo来按照自定义规则排序**


```ruby
public class Student implements Comparable<Student>{ //实现Comparable接口，泛型为Student
...
...
 //this：表示当前要添加的元素
    //o：表示已经在红黑树存在的元素

    //返回值：
    //负数：表示当前要添加的元素是小的，存左边
    //正数：表示当前要添加的元素是大的，存右边
    //0 :表示当前要添加的元素已经存在，舍弃
    public int compareTo(Student o) {
        //指定排序的规则
        //只看年龄，我想要按照年龄的升序进行排列
        return this.getAge() - o.getAge();
    }
 }
```

TreeSet第二种排序方式:比较器排序
```ruby
//o1:表示当前要添加的元素
//o2：表示已经在红黑树存在的元素
//返回值规则跟之前是一样的
TreeSet<String> ts = new TreeSet<>((o1, o2)->{
        // 按照长度排序
        int i = o1.length() - o2.length();
        //如果一样长则按照首字母排序
        i = i == 0 ? o1.compareTo(o2) : i;
        return i;
});
```

```
第一种：默认排序/自然排序
第二种：比较器排序
 默认情况下，用第一种排序方式，如果第一种不能满足当前的需求，采取第二种方式。
```

```ruby
/* 按照总分从高到低输出到控制台
如果总分一样，按照语文成绩排
如果语文一样，按照数学成绩排
如果数学成绩一样，按照英语成绩排
如果英文成绩一样，按照年龄排
如果年龄一样，按照姓名的字母顺序排
如果都一样，认为是同一个学生，不存。*/
@Override
public int compareTo(Student2 o) {
    int sum1 = this.getChinese() + this.getMath() + this.getEnglish();
    int sum2 = o.getChinese() + o.getMath() + o.getEnglish();

    //比较两者的总分
    int i = sum1 - sum2;
    //如果总分一样，就按照语文成绩排序
    i = i == 0 ? this.getChinese() - o.getChinese() : i;
    //如果语文成绩一样，就按照数学成绩排序
    i = i == 0 ? this.getMath() - o.getMath() : i;
    //如果数学成绩一样，按照英语成绩排序（可以省略不写）
    i = i == 0 ? this.getEnglish() - o.getEnglish() : i;
    //如果英文成绩一样，按照年龄排序
    i = i == 0 ? this.getAge() - o.getAge() : i;
    //如果年龄一样，按照姓名的字母顺序排序
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```

```
1. TreeSet集合的特点是怎么样的?
可排序、不重复、无索引
底层基于红黑树实现排序，增删改查性能较好
```
```
2. TreeSet集合自定义排序规则有几种方式?
方式一: Javabean类实现Comparable接口，指定比较规则
方式二∶创建集合时，自定义Comparator比较器对象，指定比较规则
方式一和方式二同时存在时，以方式二为准
```
```
3．方法返回值的特点
负数:表示当前要添加的元素是小的，存左边
正数:表示当前要添加的元素是大的，存右边
0:表示当前要添加的元素已经存在，舍弃
```

各种集合应用场景

1．如果想要集合中的元素**可重复**

用ArrayList集合，基于数组的。**（用的最多)**

2．如果想要集合中的元素**可重复**，**而且当前的增删操作明显多于查询**

用LinkedList集合，基于链表的。

3．如果想对集合中的元素**去重**

用HashSet集合，基于哈希表的。**（用的最多)**

4．如果想对集合中的元素**去重，而且保证存取顺序**

用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。

5．如果想对集合中的元素进行**排序**

用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。

# 双列集合
![image](https://user-images.githubusercontent.com/88382462/220558939-68c3c1e3-4395-4c45-85b1-6cb66dce0131.png)
## 双列集合特点
①双列集合一次需要存一对数据，分别为键和值键不能重复，值可以重复

③键和值是一一对应的，每一个键只能找到自己对应的值

④键＋值这个整体我们称之为“键值对”或者“键值对对象”，在3ava中叫做“Entry对象”

## Map
![image](https://user-images.githubusercontent.com/88382462/220559398-836fd29a-5fc5-4e9e-8dd0-6e5e8b1b23c8.png)

```ruby
//创建Map对象
Map<String, String> m = new HashMap();
//添加元素
//put方法的细节
//添加/覆盖

//在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null
//在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。
m.put("郭靖", "黄蓉");
m.put("韦小宝", "沐剑屏");
m.put("尹志平", "小龙女");

String value2 = m.put("韦小宝","双儿");
System.out.println(value2);     //沐剑屏

//删除
String result = m.remove("郭靖");
System.out.println(result);     //黄蓉

//判断是否包含
System.out.println(m.containsKey("韦小宝"));
System.out.println(m.containsValue("双儿"));

//集合长度
int size = m.size();

//清空
m.clear();

System.out.println(size);
System.out.println(m);
```

put方法 

在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null 

在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。

### Map的遍历方式

1.键找值

2.键值对

3.Lambda表达式

#### 键找值遍历
**map.keySet()**

```ruby
//创建Map集合
Map<String, String> map = new HashMap();

//添加元素
map.put("尹志平", "小龙女");
map.put("郭靖", "穆念慈");
map.put("欧阳克", "黄蓉");

//通过键找值
//获取所有的键，把这些键放到一个单列集合中
Set<String> keys = map.keySet();
//遍历单列集合，得到每一个键
for (String key : keys) {
    //利用Map中的键获取对应的值 get
    String value = map.get(key);
    System.out.println(key + "=" + value);

}

//迭代器
Iterator<String> it = keys.iterator();
while (it.hasNext()){
    String key = it.next();
    String value = map.get(key);
    System.out.println(key + "=" + value);
}

//Lambda表达式
keys.forEach((String s) -> {
        String value = map.get(s);
        System.out.println(s + "=" + value);
    }
);
```

#### 键值对遍历
**map.entrySet()**

```ruby
//创建Map集合的对象
Map<String, String> map = new HashMap();
//添加元素
map.put("标枪选手", "马超");
map.put("人物挂件", "明世隐");
map.put("御龙骑士", "尹志平");

//通过键值对方式遍历
//通过一个方法获取所有的键值对对象，方法返回一个set集合
Set<Map.Entry<String, String>> entries = map.entrySet();
//遍历entries集合，获取其中所有键值对
for (Map.Entry<String, String> entry : entries) {
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//迭代器
Iterator<Map.Entry<String, String>> it = entries.iterator();
while (it.hasNext()){
    Map.Entry<String, String> entry = it.next();
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//内部类（可简化Lambda表达式）
entries.forEach(new Consumer<Map.Entry<String, String>>() {
    @Override
    public void accept(Map.Entry<String, String> stringStringEntry) {
        System.out.println(stringStringEntry.getKey()+"="+stringStringEntry.getValue());
    }
});
```

#### Lambda表达式遍历
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```ruby
//利用Lambda表达式遍历
 map.forEach(new BiConsumer<String, String>() {
     @Override
     public void accept(String key, String value) {
         System.out.println(key + "=" + value);
     }
 });
```

利用Lambda简化后

```ruby
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```

底层:
forEach其实就是利用第二种方式进行遍历，依次得到每一个键和值,再调用accept方法

### HashMap
**HashMap的特点**

HashMap是Map里面的一个实现类。

没有额外需要学习的特有方法，直接使用Map里面的方法就可以了

特点都是由键决定的:无序、不重复、无索引

HashMap跟HashSet底层原理是一模一样的，都是哈希表结构

**总结**

1. HashMap底层是哈希表结构的

2．依赖hashCode方法和equals方法保证键的唯一

3．如果键存储的是自定义对象，需要重写hashCode和equals方法 
如果值存储自定义对象，不需要重写hashCode和equals方法


#### HashMap集合案例
需求
某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。

```ruby
//先让同学们投票
//定义一个数组储存景点
String[] arr = {"A","B","C","D"};
//利用随机数模拟80个同学的投票，，并把投票存起来
ArrayList<String> list = new ArrayList<>();
Random r = new Random();
for (int i = 0; i < 80; i++) {
    int index = r.nextInt(arr.length);
    list.add(arr[index]);
}

//如果要统计的东西比较多，不方便使用计数器思想
//可以定义Map集合，利用集合进行统计
HashMap<String,Integer> hm = new HashMap<>();
for (String name : list) {
    //判断当前景点在集合中是否存在
    if(hm.containsKey(name)){
        //存在
        //先获取当前景点被投票的次数
        Integer count = hm.get(name);
        count ++;
        //把新的次数添加到集合
        hm.put(name,count);
    }else {
        //不存在
        hm.put(name,1);
    }
}
System.out.println(hm);

//求最大值
int max = 0;
Set<Map.Entry<String, Integer>> entries = hm.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() > max) max = entry.getValue();
}

//判断那个景点最多，打印出来
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() == max) System.out.println(entry.getKey());
}
```
 
### LinkedHashMap

由键决定:有序、不重复、无索引。

这里的有序指的是保证存储和取出的元素顺序一致

原理∶底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。

```ruby
//创建集合
LinkedHashMap<String , Integer> lhm =new LinkedHashMap<>();
//添加元素
lhm.put("c",789);
lhm.put("b",456);
lhm.put("a",123);
lhm.put("a",111);

System.out.println(lhm);    //{c=789, b=456, a=111}
```

### TreeMap
TreeMap跟TreeSet底层原理一样，都是红黑树结构的。

由键决定特性:不重复、无索引、可排序

可排序:对键进行排序。

注意:默认按照键的从小到大进行排序，也可以自己规定键的排序规则 
 
**代码书写两种排序规则:**

实现Comparable接口，指定比较规则。

创建集合时传递comparator比较器对象，指定比较规则。

```ruby
//降序排列 o2 - o1 ,(默认升序)
 TreeMap<Integer,String> tm = new TreeMap<>((o1, o2) -> o2-o1);
 tm.put(5, "可恰可乐");
 tm.put(4, "雷碧");
 tm.put(3, "九个核桃");
 tm.put(2, "康帅傅");
 tm.put(1, "粤利粤");
 System.out.println(tm); //{5=可恰可乐, 4=雷碧, 3=九个核桃, 2=康帅傅, 1=粤利粤}
```

```ruby
public class Student implements Comparable<Student>
...
...
public int compareTo(Student o) {
    int i = this.getAge() - o.getAge();
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```

TreeMap例程

```ruby
/*
需求:字符串“aababcabcdabcde"
请统计字符串中每一个字符出现的次数，并按照以下格式输出输出结果:
a (5) b (4) c (3) d (2) e (1) */
//定义字符串
String str = "aababcabcdabcde";
//创建TreeMap对象
TreeMap <Character , Integer> tm =new TreeMap<>();
//遍历得到字符串每一个字符
for (int i = 0; i < str.length(); i++) {
    if(tm.containsKey(str.charAt(i))){
        //如果键已存在,值加一
        Integer count = tm.get(str.charAt(i));
        count ++;
        tm.put(str.charAt(i),count);
    }else {
        //键不存在,添加新的键
        tm.put(str.charAt(i),1);
    }
}
//格式化输出(利用Lambda表达式)
tm.forEach((character, integer) -> System.out.print(character+"("+ integer + ")")         
```

# 可变参数
可变参数:一个大胖子,有多少吃多少

1．可变参数本质上就是一个数组

2．作用:在形参中接收多个数据

3．格式:数据类型...参数名称

举例: int...a

4．注意事项:

形参列表中可变参数只能有一个可变参数必须放在形参列表的最后面

```ruby
public static void main(String[] args) {
    //JDK5
    //可变参数
    //方法形参的个数是可以发生变化的，0 1 2 3 ...
    //格式:属性类型...名字
    //int. . .args
    System.out.println(getSum(1, 2, 3, 4, 5, 6, 7));
}

//底层:
//可变参数底层就是一个数组
//只不过不需要我们自己创建了，Java会帮我们创建好
public static int getSum(int ... args){
    int sum = 0;
    for (int arg : args) {
        sum += arg;
    }
    return sum;
}
```

# Collections
java.util.Collections:是集合工具类

作用:Collections不是集合，而是集合的工具类。

Collections常用API
![image](https://user-images.githubusercontent.com/88382462/220858621-3db3b304-c5ca-4be9-b12f-41f0b91f7d5d.png)
![image](https://user-images.githubusercontent.com/88382462/220858751-2fec447e-19a2-494b-9e62-8d7f261ee4f5.png)

**Arraylist排序可以用collection里的sort方法，不需要转成TreeSet**

```ruby
ArrayList<String> list = new ArrayList<>();

//批量添加元素
Collections.addAll(list,"abc","abc","abc","qwer","zxcv");
System.out.println(list);   //[abc, abc, abc, qwer, zxcv]

//shuffle
Collections.shuffle(list);
System.out.println(list);   //[abc, zxcv, qwer, abc, abc]
```

**序号排序法**

如果原始数据的规律非常复杂，我们可以先手动排序让每一个数据跟唯一的序号产生对应关系。

序号就是数字，规律非常简单，后续的所有操作，我们以序号为准

当真正需要操作原始数据时候，再通过序号找到原始数据即可。


# 不可变集合

不可变集合应用场景:

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

## 创建不可变集合书写格式

在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。

|方法名称	|说明 |
| --- | --- |
|static<E> List<E> of(E...elements) |	创建一个具有指定元素的List集合对象 |
|static<E> Set<E> of(E...elements)	  |创建一个具有指定元素的Set集合对象 |
|static<K , V> Map<K , V> of(E...elements) |	创建一个具有指定元素的Map集合对象 |

注意:这个集合不能添加，不能删除，不能修改。

当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
 
 ```
 创建Map的不可变集合
 细节1：
     键是不能重复的
 细节2：
     Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对
 细节3：
     如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法
     ofEntries(Entry<? extends K, ? extends V>... entries)
 ```

不可变集合创建例程

```ruby
List<String> list = List.of("张三", "李四", "王五", "赵六");
Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");
Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",
                "赵六", "广州", "孙七", "深圳", "周八", "杭州",
                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
                "陈二", "嘉兴");
```

如果要存超过10对键值对的不可变map集合

```ruby
//1.创建一个普通的Map集合
HashMap<String, String> hm = new HashMap<>();
hm.put("张三", "南京");
hm.put("李四", "北京");
hm.put("王五", "上海");
hm.put("赵六", "北京");
hm.put("孙七", "深圳");
hm.put("周八", "杭州");
hm.put("吴九", "宁波");
hm.put("郑十", "苏州");
hm.put("刘一", "无锡");
hm.put("陈二", "嘉兴");
hm.put("aaa", "111");

//2.利用上面的数据来获取一个不可变的集合
//获取到所有的键值对对象（Entry对象）
Set<Map.Entry<String, String>> entries = hm.entrySet();
//把entries变成一个数组
Map.Entry[] arr1 = new Map.Entry[0];
//toArray方法在底层会比较集合的长度跟数组的长度两者的大小
//如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组
//如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用
Map.Entry[] arr2 = entries.toArray(arr1);
//不可变的map集合
Map map = Map.ofEntries(arr2);
```

简化写法

```ruby
Map<String, String> map = Map.copyOf(hm);
```








