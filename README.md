# basic-code
学习java  来自“黑马程序员”
自己学着写的一些代码和笔记
www.bilibili.com/video/BV17F411T7Ao/

# ASCII码表
![image](https://user-images.githubusercontent.com/88382462/191399708-bb773f47-edba-4dc2-bd5e-e0a0f3a02a49.png)

# StringBulider
![image](https://user-images.githubusercontent.com/88382462/191155163-0dd85d31-26d6-4895-b6db-71f2d8e48e37.png)
![image](https://user-images.githubusercontent.com/88382462/191155287-762282d0-aa3b-4bdd-914f-8a16fd8168b6.png)


# StringJoiner
![image](https://user-images.githubusercontent.com/88382462/191153955-746ade56-8bb6-4977-a477-283ca3bc60a8.png)
![image](https://user-images.githubusercontent.com/88382462/191154100-0753ce4d-bed5-4464-90f6-6e571ac6a467.png)

# String 原理
![image](https://user-images.githubusercontent.com/88382462/191155697-a474ae17-1173-4f39-b7e1-50ad72a37499.png)
![image](https://user-images.githubusercontent.com/88382462/191155904-e568b602-ad33-4c75-878e-065b95103c9d.png)

## 在涉及变量的拼接：
![image](https://user-images.githubusercontent.com/88382462/191156880-ece65d93-e280-4cec-bf0f-25e77dac2d1d.png)

![image](https://user-images.githubusercontent.com/88382462/191157706-1e27a209-d65a-46c9-bb26-355eb8a9a50d.png)
![image](https://user-images.githubusercontent.com/88382462/191157852-7e1150a1-6dc9-41c2-a8f1-c083fe3ed9d1.png)

![image](https://user-images.githubusercontent.com/88382462/191158030-5208296e-7707-43b3-8512-1b8b639d74b2.png)

# 集合
## 集合和数组的区别
![image](https://user-images.githubusercontent.com/88382462/191681113-d181f93b-dc67-463e-9b6d-de873e11c33d.png)

## 创建集合
![image](https://user-images.githubusercontent.com/88382462/191681168-12a4df9e-556c-4890-99c0-425ee8b83e4a.png)
## ArrayList成员方法
![image](https://user-images.githubusercontent.com/88382462/191681202-a6828d87-5eac-4c7d-9125-196664de8416.png)

![image](https://user-images.githubusercontent.com/88382462/191681249-8ae97d4b-f69d-4d5c-b8b2-a8f252fdf324.png)
![image](https://user-images.githubusercontent.com/88382462/191681279-d47458c5-8cc2-4f5c-b31d-10c501e768a0.png)
## 基本数据类型的包装类
![image](https://user-images.githubusercontent.com/88382462/191681309-dbce7e0d-16d5-4614-835a-a61f72a16740.png)
![image](https://user-images.githubusercontent.com/88382462/191681357-4e1e2a00-12bc-4f50-a64b-504f986c4408.png)

## 当循环嵌套时想退出外面的循环
![image](https://user-images.githubusercontent.com/88382462/191693489-485ca7dc-03ff-4051-9732-f7c087ecbdff.png)

# static
## 内存分析
![image](https://user-images.githubusercontent.com/88382462/192304073-f85684a5-954f-4247-94ed-fd353dc365c5.png)
![image](https://user-images.githubusercontent.com/88382462/192304670-74834351-597c-419f-81ae-a937055c4527.png)
![image](https://user-images.githubusercontent.com/88382462/192304854-b2bc9c63-b6af-40a4-97dd-7702be041948.png)
![image](https://user-images.githubusercontent.com/88382462/192305802-505213c1-8d53-464e-aaa1-3dad22fde0fb.png)

## 工具类
### 工具类描述
![image](https://user-images.githubusercontent.com/88382462/192308437-5af3525f-8043-4630-884f-09229393036d.png)
![image](https://user-images.githubusercontent.com/88382462/192309085-c3b4002e-7258-40f9-96b9-6c6544032a8d.png)

## static 关键字
![image](https://user-images.githubusercontent.com/88382462/192316588-29ac02f0-db94-4db4-9e70-36f0d0739e66.png)

## static 注意事项
![image](https://user-images.githubusercontent.com/88382462/192316904-a425d31f-c6b4-4136-ae32-9f9706334dc3.png)


# 封装和继承
## 封装图解
![image](https://user-images.githubusercontent.com/88382462/192415469-a34ea306-7f65-4740-a7f8-a45de43af7d6.png)

## 继承

### 继承的定义及好处
![image](https://user-images.githubusercontent.com/88382462/192416569-a9f9a1c5-1e18-40b9-93c6-d66e6796cab8.png)

![image](https://user-images.githubusercontent.com/88382462/192416738-f0a01b2a-2978-47e7-a9a8-44a8f0367ab3.png)

![image](https://user-images.githubusercontent.com/88382462/192416905-b47ee3e4-53af-4321-947e-32c27edff7d6.png)

### 继承的格式
![image](https://user-images.githubusercontent.com/88382462/192417934-f56a5bfe-5ad1-42a5-aa6b-70eba4e3608e.png)

![image](https://user-images.githubusercontent.com/88382462/192418395-a71d9e29-980e-41d6-a9e1-dafb78cdb9f5.png)

### 继承中成员变量的访问特点
![image](https://user-images.githubusercontent.com/88382462/192470608-a3ab47c5-96f0-410c-b124-2aad27d55e94.png)

![image](https://user-images.githubusercontent.com/88382462/192729991-69d7e9e4-02f7-4055-9c1f-014acd9bf3b7.png)

![image](https://user-images.githubusercontent.com/88382462/192730532-b4b46699-12e4-45f4-8e87-8c03b445ca37.png)

![image](https://user-images.githubusercontent.com/88382462/192733170-5553bda4-2439-49e5-b234-2851ef02bf16.png)

### 继承中成员方法的访问特点
![image](https://user-images.githubusercontent.com/88382462/192733283-923e1df5-c625-4112-a248-e74e5a94cfcb.png)

![image](https://user-images.githubusercontent.com/88382462/192735006-f4046805-d193-4dc9-bbda-5903fc419dfd.png)

![image](https://user-images.githubusercontent.com/88382462/192735504-55e535e9-eee0-49fe-a52a-f2b3108a3d1d.png)

![image](https://user-images.githubusercontent.com/88382462/192736250-1be90fd5-642c-4b35-91a7-76ad5f3419d4.png)

![image](https://user-images.githubusercontent.com/88382462/192742068-11b7d9a9-1d72-4f36-afd8-be42e9f89454.png)

### 继承中构造方法的访问特点
![image](https://user-images.githubusercontent.com/88382462/192742588-5d1e408a-ae98-44f2-89ce-a75ba33267d8.png)

![image](https://user-images.githubusercontent.com/88382462/192744675-ac244198-c158-4cab-827a-8151e9766c6e.png)

### this/super 使用总结
![image](https://user-images.githubusercontent.com/88382462/192746319-824bdb7d-011a-41a3-ad74-2950e53495c3.png)

![image](https://user-images.githubusercontent.com/88382462/192746886-4d33f32a-db60-4a65-a6da-3ce87af066e9.png)

## 多态

### 什么是多态
![image](https://user-images.githubusercontent.com/88382462/193443335-096a6f91-f6f7-4176-a72d-c11d7d5d0ef4.png)

![image](https://user-images.githubusercontent.com/88382462/193443788-4539d724-0449-4690-b311-4defa0559bdb.png)

### 多态调用成员变量和成员方法的特点
![image](https://user-images.githubusercontent.com/88382462/193443816-72ea183c-721b-44b7-b120-0baeb34adcf4.png)

**调用成员变量:编译看左边，运行也看左边**

编译看左边: javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。

运行也看左边: java运行代码的时候，实际获取的就是左边父类中成员变量的值

**调用成员方法:编译看左边，运行看右边**

编译看左边: javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。

运行看右边: java运行代码的时候，实际上运行的是子类中的方法。

### 多态的优势
![image](https://user-images.githubusercontent.com/88382462/193444370-6abd8aba-8969-4499-85c4-4a866aa16d8e.png)

### 多态的弊端
**不能调用子类的特有功能**

调用会报错,报错的原因?

当调用成员方法的时候，编译看左边，运行看右边

那么在编译的时候会先检查左边的父类中有没有这个方法，如果没有直接报错。

解决方案:

变回子类类型就可以了（可以用强制转换）（但是瞎转转成其他的对象就会报错）

可以用instanceof来判断对象是什么类型的

![image](https://user-images.githubusercontent.com/88382462/193444895-5379e9b7-707e-4bd1-bda4-1df4ff106bb9.png)

![image](https://user-images.githubusercontent.com/88382462/193445015-6ce2109b-6a93-47dd-84ae-2c35afcd67bf.png)

![image](https://user-images.githubusercontent.com/88382462/193445071-d6231b8c-3518-44cf-b915-22fab0dc3d17.png)

### 多态总结
![image](https://user-images.githubusercontent.com/88382462/193445126-da9512d4-5399-4961-9c7f-af2eb7e1876c.png)

# 包
## 包的定义
![image](https://user-images.githubusercontent.com/88382462/193446805-7f347726-8623-455a-aa3f-488d0baeec2a.png)
## 导包
![image](https://user-images.githubusercontent.com/88382462/193446840-70b0a958-a83c-4b3a-9698-3b907a67be27.png)
![image](https://user-images.githubusercontent.com/88382462/193446859-b8d12557-8e98-47a1-9795-2f6e17670ac5.png)
![image](https://user-images.githubusercontent.com/88382462/193447098-53feddfa-3c23-4920-bf77-2f6459d4fe41.png)

## final关键字
![image](https://user-images.githubusercontent.com/88382462/193462016-7ec4148f-427c-45f8-b036-cc376f876385.png)

![image](https://user-images.githubusercontent.com/88382462/193462339-431f325e-516d-4dd2-a834-eaf93fc3dcc9.png)

![image](https://user-images.githubusercontent.com/88382462/194689623-3bc7be28-2a4c-4f96-b9fe-a8ef5b5b9c7d.png)
 
 ## 权限修饰符分类和使用规则
![image](https://user-images.githubusercontent.com/88382462/194888059-6035f9b8-c882-4d9a-ad46-316fc4566c7f.png)

## 构造代码块
![image](https://user-images.githubusercontent.com/88382462/194889136-d35f4f08-620b-4d4b-8868-6d54f440fe3d.png)

但是构造代码块很少使用，如果多个构造方法有一些相同的代码可以用以下的方式
![image](https://user-images.githubusercontent.com/88382462/194890863-95023260-7f07-44ee-b90c-26ffe50786f6.png)

### 静态代码块

![image](https://user-images.githubusercontent.com/88382462/194895174-20e9d72a-646d-4411-b7a8-6b1451143d6c.png)

## 抽象方法和抽象类
![image](https://user-images.githubusercontent.com/88382462/194896373-61105c1f-8748-42fd-988a-8b181332aba0.png)

![image](https://user-images.githubusercontent.com/88382462/194896523-1654cc9a-df52-4efa-a152-1e091bdefc1a.png)
 
 ![image](https://user-images.githubusercontent.com/88382462/194897297-542c908f-421d-4a3c-a74a-865f9d02dc19.png)

 # 接口
 ## 接口定义和使用
 ![image](https://user-images.githubusercontent.com/88382462/195065577-fbdf768a-5060-4811-a685-61abccaeec94.png)

 ![image](https://user-images.githubusercontent.com/88382462/195073694-05c38cc1-a574-41c3-9e9a-86dce0e12e99.png)
 
## 接口中成员特点 
![image](https://user-images.githubusercontent.com/88382462/195078798-3681c96d-6718-4f16-8291-82278773fe14.png)

## 接口和类的关系
![image](https://user-images.githubusercontent.com/88382462/195083063-26424218-1de6-4d89-bb2e-9d469f7b8402.png)

## JDK8和JDK9接口新增方法
![image](https://user-images.githubusercontent.com/88382462/195088563-1fb53c54-045b-48d8-b510-7ccb82b32e49.png)

![image](https://user-images.githubusercontent.com/88382462/195090214-7be3fda3-19a7-4f11-a869-0a65d41d6142.png)

![image](https://user-images.githubusercontent.com/88382462/195091618-c05e421b-0d9b-433b-bf9b-51433cbedb00.png)
 
![image](https://user-images.githubusercontent.com/88382462/195093990-dc58c43b-025e-44dc-9c97-7dc6ce19d777.png)

![image](https://user-images.githubusercontent.com/88382462/195094439-fb2cb0da-d8d9-4d97-8323-c15e7721e7de.png)
  
 ![image](https://user-images.githubusercontent.com/88382462/195094808-f6a4c0c4-1903-41bb-a94b-bfac6c4f9589.png)

![image](https://user-images.githubusercontent.com/88382462/195252965-d6816991-33a0-441d-8502-e849aa031a6f.png)

## 接口多态
当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。
![image](https://user-images.githubusercontent.com/88382462/195253161-c69b1e31-1e7a-4a97-a587-78dff5b2e33f.png)

## 适配器设计模式
![image](https://user-images.githubusercontent.com/88382462/195254134-50fc1e71-96f5-4cb4-a337-f9bce80aa09e.png)

# 内部类
## 什么是内部类
![image](https://user-images.githubusercontent.com/88382462/195254292-1a41f7e2-ab97-48f3-b150-018170f2d1ed.png)

![image](https://user-images.githubusercontent.com/88382462/195254397-53904668-9f72-4e0b-9434-6cb4d413520c.png)

![image](https://user-images.githubusercontent.com/88382462/195254619-7c654814-f7a8-489a-8f24-be07ca01de38.png)

## 内部类分类
![image](https://user-images.githubusercontent.com/88382462/195256185-7aef5fc1-85d2-4be1-907a-c49d9dca4596.png)
### 成员内部类
![image](https://user-images.githubusercontent.com/88382462/195256696-9eb4026c-fa5c-4693-bb03-22065e2bcd6f.png)
![image](https://user-images.githubusercontent.com/88382462/195256859-66e2ceea-ce8e-4ea3-bef8-2f9baea508eb.png)
![image](https://user-images.githubusercontent.com/88382462/195257342-e49f4f13-ddea-443d-bec8-5c89d630ffad.png)
#### 内部类内存图
![image](https://user-images.githubusercontent.com/88382462/195263171-1bfd870d-b798-4901-a7d8-e9d752a3a8f3.png)
#### 成员内部类总结
![image](https://user-images.githubusercontent.com/88382462/195263454-432b485c-6c2c-40c0-97ea-c0e13d9dbe15.png)
### 静态内部类
![image](https://user-images.githubusercontent.com/88382462/195263693-86c89bbe-33aa-4625-8743-70fd6a976428.png)
### 局部内部类
![image](https://user-images.githubusercontent.com/88382462/195792742-0a970046-f7eb-4283-a96e-036502c5f61d.png)

### 匿名内部类(重要)
![image](https://user-images.githubusercontent.com/88382462/195794365-d429243f-b87e-4bce-a16a-5c23d8af1cf6.png)
![image](https://user-images.githubusercontent.com/88382462/195796546-a7d68049-352a-4c40-8e2c-baa1bd8fe3c4.png)
![image](https://user-images.githubusercontent.com/88382462/196916464-8b47eaca-d82d-4964-8244-40bc1494f54d.png)
![image](https://user-images.githubusercontent.com/88382462/196920860-7b162a88-584f-419f-8055-182fb4d5a757.png)

# GUI(Jframe)
![image](https://user-images.githubusercontent.com/88382462/196923244-775afbb2-8060-4180-9380-1359fe8f6c9f.png)
![image](https://user-images.githubusercontent.com/88382462/197311400-95c798c7-8aef-4889-9161-9ddabb3bd62c.png)
![image](https://user-images.githubusercontent.com/88382462/197311393-a51119d9-8f19-4c12-8f15-ab97719ec90a.png)
![image](https://user-images.githubusercontent.com/88382462/197311465-67557037-1e27-440f-9f19-568d9efe1dd1.png)
![image](https://user-images.githubusercontent.com/88382462/197311490-e726f93c-595d-4631-8b37-d5393f15b2e8.png)
![image](https://user-images.githubusercontent.com/88382462/197316325-30d3b4e3-e44f-4368-805f-d7172e3508d5.png)
![image](https://user-images.githubusercontent.com/88382462/197316480-e1679369-d7b3-423c-842e-05a8ed6855f7.png)
![image](https://user-images.githubusercontent.com/88382462/197980394-ac2e4889-8a87-4f15-b355-911d259c8e1a.png)
![image](https://user-images.githubusercontent.com/88382462/197989772-d1602dde-ca13-4023-a284-58ad0c24227e.png)
![image](https://user-images.githubusercontent.com/88382462/197989820-81550170-7a16-4654-adb8-16b06dbb5062.png)
![image](https://user-images.githubusercontent.com/88382462/197994468-5dc80479-3257-438a-8f06-4c8e6e8ff296.png)
![image](https://user-images.githubusercontent.com/88382462/197994598-977efe20-8e35-455b-aee9-612fd103364a.png)

# 一些常用工具类
## MATH类
![image](https://user-images.githubusercontent.com/88382462/200764190-add2f3ff-7071-4071-b3dc-d7459cfad150.png)
![image](https://user-images.githubusercontent.com/88382462/201478751-88158b35-9573-4560-8666-e6d6a60d3f9a.png)
![image](https://user-images.githubusercontent.com/88382462/201479007-4d835e91-944c-4cfd-9d09-63902ce8fbd0.png)

## SYSTEM
![image](https://user-images.githubusercontent.com/88382462/201480948-747235d7-4ee7-4247-8323-ea8e334bb10a.png)
![image](https://user-images.githubusercontent.com/88382462/201480916-681590ad-dfc9-4f01-b29b-7edf57f5a6a6.png)
![image](https://user-images.githubusercontent.com/88382462/201482246-f7a516da-df49-456a-b281-d3617273214a.png)

## RUNTIME
![image](https://user-images.githubusercontent.com/88382462/201514149-0d7deccb-1cc6-4e42-b0bc-8b6bd64125cd.png)
![image](https://user-images.githubusercontent.com/88382462/201514159-35c94581-09c1-45b9-b09c-8536a88b4b61.png)

## OBJECT
### Object构造方法
![image](https://user-images.githubusercontent.com/88382462/201514278-3ac501be-4849-409f-b462-496bd1682f7c.png)
### Object成员方法
![image](https://user-images.githubusercontent.com/88382462/201514302-75ea8fa9-2a31-4df3-93f3-37b2ceab4338.png)
 #### 重写toString
 ![image](https://user-images.githubusercontent.com/88382462/201514715-57b9d985-4a52-4457-a2bf-d5c6ad72b670.png)

![image](https://user-images.githubusercontent.com/88382462/201514989-434ce7c2-7c42-4f75-883f-7c168386e60d.png)
#### 重写equals
![image](https://user-images.githubusercontent.com/88382462/201515215-4164c423-e8f8-45d1-adab-7f0e079b6771.png)
![image](https://user-images.githubusercontent.com/88382462/201515557-bad20d9e-b956-473e-bea1-6dba832f6a0c.png)
#### 对象克隆(浅克隆和深克隆)
![image](https://user-images.githubusercontent.com/88382462/201515746-d5ce739d-7abf-4033-a68c-d34d22e2060c.png)
![image](https://user-images.githubusercontent.com/88382462/201516056-5640170d-598f-447d-93d9-42b2f6e18310.png)
![image](https://user-images.githubusercontent.com/88382462/201516124-5bf37ad7-e7a6-4a9d-a0ae-10d8b105e285.png)
![image](https://user-images.githubusercontent.com/88382462/201516181-544615e3-a52f-445d-afe6-bf347922bf86.png)
![image](https://user-images.githubusercontent.com/88382462/201516200-a6203523-0440-44f4-9c9b-6d48a1b6db4d.png)
![image](https://user-images.githubusercontent.com/88382462/201516281-18aa38a7-d90d-41f0-992b-92ec1464736c.png)
##### 第三方工具实现深克隆
![image](https://user-images.githubusercontent.com/88382462/201516765-cb35da72-235e-4658-b6e0-a7002a3be0f3.png)
### Object总结
![image](https://user-images.githubusercontent.com/88382462/201516792-8fc81685-3c07-4076-a7f3-591ec34126f3.png)

## OBJECTS
![image](https://user-images.githubusercontent.com/88382462/201690011-372cf37d-0e12-447c-b798-77ce08830a97.png)
![image](https://user-images.githubusercontent.com/88382462/201691646-428c632f-4839-42b0-9922-d7d0dcb3cae2.png)

## BigInteger
![image](https://user-images.githubusercontent.com/88382462/201692963-c96f9e39-0412-4c6b-bef3-da4ffa52da7e.png)
![image](https://user-images.githubusercontent.com/88382462/201699816-16fd12bf-1f51-4e0d-a4d0-a4bb4c4a6bbc.png)
![image](https://user-images.githubusercontent.com/88382462/201700211-fc75ea3e-d7ea-450b-b6a4-8e3b93f4e562.png)


## BigDecimal
![image](https://user-images.githubusercontent.com/88382462/201882203-a45ba5d2-f136-4b7b-b15c-00548dc1809e.png)
![image](https://user-images.githubusercontent.com/88382462/201885104-d50ef8b8-c98a-40c6-b3c5-957b8f1c30bc.png)
![image](https://user-images.githubusercontent.com/88382462/201885266-1bd73863-eb04-4777-a8f9-17b8164b2b92.png)
![image](https://user-images.githubusercontent.com/88382462/201888770-8783e06d-f643-48a9-be1e-928c8f94ed7b.png)

## Regex:正则表达式
![image](https://user-images.githubusercontent.com/88382462/201891646-35a26245-721d-41a6-babe-cd7b72d0846c.png)
![image](https://user-images.githubusercontent.com/88382462/201895122-97145d02-c0a1-4726-816d-e8c99c234f19.png)
![image](https://user-images.githubusercontent.com/88382462/201907062-e2d2178f-c424-49e8-8488-046e336ecab9.png)
![image](https://user-images.githubusercontent.com/88382462/201907135-ab359d3e-e114-4059-bbef-d7096e851079.png)
![image](https://user-images.githubusercontent.com/88382462/202378983-caf2d3ff-5b28-49da-aa9f-44ce40229342.png)
![image](https://user-images.githubusercontent.com/88382462/202379282-b9b949e9-f4e5-4c19-83d5-7ca6f15b59f3.png)
![image](https://user-images.githubusercontent.com/88382462/202381946-5fdf2a68-de36-4952-b9d0-cb4728429b3d.png)
![image](https://user-images.githubusercontent.com/88382462/202381707-ff552fba-6ed7-4209-adcf-f860bc6cdc6c.png)
![image](https://user-images.githubusercontent.com/88382462/202384021-835bf7eb-50f7-4147-b6c0-7a8061ddbeb3.png)
![image](https://user-images.githubusercontent.com/88382462/202396066-fa97c7c4-063f-4b4e-946e-36793d139985.png)
![image](https://user-images.githubusercontent.com/88382462/202397774-ac59c0d8-6a75-437b-a06c-93ae2920ae64.png)
![image](https://user-images.githubusercontent.com/88382462/202397837-a7d8be09-8e71-498c-a359-74739af8d980.png)
 ![image](https://user-images.githubusercontent.com/88382462/202402297-a0f728a0-8611-4c6c-8ee8-4fb8a7a38f75.png)
![image](https://user-images.githubusercontent.com/88382462/202896767-c63628d6-7b28-45eb-8a7a-9ace7a9778b8.png)
![image](https://user-images.githubusercontent.com/88382462/202897128-e32b547c-b209-4337-a7af-57e5a12888b2.png)
![image](https://user-images.githubusercontent.com/88382462/202897150-d2d0c30b-c247-45c6-bdc5-baf392e0180e.png)
![image](https://user-images.githubusercontent.com/88382462/202897249-10cfb18a-caa6-4a0f-b681-4c4661dd3d2f.png)
![image](https://user-images.githubusercontent.com/88382462/202897296-9d4f2289-76b4-4e29-9dde-0f06e5baac57.png)
![image](https://user-images.githubusercontent.com/88382462/202897438-7488ebcd-f9bc-46f7-be2a-e15f5bd07a19.png)
## Date
![image](https://user-images.githubusercontent.com/88382462/202897519-4ec553e9-35da-4ca9-b5e3-e39077141c72.png)
![image](https://user-images.githubusercontent.com/88382462/202897625-7919bea0-732b-4f10-a493-4be8d0fcaca2.png)
![image](https://user-images.githubusercontent.com/88382462/202899396-8a052354-fc84-47ee-8f19-9e935d86af34.png)
## SimpleDateFormat (时间格式化和解析)
![image](https://user-images.githubusercontent.com/88382462/202899912-18fea89a-87f4-47c6-b44d-e24a4acd6950.png)
![image](https://user-images.githubusercontent.com/88382462/202899960-babd0bab-95a3-4fb4-b063-4be4679a7a47.png)
![image](https://user-images.githubusercontent.com/88382462/202900038-d3f8f862-561f-49dc-ab6c-f18d80b43447.png)
 ![image](https://user-images.githubusercontent.com/88382462/202900074-2bdac03f-ae4d-49f7-b7f8-56c84d3505f0.png)
![image](https://user-images.githubusercontent.com/88382462/202900513-78ecfe63-b42e-40f3-818e-bdac7df157b8.png)
![image](https://user-images.githubusercontent.com/88382462/202900516-43fc6521-2c63-45b7-a704-7e96d02acfb5.png)
![image](https://user-images.githubusercontent.com/88382462/202901290-f3639bf6-54a1-4ba0-be06-cf003098f28f.png)
## Calendar
 ![image](https://user-images.githubusercontent.com/88382462/202901362-473c798f-a850-4d74-8617-6ffb22119f7b.png)
![image](https://user-images.githubusercontent.com/88382462/202901698-05eabdb5-2053-4593-b96f-cfecbb2134dc.png)
![image](https://user-images.githubusercontent.com/88382462/202902188-746bb30a-6127-47cf-833e-e57464239a08.png)
![image](https://user-images.githubusercontent.com/88382462/202902498-f8ed29ef-4580-4544-a0d2-23f4122327cb.png)
## Jdk8以后时间类
![image](https://user-images.githubusercontent.com/88382462/202902519-75dcc771-1d28-4578-9ec4-fb775e4b553d.png)
### ZoneId 时区
![image](https://user-images.githubusercontent.com/88382462/202902569-9819cbd4-f0b2-4453-b8af-f4d0eb0ae724.png)
![image](https://user-images.githubusercontent.com/88382462/202902578-302921e8-6423-4ea5-99d7-ac0bf4bb246a.png)
![image](https://user-images.githubusercontent.com/88382462/202902982-4d5f9175-d64d-4b6f-8073-cc14e07d3752.png)
### Instant 时间戳
![image](https://user-images.githubusercontent.com/88382462/202903027-4fb5cb6e-66c0-4f73-ae6e-754b30789bfa.png)
![image](https://user-images.githubusercontent.com/88382462/202903553-1250c6e6-9c23-47b4-b283-0c64e30c862a.png)
### ZoneDateTime 带时区的时间
![image](https://user-images.githubusercontent.com/88382462/202903594-5f38298d-d683-44b0-80d3-9fb6a06aac2b.png)
![image](https://user-images.githubusercontent.com/88382462/202903883-a41d9760-b0be-44e0-aed6-1c858f0bc47e.png)
### DateTimeFormatter 用于时间的格式化和解析
![image](https://user-images.githubusercontent.com/88382462/202903984-ba2bc7af-d687-4013-9e74-1b5d574a3083.png)
![image](https://user-images.githubusercontent.com/88382462/202903989-3e048940-bb5c-4da4-a1c7-b5d4c4195b87.png)
## LocalDate LocalTime LocalDateTime
![image](https://user-images.githubusercontent.com/88382462/203062932-e0db39e1-a8a6-4427-882e-1e680379d5cb.png)
![image](https://user-images.githubusercontent.com/88382462/203067139-14949efd-d5d6-48f6-bcc5-cf6cd01afa7a.png)
![image](https://user-images.githubusercontent.com/88382462/203067711-89ac5ade-b35c-46fe-95ee-4c3470e073ce.png)
![image](https://user-images.githubusercontent.com/88382462/203068644-2aa13d94-21f0-4f07-ac95-9c442b85ce00.png)


# 包装类
![image](https://user-images.githubusercontent.com/88382462/203069149-21c93513-2bec-4107-800b-f822cf8b6dff.png)
![image](https://user-images.githubusercontent.com/88382462/203070078-edbcfe8b-290b-40cb-8e0d-8fd1af4dc5c7.png)
![image](https://user-images.githubusercontent.com/88382462/203071231-3a79771a-bcb3-4d58-9818-5ee5c531eb79.png)
![image](https://user-images.githubusercontent.com/88382462/203071418-57ff286a-4e93-4abd-8c42-c81b9eaf6d57.png)
![image](https://user-images.githubusercontent.com/88382462/203071642-4c31716d-0150-4492-b93c-8b215265d65d.png)
## Integer
![image](https://user-images.githubusercontent.com/88382462/203071759-b534efe5-d69a-4228-9d29-dcb017e830f0.png)
![image](https://user-images.githubusercontent.com/88382462/203072800-9f54bcba-f358-44b3-9559-5d758ffdf046.png)
# 键盘录入更规范的写法
![image](https://user-images.githubusercontent.com/88382462/203073493-8a53cfa2-c812-49e8-bf02-6d87fe6b2462.png)

练习
![image](https://user-images.githubusercontent.com/88382462/203094884-4ec17fd0-63d1-4d1c-a735-acfdf5d132ce.png)
![image](https://user-images.githubusercontent.com/88382462/203094789-03a71d43-3914-4aa0-b784-1dc978f9d607.png)

====================================================================================
# 查找
## 基本查找/顺序查找
![image](https://user-images.githubusercontent.com/88382462/203272542-b0860da3-10c5-43ac-ad50-b9d472cd718b.png)
## 二分查找
![image](https://user-images.githubusercontent.com/88382462/203273128-bb9b0a2b-9458-41d2-9c3c-e0efebb7685e.png)
![image](https://user-images.githubusercontent.com/88382462/203274122-60f823c0-6c78-4559-88f2-b6582b676d3e.png)
![image](https://user-images.githubusercontent.com/88382462/203276350-00e33a09-164c-493a-a60e-25e54d4c2746.png)
## 插值查找
![image](https://user-images.githubusercontent.com/88382462/203276840-b9e801c8-4f2d-494d-8dd3-8534ae2faa22.png)
## 斐波那契查找
![image](https://user-images.githubusercontent.com/88382462/203277104-1939a944-e8f1-473d-adb6-974e3f174721.png)
## 二分/插值/斐波那契查找各自的特点
![image](https://user-images.githubusercontent.com/88382462/203277398-33d58c8a-99b1-4cba-a8f4-8b2f239ebf35.png)
## 分块查找
![image](https://user-images.githubusercontent.com/88382462/203277952-d6d1a2f0-7cf6-4751-9f88-97fe985c118d.png)
### 拓展的分块查找
![image](https://user-images.githubusercontent.com/88382462/203280577-960902ae-985e-4029-b315-d099fe1ca836.png)
![image](https://user-images.githubusercontent.com/88382462/203281332-267a683a-8a38-4a0c-8adb-70e68dd0d522.png)
## 七种查找方式
![image](https://user-images.githubusercontent.com/88382462/203281476-6d25d58b-b998-4ac2-9790-82318be9ed3a.png)

# 排序
## 四种排序
![image](https://user-images.githubusercontent.com/88382462/204125316-0fea450a-efc3-4653-a8e1-ea9136c5147a.png)
## 冒泡排序
![image](https://user-images.githubusercontent.com/88382462/204125441-8a380509-07f8-443d-ab95-d3887dd7e1c6.png)
![image](https://user-images.githubusercontent.com/88382462/204125608-b4049365-926b-4e13-9a51-a5c49d96352e.png)
## 选择排序
![image](https://user-images.githubusercontent.com/88382462/204125779-e2556b86-4247-4bc9-8fc0-4b020f5c2b38.png)
## 插入排序
![image](https://user-images.githubusercontent.com/88382462/204126092-bcb803a5-3781-4c06-8893-47b3caa5d02f.png)
## 递归
![image](https://user-images.githubusercontent.com/88382462/204126188-d4d1fec1-a095-48ae-b5b7-27242e6d6d8b.png)
![image](https://user-images.githubusercontent.com/88382462/204126218-9e7b8468-2c80-4b7c-ab00-7ed91274e81b.png)
![image](https://user-images.githubusercontent.com/88382462/204126447-f7c01fee-3ec3-4544-b947-4b0ba751fd68.png)
![image](https://user-images.githubusercontent.com/88382462/204126604-d6f5cd47-d5d5-4380-8040-d22a6180e829.png)
## 快速排序
![image](https://user-images.githubusercontent.com/88382462/204126791-6564be36-508b-4c8e-a5e4-69921f2de601.png)
![image](https://user-images.githubusercontent.com/88382462/204128602-ac11012e-0486-4f81-869e-fcc4d42c4452.png)
## 排序总结
![image](https://user-images.githubusercontent.com/88382462/204128653-c75cf7cf-edb2-4d5c-ba00-fb0ddc33175d.png)

# Arrays
![image](https://user-images.githubusercontent.com/88382462/204129419-2c2990fe-ecd9-434e-a642-0397bbb63549.png)
![image](https://user-images.githubusercontent.com/88382462/212838345-b5df044a-c7f0-4987-8758-0a85a3f40fc4.png)
![image](https://user-images.githubusercontent.com/88382462/212838577-6c0f78ee-a296-485a-95dd-13d66b733cc9.png)
![image](https://user-images.githubusercontent.com/88382462/212840022-05df4f80-1740-40d0-887d-e66a1941d416.png)
![image](https://user-images.githubusercontent.com/88382462/212841260-4843be3b-938d-4066-bae3-195775ba72cc.png)
![image](https://user-images.githubusercontent.com/88382462/212843080-3344b9e5-1e09-4d7d-9b2a-e5ced56a77ef.png)
# Lambda表达式
![image](https://user-images.githubusercontent.com/88382462/212844111-18b06548-a878-471b-87f4-894c2965c257.png)
![image](https://user-images.githubusercontent.com/88382462/212844491-e2585351-7c52-47d4-a41d-72dc36b01929.png)
![image](https://user-images.githubusercontent.com/88382462/212844821-312a043d-cfe7-4e08-9a12-524b2b7691f2.png)
![image](https://user-images.githubusercontent.com/88382462/212846790-87b04796-d288-499d-9b06-24e390d604bf.png)
![image](https://user-images.githubusercontent.com/88382462/212846834-4a9a184a-873d-46ab-a2b5-bab380d2a37f.png)
![image](https://user-images.githubusercontent.com/88382462/212846974-1b2780e0-8f0a-474d-93ff-4eef4da674a3.png)
![image](https://user-images.githubusercontent.com/88382462/212847403-ef1b6ee4-3396-49f6-88d3-48cb08b5b018.png)
![image](https://user-images.githubusercontent.com/88382462/212847886-5f52aa37-6322-499b-aa7b-04c215adf758.png)
![image](https://user-images.githubusercontent.com/88382462/212848511-b143a293-219f-4d98-90b4-d77b1cd86244.png)
![image](https://user-images.githubusercontent.com/88382462/212850833-ec22ddc5-b582-4d90-9875-cc6e1802fbe0.png)

![image](https://user-images.githubusercontent.com/88382462/213338212-f465bea6-6138-4ff0-b4bd-1b97160efe7e.png)

# 集合进阶
![image](https://user-images.githubusercontent.com/88382462/216255773-8767ecee-e2c0-496e-8ae7-8d1f83fb36e9.png)
![image](https://user-images.githubusercontent.com/88382462/216256092-b126e33c-6113-4340-854b-f23a78dd2ae6.png)
## Collection集合
![image](https://user-images.githubusercontent.com/88382462/216256372-243aa9f5-39d4-41b1-bff8-af549627d4af.png)
![image](https://user-images.githubusercontent.com/88382462/216264717-872ce773-53b6-481e-a456-86ef27d1c4fe.png)
![image](https://user-images.githubusercontent.com/88382462/219992068-0b791076-6178-46e2-b2ba-777f776c1ce5.png)
![image](https://user-images.githubusercontent.com/88382462/219992083-1537850c-11dd-44ad-9366-194b265c77ab.png)
### Collection遍历方式
![image](https://user-images.githubusercontent.com/88382462/219992435-020faff8-1778-4115-842f-d817575c7eda.png)
#### 迭代器遍历
![image](https://user-images.githubusercontent.com/88382462/219992689-84aaea5c-50f8-495a-9b38-cf969119d9b4.png)
![image](https://user-images.githubusercontent.com/88382462/219993400-3e620c3e-2fca-4725-ae00-ebc4f17f30f9.png)
![image](https://user-images.githubusercontent.com/88382462/219993565-83b9b82d-d667-4361-a943-22ce3e514c72.png)
![image](https://user-images.githubusercontent.com/88382462/219993693-a31ea552-5484-45d8-b369-967ab5150c29.png)
![image](https://user-images.githubusercontent.com/88382462/219995025-e929098d-7ba4-4f51-80cb-f6737eb51e87.png)
![image](https://user-images.githubusercontent.com/88382462/219995141-8a890ec6-eaad-44fa-90b7-143aff9273c9.png)
![image](https://user-images.githubusercontent.com/88382462/219996316-29f7c66c-4233-4fc8-817f-c2c432454569.png)
![image](https://user-images.githubusercontent.com/88382462/219996961-2bf8b440-148b-4873-ada2-6dbb23acd9c4.png)
![image](https://user-images.githubusercontent.com/88382462/219997025-6f13b13c-f790-4166-8f86-5db02aac3f79.png)

#### 增强for遍历
![image](https://user-images.githubusercontent.com/88382462/219997360-cf27e5a1-6876-4209-9e4d-cd161c82a0d6.png)
![image](https://user-images.githubusercontent.com/88382462/219997562-9924c26f-1836-4550-a22e-b56e1446bf69.png)
![image](https://user-images.githubusercontent.com/88382462/219998454-e59fad6e-18bc-45f2-9ecc-0664acf0fa1c.png)

#### lambda表达式遍历
![image](https://user-images.githubusercontent.com/88382462/219998998-d200c272-aaa1-415b-98c8-a9cd82ef6ea5.png)
![image](https://user-images.githubusercontent.com/88382462/219999476-31d36b56-b155-4010-add3-d2efe674a982.png)
![image](https://user-images.githubusercontent.com/88382462/219999888-9ea24500-925e-48bd-8f9d-b4d43959137d.png)

## list集合
![image](https://user-images.githubusercontent.com/88382462/220021481-4ef87a57-3a2d-47a0-8a80-80ba90cf587e.png)

```
        List系列集合独有的方法：
            void add(int index,E element)       在此集合中的指定位置插入指定的元素
            E remove(int index)                 删除指定索引处的元素，返回被删除的元素
            E set(int index,E element)          修改指定索引处的元素，返回被修改的元素
            E get(int index)                    返回指定索引处的元素
```

```ruby
        //1.创建一个集合(接口多态)
        List<String> list = new ArrayList<>();

        //2.添加元素
        list.add("aaa");
        list.add("bbb");//1
        list.add("ccc");

        list.add(1,"ddd"); 

        //E remove(int index)                 
        // 删除指定索引处的元素，返回被删除的元素
        String remove = list.remove(0);
        System.out.println(remove);//aaa


        //E set(int index,E element)         
        //修改指定索引处的元素，返回被修改的元素
        String result = list.set(0, "QQQ");   //aaa
        System.out.println(result);

        // E get(int index)                   
        //返回指定索引处的元素
        String s = list.get(0);
        System.out.println(s);


        //3.打印集合
        System.out.println(list);
```

list.remove 删除的小细节

```ruby
//List系列集合中的两个删除的方法
        //1.直接删除元素
        //2.通过索引进行删除

        //1.创建集合并添加元素
        List<Integer> list = new ArrayList<>();

        list.add(1);
        list.add(2);
        list.add(3);


        //2.删除元素
        //请问：此时删除的是1这个元素，还是1索引上的元素？
        //为什么？
        //因为在调用方法的时候，如果方法出现了重载现象
        //优先调用，实参跟形参类型一致的那个方法。

        list.remove(1);


        //手动装箱，手动把基本数据类型的1，变成Integer类型
        Integer i = Integer.valueOf(1);

        list.remove(i);

        System.out.println(list);
```

### list集合的5种遍历方式

```
  1.迭代器
  2.列表迭代器
  3.增强for
  4.Lambda表达式
  5.普通for循环
```

1.迭代器

```ruby
 Iterator<String> it = list.iterator();
  while(it.hasNext()){
      String str = it.next();
      System.out.println(str);
  }
        
```

2.增强for

```ruby
 //2.增强for
 //下面的变量s，其实就是一个第三方的变量而已。
 //在循环的过程中，依次表示集合中的每一个元素
 for (String s : list) {
     System.out.println(s);
 }

```

3.lambda表达式

```ruby
 //3.Lambda表达式
 //forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素
 //并把每一个元素传递给下面的accept方法
 //accept方法的形参s，依次表示集合中的每一个元素
 list.forEach(s->System.out.println(s) );

```
4.普通for循环

```ruby
 //4.普通for循环
 //size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素
 for (int i = 0; i < list.size(); i++) {
     //i:依次表示集合中的每一个索引
     String s = list.get(i);
     System.out.println(s);
 }

```

5.列表迭代器

```ruby
 // 5.列表迭代器
 //获取一个列表迭代器的对象，里面的指针默认也是指向0索引的

 //额外添加了一个方法：在遍历的过程中，可以添加元素
 ListIterator<String> it = list.listIterator();
 while(it.hasNext()){
     String str = it.next();
     if("bbb".equals(str)){
         //qqq
         it.add("qqq");
     }
 }
 System.out.println(list);

```

![image](https://user-images.githubusercontent.com/88382462/220029603-96efbf8d-b49b-4974-ac78-47342988b7ea.png)


# 数据结构
![image](https://user-images.githubusercontent.com/88382462/220030693-20573337-597f-4131-bed8-a05af3cd3f1a.png)
![image](https://user-images.githubusercontent.com/88382462/220030845-183ccf5b-9267-4139-8172-f0e05a51830f.png)

## 栈
![image](https://user-images.githubusercontent.com/88382462/220031566-16336ede-14de-4606-bb63-0f60e507b623.png)
![image](https://user-images.githubusercontent.com/88382462/220031700-a1310d5a-eafa-4eab-98e0-f0c598013b8d.png)

## 队列
![image](https://user-images.githubusercontent.com/88382462/220031941-63421719-1488-49ae-b291-c8d88008b9f9.png)

## 数组
![image](https://user-images.githubusercontent.com/88382462/220032502-f43751fa-6224-454a-82c7-996be2313b05.png)

## 链表
![image](https://user-images.githubusercontent.com/88382462/220033617-ca82eb99-5c0e-4a98-b59b-47fae0ce2c42.png)
![image](https://user-images.githubusercontent.com/88382462/220033748-714670e0-3521-4bf9-97fd-94733303eb71.png)
![image](https://user-images.githubusercontent.com/88382462/220033952-4e2de156-0361-4c9d-9872-2aba86982a1a.png)
![image](https://user-images.githubusercontent.com/88382462/220034119-77170c52-3e1e-4e88-b0b5-47a2b67bad49.png)

## 树
![image](https://user-images.githubusercontent.com/88382462/220077681-0adc38c2-a15f-46c3-bb6b-6bea0e51b1ec.png)
![image](https://user-images.githubusercontent.com/88382462/220077745-b0d9cf38-bf54-4bdc-b829-027490b8546d.png)

## 二叉树
![image](https://user-images.githubusercontent.com/88382462/220077871-70d5e10f-8474-4236-956a-ae099f74267d.png)
![image](https://user-images.githubusercontent.com/88382462/220077976-756e4654-5a5b-4b3d-bee3-dd4fd7414232.png)

### 二叉查找树（排序树/搜索树）
![image](https://user-images.githubusercontent.com/88382462/220078162-cd7913eb-c1f1-4675-b930-9f62ef5b8e2e.png)
![image](https://user-images.githubusercontent.com/88382462/220078242-b93266b1-1217-4f09-bb40-4b9f4bc2111f.png)

#### 二叉查找树遍历方式
![image](https://user-images.githubusercontent.com/88382462/220078399-84bb6ff5-e67e-4280-95d1-f5d08753e613.png)
##### 1、前序遍历
![image](https://user-images.githubusercontent.com/88382462/220078578-53edca32-361d-47c0-b44b-5db96da491c3.png)
##### 2、中序遍历
![image](https://user-images.githubusercontent.com/88382462/220078664-01927b26-94f0-47a6-a0f2-29ba418f7800.png)
##### 3、后序遍历
![image](https://user-images.githubusercontent.com/88382462/220078967-4921a529-30f2-47ad-a7cf-81801d567505.png)

##### 4、层序遍历
![image](https://user-images.githubusercontent.com/88382462/220079228-ea6102ae-a273-4cc6-a579-c48f71a3dd0a.png)

![image](https://user-images.githubusercontent.com/88382462/220079280-1bbf7c32-a25d-400c-94b2-69197d116cf6.png)

#### 二叉查找树弊端
![image](https://user-images.githubusercontent.com/88382462/220080659-5e0b85bc-8289-4ebb-9c9c-4551c700a645.png)

### 平衡二叉树
![image](https://user-images.githubusercontent.com/88382462/220081164-ac9b47b2-b06c-4e9a-bafe-aeccd276cce3.png)
![image](https://user-images.githubusercontent.com/88382462/220081346-8424b556-649a-4b43-a1f3-e79cbf2323a3.png)
![image](https://user-images.githubusercontent.com/88382462/220081701-ead02489-5b0a-41fe-a199-91555ba3b47a.png)

#### 平衡二叉树旋转机制
![image](https://user-images.githubusercontent.com/88382462/220082023-19fab3df-bbc4-4272-a7c2-d43558096cbd.png)
![image](https://user-images.githubusercontent.com/88382462/220082481-3cfb93f3-0cbf-47ca-9d66-8d441fef2f4e.png)
![image](https://user-images.githubusercontent.com/88382462/220082692-3d10d1dc-32c7-469a-8f11-57e16d3d1f16.png)
![image](https://user-images.githubusercontent.com/88382462/220083019-f18f2656-1219-47c1-a204-ad40f2f3742d.png)
![image](https://user-images.githubusercontent.com/88382462/220083899-eef0faac-75dd-447a-8e2e-3353d943b40f.png)
![image](https://user-images.githubusercontent.com/88382462/220084067-cdfef676-5899-44df-9a53-d87fd0262aa5.png)

##### 平衡二叉树需要旋转的四种情况
1.左左 - 一次右旋
![image](https://user-images.githubusercontent.com/88382462/220085041-a28807fb-1b8f-4c76-8fa3-90433bd510b2.png)
2.左右-先局部左旋，再整体右旋
![image](https://user-images.githubusercontent.com/88382462/220092710-7063af79-2d44-4512-a728-2261391229c6.png)
![image](https://user-images.githubusercontent.com/88382462/220092811-8592dca1-e9d1-4f50-98c1-2ef720b348e6.png)
3.右右-一次左旋
![image](https://user-images.githubusercontent.com/88382462/220093359-9c282351-204c-4e2b-ba44-5a264e6b2aea.png)
4.右左-先局部右旋，再整体左旋
![image](https://user-images.githubusercontent.com/88382462/220093685-02f7c131-c4a1-4a60-9baa-b33562a501a1.png)
![image](https://user-images.githubusercontent.com/88382462/220093846-31340ca7-a4cb-406d-aa94-5e8234b9d08f.png)

![image](https://user-images.githubusercontent.com/88382462/220093950-07bf92d7-8603-4aa3-b758-591886a7b055.png)
![image](https://user-images.githubusercontent.com/88382462/220093992-f13e770e-b693-4505-8e34-1ee3379825f7

### 红黑树
![image](https://user-images.githubusercontent.com/88382462/220095287-0a6e24a3-80d9-4ea8-9353-5e1d6d7da9a6.png)
![image](https://user-images.githubusercontent.com/88382462/220095732-87425e79-a880-4f76-bc5e-62b4dcc80068.png)
#### 红黑树添加节点的规则
![image](https://user-images.githubusercontent.com/88382462/220097996-294dee22-873d-43b6-b74e-9cafebcdc24e.png)



# LinkedList(list的一种实现类)
以下几种方法不常用
![image](https://user-images.githubusercontent.com/88382462/220034890-e337f11e-aeb4-4e2f-a9f9-7e9e4197b339.png)

# 泛型

## 泛型概述
![image](https://user-images.githubusercontent.com/88382462/220035567-477f2fe9-0972-4331-a11b-8117c199203a.png)

## 没有泛型的时候，集合如何存储数据？
    结论：
    
    如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型
    
    此时可以往集合添加任意的数据类型。
    
    **带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。**
    
    此时推出了泛型，可以在添加数据的时候就把类型进行统一。
    
    而且我们在获取数据的时候，也省的强转了，非常的方便。
    
没有泛型时
```ruby
 //1.创建集合的对象
 ArrayList<String> list = new ArrayList<>();

 //2.添加数据
 list.add(123);
 list.add("aaa");
 list.add(new Student("zhangsan",123));


 //3.遍历集合获取里面的每一个元素
 Iterator<String> it = list.iterator();
 while(it.hasNext()){
     String str = it.next();
     //多态的弊端是不能访问子类的特有功能
     //obj.length();
     //str.length();
     System.out.println(str);
 }
```

## 泛型的好处

1.统一数据类型。

2.把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。

Java里的泛型是伪泛型

## 泛型的细节

1.泛型中不能写基本数据类型

2.指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型

3.如果不写泛型，类型默认是Object

![image](https://user-images.githubusercontent.com/88382462/220038439-d0f7d5d2-35c8-4812-9be1-9c163b700ab8.png)

## 泛型类
![image](https://user-images.githubusercontent.com/88382462/220038644-5e32c8e9-8082-4d31-8366-53952503563a.png)

编写泛型类
```ruby
/*
*       当我在编写一个类的时候，如果不确定类型，那么这个类就可以定义为泛型类。
* */
public class MyArrayList<E> {

    Object[] obj = new Object[10];
    int size;

    /*
    E : 表示是不确定的类型。该类型在类名后面已经定义过了。
    e：形参的名字，变量名
    * */
    public boolean add(E e){
        obj[size] = e;
        size++;
        return true;
    }


    public E get(int index){
        return (E)obj[index];
    }


    @Override
    public String toString() {
        return Arrays.toString(obj);
    }
}

```
对应的实现方法
```ruby
MyArrayList<String> list = new MyArrayList<>();

list.add("aaa");
list.add("bbb");
list.add("ccc");


System.out.println(list);


MyArrayList<Integer> list2 = new MyArrayList<>();
list2.add(123);
list2.add(456);
list2.add(789);


int i = list2.get(0);
System.out.println(i);


System.out.println(list2);
```


## 泛型方法
![image](https://user-images.githubusercontent.com/88382462/220041595-e08bfa9b-b8da-44fe-9383-7d65c55d454e.png)
![image](https://user-images.githubusercontent.com/88382462/220041741-bc760f8d-61d8-4be7-9817-d667e1020726.png)

定义一个工具类：ListUtil
类中定义一个静态方法addAll，用来添加多个集合的元素。

```ruby
public class ListUtil {
    private ListUtil(){}

    //类中定义一个静态方法addAll，用来添加多个集合的元素。


    /*
    *   参数一：集合
    *   参数二~最后：要添加的元素
    *
    * */
    public static<E> void addAll(ArrayList<E> list, E e1,E e2,E e3,E e4){
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
    }

/*    public static<E> void addAll2(ArrayList<E> list, E...e){
        //e为可变参数
        for (E element : e) {
            list.add(element);
        }
    }*/


    public void show(){
        System.out.println("阿玮");
    }
}

```
实现类
```ruby
public class GenericsDemo3 {
    public static void main(String[] args) {

        ArrayList<String> list1 = new ArrayList<>();
        ListUtil.addAll(list1, "aaa", "bbb", "ccc", "ddd");
        System.out.println(list1);


        ArrayList<Integer> list2 = new ArrayList<>();
        ListUtil.addAll(list2,1,2,3,4);
        System.out.println(list2);

    }
}
```

## 泛型接口

![image](https://user-images.githubusercontent.com/88382462/220043693-99882c7d-baa6-4f11-9844-917edc7f0135.png)

泛型接口的两种使用方式：
   1.实现类给出具体的类型
   2.实现类延续泛型，创建实现类对象时再确定类型
   
```ruby
//1.实现类给出具体的类型
public class MyArrayList2 implements List<String> {}
//2.实现类延续泛型，创建实现类对象时再确定类型
public class MyArrayList3<E> implements List<E>{}
```

## 泛型的继承和通配符

**泛型不具备继承性，数据具备继承性**

```ruby
public  static <E> void method(ArrayList<E> list) {

}
```

需求： 定义一个方法，形参是一个集合，但是集合中的数据类型不确定。
 
```ruby
 /*
     * 此时，泛型里面写的是什么类型，那么只能传递什么类型的数据。
     * 弊端：
     *      利用泛型方法有一个小弊端，此时他可以接受任意的数据类型
     *      Ye  Fu   Zi    Student
     *
     * 希望：本方法虽然不确定类型，但是以后我希望只能传递Ye Fu Zi
     *
     * 此时我们就可以使用泛型的通配符：
     *      ?也表示不确定的类型
     *      他可以进行类型的限定
     *      ? extends E: 表示可以传递E或者E所有的子类类型
     *      ? super E:表示可以传递E或者E所有的父类类型
     *
     * 应用场景：
     *      1.如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。
     *      2.如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符
     * 泛型的通配符：
     *      关键点：可以限定类型的范围。
     *
     * */
```

```ruby
public static void method(ArrayList<? super Fu> list) {

}
```

# set
![image](https://user-images.githubusercontent.com/88382462/220497939-72e2b8c5-3436-4f30-baa7-0d42f8a49ae9.png)

```ruby
/*
   利用Set系列的集合，添加字符串，并使用多种方式遍历。
    迭代器
    增强for
    Lambda表达式

*/


//1.创建一个Set集合的对象（接口多态）
Set<String> s = new HashSet<>();

//2,添加元素
//如果当前元素是第一次添加，那么可以添加成功，返回true
//如果当前元素是第二次添加，那么添加失败，返回false
System.out.println(s.add("张三"));    //true
System.out.println(s.add("张三"));    //false
s.add("李四");
s.add("王五");

//3.打印集合
//无序
//System.out.println(s);//[李四, 张三, 王五]

//迭代器遍历
Iterator<String> it = s.iterator();
while (it.hasNext()){
    String str = it.next();
    System.out.println(str);
}


//增强for
 for (String str : s) {
    System.out.println(str);
}

// Lambda表达式
s.forEach( str->System.out.println(str));
```
 
## HashSet
![image](https://user-images.githubusercontent.com/88382462/220499392-81665b21-31f3-448b-80cd-c4cd42f44065.png)

### 哈希值
![image](https://user-images.githubusercontent.com/88382462/220499720-4abae5b3-82dd-4e6c-aa25-75babbb5955c.png)

```ruby
/*
   哈希值：
       对象的整数表现形式
       1. 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
       2. 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
       3. 但是在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）

*/

//1.创建对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("zhangsan",23);

//2.如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
//  如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
System.out.println(s1.hashCode());//-1461067292
System.out.println(s2.hashCode());//-1461067292


//在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。
//哈希碰撞
System.out.println("abc".hashCode());//96354
System.out.println("acD".hashCode());//96354
```

### JDK8以前的HashSet
![image](https://user-images.githubusercontent.com/88382462/220501348-36f12f78-f097-47f9-bdff-ee6db3ff9386.png)
![image](https://user-images.githubusercontent.com/88382462/220501183-2980e9b7-4fc6-457f-ab9b-b018c888a11c.png)

**扩容时机：当数组存了0.75*当前的数组长度时，数组长度加倍 （0.75为加载因子）**

**JDK8以后当链表长度大于等于8且数组长度大于等于64时链表转换为红黑树。**

![image](https://user-images.githubusercontent.com/88382462/220502690-ea1b960f-7900-4f60-af0d-554a40431f82.png)

**重写Equals一定要重写HashCode**

```ruby
/* 需求：创建一个存储学生对象的集合，存储多个学生对象。
            使用程序实现在控制台遍历该集合。
            要求：学生对象的成员变量值相同，我们就认为是同一个对象

*/
  //1.创建三个学生对象
  Student s1 = new Student("zhangsan",23);
  Student s2 = new Student("lisi",24);
  Student s3 = new Student("wangwu",25);
  Student s4 = new Student("zhangsan",23);


  //2.创建集合用来添加学生
  HashSet<Student> hs = new HashSet<>();

  //3.添加元素，重写hashCode和equals方法后true，true，true，false
  System.out.println(hs.add(s1));
  System.out.println(hs.add(s2));
  System.out.println(hs.add(s3));
  System.out.println(hs.add(s4));

  //4.打印集合
  System.out.println(hs);
```

## LinkedHashSet
比HashSet多了一条双向链表用来存顺序
![image](https://user-images.githubusercontent.com/88382462/220504932-f7348ac5-e5d8-4433-95cd-e1cd36b39f61.png)

```ruby
 //1.创建4个学生对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("lisi",24);
Student s3 = new Student("wangwu",25);
Student s4 = new Student("zhangsan",23);

//2.创建集合的对象
LinkedHashSet<Student> lhs = new LinkedHashSet<>();

//3.添加元素
System.out.println(lhs.add(s3));    //true
System.out.println(lhs.add(s2));    //true
System.out.println(lhs.add(s1));    //true
System.out.println(lhs.add(s4));    //false

//4.打印集合
System.out.println(lhs); //顺序打印
```

![image](https://user-images.githubusercontent.com/88382462/220505517-879f648c-7d87-41ab-9f4d-e16480a89725.png)

## TreeSet
![image](https://user-images.githubusercontent.com/88382462/220505662-e807d99a-b997-44d8-8e17-c4b891a2918a.png)
### 创建和遍历
```ruby
/*
*
*       需求：利用TreeSet存储整数并进行排序
*
* */

//1.创建TreeSet集合对象
TreeSet<Integer> ts = new TreeSet<>();

//2.添加元素
ts.add(4);
ts.add(5);
ts.add(1);
ts.add(3);
ts.add(2);

//3.打印集合
System.out.println(ts);   //1,2,3,4,5(存入时自动排序，从小到大)

//4.遍历集合（三种遍历）
//迭代器
Iterator<Integer> it = ts.iterator();
while(it.hasNext()){
    int i = it.next();
    System.out.println(i);
}

System.out.println("--------------------------");
//增强for
for (int t : ts) {
    System.out.println(t);
}
System.out.println("--------------------------");
//lambda
ts.forEach( integer -> System.out.println(integer));
```

![image](https://user-images.githubusercontent.com/88382462/220507628-ff46df59-386b-40c5-aff7-fba84b4c1124.png)

### 两种排序规则
#### 1.默认排序/自然排序
```ruby
需求：创建TreeSet集合，并添加3个学生对象
            学生对象属性：
                姓名，年龄。
                要求按照学生的年龄进行排序
                同年龄按照姓名字母排列（暂不考虑中文）
                同姓名，同年龄认为是同一个人

            方式一：
                默认的排序规则/自然排序
                Student实现Comparable接口，重写里面的抽象方法，再指定比较规则
```

**实现Comparable接口，重写里面的抽象方法，再指定比较规则**

**存到TreeSet不用重写hashCode和eauals 因为TreeSet底层没有使用HashSet而是红黑树.**

**如果要往TreeSet存入自定义对象，要重写compareTo来按照自定义规则排序**


```ruby
public class Student implements Comparable<Student>{ //实现Comparable接口，泛型为Student
...
...
 //this：表示当前要添加的元素
    //o：表示已经在红黑树存在的元素

    //返回值：
    //负数：表示当前要添加的元素是小的，存左边
    //正数：表示当前要添加的元素是大的，存右边
    //0 :表示当前要添加的元素已经存在，舍弃
    public int compareTo(Student o) {
        //指定排序的规则
        //只看年龄，我想要按照年龄的升序进行排列
        return this.getAge() - o.getAge();
    }
 }
```

#### 2.比较器排序
```ruby
//o1:表示当前要添加的元素
//o2：表示已经在红黑树存在的元素
//返回值规则跟之前是一样的
TreeSet<String> ts = new TreeSet<>((o1, o2)->{
        // 按照长度排序
        int i = o1.length() - o2.length();
        //如果一样长则按照首字母排序
        i = i == 0 ? o1.compareTo(o2) : i;
        return i;
});
```

```
第一种：默认排序/自然排序
第二种：比较器排序
 默认情况下，用第一种排序方式，如果第一种不能满足当前的需求，采取第二种方式。
```

```ruby
/* 按照总分从高到低输出到控制台
如果总分一样，按照语文成绩排
如果语文一样，按照数学成绩排
如果数学成绩一样，按照英语成绩排
如果英文成绩一样，按照年龄排
如果年龄一样，按照姓名的字母顺序排
如果都一样，认为是同一个学生，不存。*/
@Override
public int compareTo(Student2 o) {
    int sum1 = this.getChinese() + this.getMath() + this.getEnglish();
    int sum2 = o.getChinese() + o.getMath() + o.getEnglish();

    //比较两者的总分
    int i = sum1 - sum2;
    //如果总分一样，就按照语文成绩排序
    i = i == 0 ? this.getChinese() - o.getChinese() : i;
    //如果语文成绩一样，就按照数学成绩排序
    i = i == 0 ? this.getMath() - o.getMath() : i;
    //如果数学成绩一样，按照英语成绩排序（可以省略不写）
    i = i == 0 ? this.getEnglish() - o.getEnglish() : i;
    //如果英文成绩一样，按照年龄排序
    i = i == 0 ? this.getAge() - o.getAge() : i;
    //如果年龄一样，按照姓名的字母顺序排序
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```
### TreeSet总结
```
1. TreeSet集合的特点是怎么样的?
可排序、不重复、无索引
底层基于红黑树实现排序，增删改查性能较好
```
```
2. TreeSet集合自定义排序规则有几种方式?
方式一: Javabean类实现Comparable接口，指定比较规则
方式二∶创建集合时，自定义Comparator比较器对象，指定比较规则
方式一和方式二同时存在时，以方式二为准
```
```
3．方法返回值的特点
负数:表示当前要添加的元素是小的，存左边
正数:表示当前要添加的元素是大的，存右边
0:表示当前要添加的元素已经存在，舍弃
```

## 各种单列集合应用场景

1．如果想要集合中的元素**可重复**

用ArrayList集合，基于数组的。**（用的最多)**

2．如果想要集合中的元素**可重复**，**而且当前的增删操作明显多于查询**

用LinkedList集合，基于链表的。

3．如果想对集合中的元素**去重**

用HashSet集合，基于哈希表的。**（用的最多)**

4．如果想对集合中的元素**去重，而且保证存取顺序**

用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。

5．如果想对集合中的元素进行**排序**

用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。

# 双列集合
![image](https://user-images.githubusercontent.com/88382462/220558939-68c3c1e3-4395-4c45-85b1-6cb66dce0131.png)
## 双列集合特点
①双列集合一次需要存一对数据，分别为键和值键不能重复，值可以重复

③键和值是一一对应的，每一个键只能找到自己对应的值

④键＋值这个整体我们称之为“键值对”或者“键值对对象”，在3ava中叫做“Entry对象”

## Map
![image](https://user-images.githubusercontent.com/88382462/220559398-836fd29a-5fc5-4e9e-8dd0-6e5e8b1b23c8.png)

```ruby
//创建Map对象
Map<String, String> m = new HashMap();
//添加元素
//put方法的细节
//添加/覆盖

//在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null
//在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。
m.put("郭靖", "黄蓉");
m.put("韦小宝", "沐剑屏");
m.put("尹志平", "小龙女");

String value2 = m.put("韦小宝","双儿");
System.out.println(value2);     //沐剑屏

//删除
String result = m.remove("郭靖");
System.out.println(result);     //黄蓉

//判断是否包含
System.out.println(m.containsKey("韦小宝"));
System.out.println(m.containsValue("双儿"));

//集合长度
int size = m.size();

//清空
m.clear();

System.out.println(size);
System.out.println(m);
```

put方法 

在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null 

在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。

### Map的遍历方式

1.键找值

2.键值对

3.Lambda表达式

#### 键找值遍历
**map.keySet()**

```ruby
//创建Map集合
Map<String, String> map = new HashMap();

//添加元素
map.put("尹志平", "小龙女");
map.put("郭靖", "穆念慈");
map.put("欧阳克", "黄蓉");

//通过键找值
//获取所有的键，把这些键放到一个单列集合中
Set<String> keys = map.keySet();
//遍历单列集合，得到每一个键
for (String key : keys) {
    //利用Map中的键获取对应的值 get
    String value = map.get(key);
    System.out.println(key + "=" + value);

}

//迭代器
Iterator<String> it = keys.iterator();
while (it.hasNext()){
    String key = it.next();
    String value = map.get(key);
    System.out.println(key + "=" + value);
}

//Lambda表达式
keys.forEach((String s) -> {
        String value = map.get(s);
        System.out.println(s + "=" + value);
    }
);
```

#### 键值对遍历
**map.entrySet()**

```ruby
//创建Map集合的对象
Map<String, String> map = new HashMap();
//添加元素
map.put("标枪选手", "马超");
map.put("人物挂件", "明世隐");
map.put("御龙骑士", "尹志平");

//通过键值对方式遍历
//通过一个方法获取所有的键值对对象，方法返回一个set集合
Set<Map.Entry<String, String>> entries = map.entrySet();
//遍历entries集合，获取其中所有键值对
for (Map.Entry<String, String> entry : entries) {
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//迭代器
Iterator<Map.Entry<String, String>> it = entries.iterator();
while (it.hasNext()){
    Map.Entry<String, String> entry = it.next();
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//内部类（可简化Lambda表达式）
entries.forEach(new Consumer<Map.Entry<String, String>>() {
    @Override
    public void accept(Map.Entry<String, String> stringStringEntry) {
        System.out.println(stringStringEntry.getKey()+"="+stringStringEntry.getValue());
    }
});
```

#### Lambda表达式遍历
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```ruby
//利用Lambda表达式遍历
 map.forEach(new BiConsumer<String, String>() {
     @Override
     public void accept(String key, String value) {
         System.out.println(key + "=" + value);
     }
 });
```

利用Lambda简化后

```ruby
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```







底层:
forEach其实就是利用第二种方式进行遍历，依次得到每一个键和值,再调用accept方法

### HashMap
**HashMap的特点**

HashMap是Map里面的一个实现类。

没有额外需要学习的特有方法，直接使用Map里面的方法就可以了

特点都是由键决定的:无序、不重复、无索引

HashMap跟HashSet底层原理是一模一样的，都是哈希表结构

**总结**

1. HashMap底层是哈希表结构的

2．依赖hashCode方法和equals方法保证键的唯一

3．如果键存储的是自定义对象，需要重写hashCode和equals方法 
如果值存储自定义对象，不需要重写hashCode和equals方法


#### HashMap集合案例
需求
某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。

```ruby
//先让同学们投票
//定义一个数组储存景点
String[] arr = {"A","B","C","D"};
//利用随机数模拟80个同学的投票，，并把投票存起来
ArrayList<String> list = new ArrayList<>();
Random r = new Random();
for (int i = 0; i < 80; i++) {
    int index = r.nextInt(arr.length);
    list.add(arr[index]);
}

//如果要统计的东西比较多，不方便使用计数器思想
//可以定义Map集合，利用集合进行统计
HashMap<String,Integer> hm = new HashMap<>();
for (String name : list) {
    //判断当前景点在集合中是否存在
    if(hm.containsKey(name)){
        //存在
        //先获取当前景点被投票的次数
        Integer count = hm.get(name);
        count ++;
        //把新的次数添加到集合
        hm.put(name,count);
    }else {
        //不存在
        hm.put(name,1);
    }
}
System.out.println(hm);

//求最大值
int max = 0;
Set<Map.Entry<String, Integer>> entries = hm.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() > max) max = entry.getValue();
}

//判断那个景点最多，打印出来
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() == max) System.out.println(entry.getKey());
}
```
 
### LinkedHashMap

由键决定:有序、不重复、无索引。

这里的有序指的是保证存储和取出的元素顺序一致

原理∶底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。

```ruby
//创建集合
LinkedHashMap<String , Integer> lhm =new LinkedHashMap<>();
//添加元素
lhm.put("c",789);
lhm.put("b",456);
lhm.put("a",123);
lhm.put("a",111);

System.out.println(lhm);    //{c=789, b=456, a=111}
```

### TreeMap
TreeMap跟TreeSet底层原理一样，都是红黑树结构的。

由键决定特性:不重复、无索引、可排序

可排序:对键进行排序。

注意:默认按照键的从小到大进行排序，也可以自己规定键的排序规则 
 
**代码书写两种排序规则:**

实现Comparable接口，指定比较规则。

创建集合时传递comparator比较器对象，指定比较规则。

```ruby
//降序排列 o2 - o1 ,(默认升序)
 TreeMap<Integer,String> tm = new TreeMap<>((o1, o2) -> o2-o1);
 tm.put(5, "可恰可乐");
 tm.put(4, "雷碧");
 tm.put(3, "九个核桃");
 tm.put(2, "康帅傅");
 tm.put(1, "粤利粤");
 System.out.println(tm); //{5=可恰可乐, 4=雷碧, 3=九个核桃, 2=康帅傅, 1=粤利粤}
```

```ruby
public class Student implements Comparable<Student>
...
...
public int compareTo(Student o) {
    int i = this.getAge() - o.getAge();
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```

TreeMap例程

```ruby
/*
需求:字符串“aababcabcdabcde"
请统计字符串中每一个字符出现的次数，并按照以下格式输出输出结果:
a (5) b (4) c (3) d (2) e (1) */
//定义字符串
String str = "aababcabcdabcde";
//创建TreeMap对象
TreeMap <Character , Integer> tm =new TreeMap<>();
//遍历得到字符串每一个字符
for (int i = 0; i < str.length(); i++) {
    if(tm.containsKey(str.charAt(i))){
        //如果键已存在,值加一
        Integer count = tm.get(str.charAt(i));
        count ++;
        tm.put(str.charAt(i),count);
    }else {
        //键不存在,添加新的键
        tm.put(str.charAt(i),1);
    }
}
//格式化输出(利用Lambda表达式)
tm.forEach((character, integer) -> System.out.print(character+"("+ integer + ")")         
```

# 可变参数
可变参数:一个大胖子,有多少吃多少

1．可变参数本质上就是一个数组

2．作用:在形参中接收多个数据

3．格式:数据类型...参数名称

举例: int...a

4．注意事项:

形参列表中可变参数只能有一个可变参数必须放在形参列表的最后面

```ruby
public static void main(String[] args) {
    //JDK5
    //可变参数
    //方法形参的个数是可以发生变化的，0 1 2 3 ...
    //格式:属性类型...名字
    //int. . .args
    System.out.println(getSum(1, 2, 3, 4, 5, 6, 7));
}

//底层:
//可变参数底层就是一个数组
//只不过不需要我们自己创建了，Java会帮我们创建好
public static int getSum(int ... args){
    int sum = 0;
    for (int arg : args) {
        sum += arg;
    }
    return sum;
}
```

# Collections
java.util.Collections:是集合工具类

作用:Collections不是集合，而是集合的工具类。

Collections常用API
![image](https://user-images.githubusercontent.com/88382462/220858621-3db3b304-c5ca-4be9-b12f-41f0b91f7d5d.png)
![image](https://user-images.githubusercontent.com/88382462/220858751-2fec447e-19a2-494b-9e62-8d7f261ee4f5.png)

**Arraylist排序可以用collection里的sort方法，不需要转成TreeSet**

```ruby
ArrayList<String> list = new ArrayList<>();

//批量添加元素
Collections.addAll(list,"abc","abc","abc","qwer","zxcv");
System.out.println(list);   //[abc, abc, abc, qwer, zxcv]

//shuffle
Collections.shuffle(list);
System.out.println(list);   //[abc, zxcv, qwer, abc, abc]
```

**序号排序法**

如果原始数据的规律非常复杂，我们可以先手动排序让每一个数据跟唯一的序号产生对应关系。

序号就是数字，规律非常简单，后续的所有操作，我们以序号为准

当真正需要操作原始数据时候，再通过序号找到原始数据即可。


# 不可变集合

不可变集合应用场景:

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

## 创建不可变集合书写格式

在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。

|方法名称	|说明 |
| --- | --- |
|static<E> List<E> of(E...elements) |	创建一个具有指定元素的List集合对象 |
|static<E> Set<E> of(E...elements)	  |创建一个具有指定元素的Set集合对象 |
|static<K , V> Map<K , V> of(E...elements) |	创建一个具有指定元素的Map集合对象 |

注意:这个集合不能添加，不能删除，不能修改。

当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
 
 ```
 创建Map的不可变集合
 细节1：
     键是不能重复的
 细节2：
     Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对
 细节3：
     如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法
     ofEntries(Entry<? extends K, ? extends V>... entries)
 ```

不可变集合创建例程

```ruby
List<String> list = List.of("张三", "李四", "王五", "赵六");
Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");
Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",
                "赵六", "广州", "孙七", "深圳", "周八", "杭州",
                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
                "陈二", "嘉兴");
```

如果要存超过10对键值对的不可变map集合

```ruby
//1.创建一个普通的Map集合
HashMap<String, String> hm = new HashMap<>();
hm.put("张三", "南京");
hm.put("李四", "北京");
hm.put("王五", "上海");
hm.put("赵六", "北京");
hm.put("孙七", "深圳");
hm.put("周八", "杭州");
hm.put("吴九", "宁波");
hm.put("郑十", "苏州");
hm.put("刘一", "无锡");
hm.put("陈二", "嘉兴");
hm.put("aaa", "111");

//2.利用上面的数据来获取一个不可变的集合
//获取到所有的键值对对象（Entry对象）
Set<Map.Entry<String, String>> entries = hm.entrySet();
//把entries变成一个数组
Map.Entry[] arr1 = new Map.Entry[0];
//toArray方法在底层会比较集合的长度跟数组的长度两者的大小
//如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组
//如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用
Map.Entry[] arr2 = entries.toArray(arr1);
//不可变的map集合
Map map = Map.ofEntries(arr2);
```

简化写法

```ruby
Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));
//或者:Jdk10以后 copyOf() 生成不可变集合
Map<String, String> map = Map.copyOf(hm);
```

## 不可变集合总结 
1．不可变集合的特点?

定义完成后不可以修改，或者添加、删除

2．如何创建不可变集合?

List、Set.Map接口中，都存在of方法可以创建不可变集合

3.三种方式的细节

List:直接用

Set:元素不能重复

Map:元素不能重复、键值对数量最多是10个。

超过10个用ofEntries方法,如果Jdk版本大于10,可以用copyOf 方法

# Stream流

## Stream作用 
结合了Lambda表达式，简化集合、数组的操作

| 获取方式 |	方法名 |	说明 |
| --- | --- | --- |
| 单列集合 |	default Stream<E> stream()	|collection中的默认方法 | 
| 双列集合 |	无	| 无法直接使用stream流 |
| 数组 |	public static <T> Stream<T> stream(T[] array) |	Arrays工具类中的静态方法 |
| 一堆零散数据 |	public static<T> Stream<T> of(T... values) |	Stream接口中的静态方法 |

## Stream流的使用步骤:

1.先得到一条Stream流（流水线），并把数据放上去

2.使用中间方法对流水线上的数据进行操作

3.使用终结方法对流水线上的数据进行操作

![image](https://user-images.githubusercontent.com/88382462/221397588-4007395f-24af-40e1-9027-2013836f129f.png)

### 单列集合Stream流

```ruby
//1.单列集合获取Stream流
 ArrayList<String> list = new ArrayList<>();
 Collections.addAll(list,"a","b","c","d","e");
 //获取到一条流水线，并把集合中的数据放到流水线上
 Stream<String> stream1 = list.stream();
 //使用终结方法打印一下流水线上的所有数据
 stream1.forEach(new Consumer<String>() {
     @Override
     public void accept(String s) {
         //s:依次表示流水线上的每一个数据
         System.out.println(s);
     }
 });
```

简化写法

```ruby
list.stream().forEach(s -> System.out.println(s));
```

### 双列集合Stream流

获取键或者获取键值对再获取stream流

```ruby
//1.创建双列集合
HashMap<String,Integer> hm = new HashMap<>();
//2.添加数据
hm.put("aaa",111);
hm.put("bbb",222);
hm.put("ccc",333);
hm.put("ddd",444);

//3.第一种获取stream流

hm.keySet().stream().forEach(s -> System.out.println(s));

//4.第二种获取stream流

hm.entrySet().stream().forEach(s-> System.out.println(s));
```

### 集合Stream流
```ruby
// 数组          public static <T> Stream<T> stream(T[] array)        Arrays工具类中的静态方法

//1.创建数组
int[] arr1 = {1,2,3,4,5,6,7,8,9,10};
String[] arr2 = {"a","b","c"};

//2.获取stream流
 Arrays.stream(arr1).forEach(s-> System.out.println(s));
System.out.println("============================");

Arrays.stream(arr2).forEach(s-> System.out.println(s));
```

### 零散数据Stream流
```ruby
//一堆零散数据   public static<T> Stream<T> of(T... values)    Stream接口中的静态方法

Stream.of(1,2,3,4,5).forEach(s-> System.out.println(s));
Stream.of("a","b","c","d","e").forEach(s-> System.out.println(s));
```

注意：

**Stream接口中静态方法of的细节**

方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组

但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。

```ruby
int[] arr1 = {1,2,3,4,5,6,7,8,9,10};
Stream.of(arr1).forEach(s-> System.out.println(s));//[I@41629346
```

## Stream流中间方法

|名称	| 说明 |
| --- | --- |
|Stream<T> filter(Predicate<? super T> predicate)	| 过滤 |
|Stream<T> limit(long maxSize)| 	获取前几个元素 |
|Stream<T> skip(long n) |	跳过前几个元素 |
|Stream<T> distinct()	| 元素去重，依赖(hashCode和equals方法) |
|static<T> Stream<T> concat(Stream a, Stream b)	| 合并a和b两个流为一个流 |
|stream<R> map(Function<T， R> mapper)	| 转换流中的数据类型 | 

**注意1**∶中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程

**注意2**:修改Stream流中的数据，不会影响原来集合或者数组中的数据

### filter 过滤

匿名内部类写法

```ruby
//filter   过滤  把张开头的留下，其余数据过滤不要
list.stream().filter(new Predicate<String>() {
    @Override
    public boolean test(String s) {
        //如果返回值为true，表示当前数据留下
        //如果返回值为false，表示当前数据舍弃不要
        return s.startsWith("张");
    }
}).forEach(s -> System.out.println(s));
```

Lambda表达式写法

```ruby
list.stream()
          .filter(s -> s.startsWith("张"))
          .filter(s -> s.length() == 3)
          .forEach(s -> System.out.println(s));
```

### limit 获取前几个元素 和 skip 跳过前几个元素

```ruby
//"张无忌", "周芷若", "赵敏", "张强", "张三丰", "张翠山", "张良", "王二麻子", "谢广坤"
list.stream().limit(3)
        .forEach(s -> System.out.println(s));   //张无忌 周芷若 赵敏
list.stream().skip(4)
        .forEach(s -> System.out.println(s));   //张三丰 张翠山 张良 王二麻子 谢广坤
```

### distinct 元素去重 和 concat 流合并

distinct  元素去重，依赖(hashCode和equals方法)

 concat   合并a和b两个流为一个流

```ruby
// distinct            元素去重，依赖(hashCode和equals方法)
list1.stream().distinct().forEach(s -> System.out.println(s));

// concat   合并a和b两个流为一个流
Stream.concat(list1.stream(),list2.stream()).forEach(s -> System.out.println(s));
```

### map 转换流中的数据类型

```ruby
/*
    map                 转换流中的数据类型

    注意1：中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程
    注意2：修改Stream流中的数据，不会影响原来集合或者数组中的数据
*/

ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张无忌-15", "周芷若-14", "赵敏-13", "张强-20", "张三丰-100", "张翠山-40", "张良-35", "王二麻子-37", "谢广坤-41");
//需求：只获取里面的年龄并进行打印
//String->int

//第一个类型：流中原本的数据类型
//第二个类型：要转成之后的类型

//apply的形参s：依次表示流里面的每一个数据
//返回值：表示转换之后的数据

//当map方法执行完毕之后，流上的数据就变成了整数
//所以在下面forEach当中，s依次表示流里面的每一个数据，这个数据现在就是整数了
list.stream().map(new Function<String, Integer>() {
    @Override
    public Integer apply(String s) {
        String[] arr = s.split("-");    //把字符串按"-"切割,返回数组
        String ageString = arr[1];
        int age = Integer.parseInt(ageString);
        return age;
    }
}).forEach(s-> System.out.println(s));

System.out.println("------------------------");

```

使用Lambda表达式

```ruby

list.stream()
        .map(s-> Integer.parseInt(s.split("-")[1]))
        .forEach(s-> System.out.println(s));
}
```

## Stream流 终结方法

|名称	| 说明 |
| --- | --- |
|void forEach(Consumer action) |	遍历 |
|long count()	| 统计 |
|toArray()	| 收集流中的数据，放到数组中 |
|collect(Collector collector) |	收集流中的数据，放到集合中 |

### forEach 遍历 count 统计 toArray 收集流中的数据，放到数组中

```ruby
//void forEach(Consumer action)           遍历

//Consumer的泛型：表示流中数据的类型
//accept方法的形参s：依次表示流里面的每一个数据
//方法体：对每一个数据的处理操作（打印）
list.stream().forEach(new Consumer<String>() {
    @Override
    public void accept(String s) {
        System.out.println(s);
    }
});

list.stream().forEach(s -> System.out.println(s));
```

```ruby
 // long count()                            统计
 long count = list.stream().count();
 System.out.println(count);
```

```ruby
// toArray()                               收集流中的数据，放到数组中
Object[] arr1 = list.stream().toArray();
System.out.println(Arrays.toString(arr1));
```

```ruby
//IntFunction的泛型：具体类型的数组
//apply的形参:流中数据的个数，要跟数组的长度保持一致
//apply的返回值：具体类型的数组
//方法体：就是创建数组

//toArray方法的参数的作用：负责创建一个指定类型的数组
//toArray方法的底层，会依次得到流里面的每一个数据，并把数据放到数组当中
//toArray方法的返回值：是一个装着流里面所有数据的数组
String[] arr = list.stream().toArray(new IntFunction<String[]>() {
    @Override
    public String[] apply(int value) {
        return new String[value];
    }
});

System.out.println(Arrays.toString(arr));
```

Lambda表达式写法

```ruby
 String[] arr2 = list.stream().toArray(value -> new String[value]);
 System.out.println(Arrays.toString(arr2));
```

### collect 收集流中的数据，放到集合中 (List Set Map)

收集到List集合和Set集合中

```ruby
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张无忌-男-15", "周芷若-女-14", "赵敏-女-13", "张强-男-20",
        "张三丰-男-100", "张翠山-男-40", "张良-男-35", "王二麻子-男-37", "谢广坤-男-41");

//收集List集合当中
//需求：
//我要把所有的男性收集起来
List<String> newList1 = list.stream()
        .filter(s -> "男".equals(s.split("-")[1]))
        .collect(Collectors.toList());
System.out.println(newList1);

//收集Set集合当中
//需求：
//我要把所有的男性收集起来
Set<String> newList2 = list.stream().filter(s -> "男".equals(s.split("-")[1]))
        .collect(Collectors.toSet());
System.out.println(newList2);
```

**收集到Map集合中(注意键和值和参数)**

注意点：

    如果我们要收集到Map集合当中，键不能重复，否则会报错

```ruby
//收集Map集合当中
//谁作为键,谁作为值.
//我要把所有的男性收集起来
//键：姓名。 值：年龄
Map<String, Integer> map = list.stream()
        .filter(s -> "男".equals(s.split("-")[1]))
        /*
         *   toMap : 参数一表示键的生成规则
         *           参数二表示值的生成规则
         *
         * 参数一：
         *       Function泛型一：表示流中每一个数据的类型
         *               泛型二：表示Map集合中键的数据类型
         *
         *        方法apply形参：依次表示流里面的每一个数据
         *               方法体：生成键的代码
         *               返回值：已经生成的键
         *
         *
         * 参数二：
         *        Function泛型一：表示流中每一个数据的类型
         *                泛型二：表示Map集合中值的数据类型
         *
         *       方法apply形参：依次表示流里面的每一个数据
         *               方法体：生成值的代码
         *               返回值：已经生成的值
         *
         * */
        .collect(Collectors.toMap(new Function<String, String>() {
                                      @Override
                                      public String apply(String s) {
                                          //张无忌-男-15
                                          return s.split("-")[0];
                                      }
                                  },
                new Function<String, Integer>() {
                    @Override
                    public Integer apply(String s) {
                        return Integer.parseInt(s.split("-")[2]);
                    }
                }));
```

收集到Map集合的Lambda表达式

```ruby
 Map<String, Integer> map2 = list.stream()
         .filter(s -> "男".equals(s.split("-")[1]))
         .collect(Collectors.toMap(
                 s -> s.split("-")[0],
                 s -> Integer.parseInt(s.split("-")[2])));
```

## Stream流总结

**1. Stream流的作用**

结合了Lambda表达式，简化集合、数组的操作

**2. Stream的使用步骤**

获取Stream流对象使用中间方法处理数据使用终结方法处理数据

**3．如何获取Stream流对象**

单列集合:Collection中的默认方法

stream双列集合:不能直接获取

数组:Arrays工具类型中的静态方法stream一堆零散的数据:Stream接口中的静态方法of

**4．常见方法**

中间方法:
filter，limit，skip，distinct,concat,map

终结方法:
forEach, count,collect

## 练习

```ruby
现在有两个ArrayList集合，
第一个集合中∶存储6名男演员的名字和年龄。第二个集合中:存储6名女演员的名字和年龄。姓名和年龄中间用逗号隔开。比如:张三,23
要求完成如下的操作:
1，男演员只要名字为3个字的前两人2，女演员只要姓杨的，并且不要第一个
3，把过滤后的男演员姓名和女演员姓名合并到一起4，将上一步的演员信息封装成Actor对象。
5，将所有的演员对象都保存到List集合中。备注:演员类Actor，属性有:name,age
```

```ruby
//创建集合并添加元素
ArrayList<String> maleActorList = new ArrayList<>();
ArrayList<String> femaleActorList = new ArrayList<>();
Collections.addAll(maleActorList, "蔡坤坤,24", "叶齁咸,23", "刘不甜,22", "吴签,24", "谷嘉,30", "肖梁梁,27");
Collections.addAll(femaleActorList, "赵小颖,35", "杨颖,36", "高元元,43", "张天天,31", "刘诗,35", "杨小幂,33");
//分别对两个集合进行流处理,得到两个流
Stream<String> maleStream = maleActorList.stream()
        .filter(s -> s.split(",")[0].length() == 3)
        .limit(2);
Stream<String> femaleStream = femaleActorList.stream()
        .filter(s -> s.split(",")[0].startsWith("杨"))
        .skip(1);
//使用concat进行流合并再用map把流转换成actor,最后打包成list
List<Actor> actorList =
        Stream.concat(maleStream, femaleStream)
        .map(s -> new Actor(s.split(",")[0], Integer.parseInt(s.split(",")[1])))
                .collect(Collectors.toList());

System.out.println(actorList);
```

# 方法引用

把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体

原来的写法:

```ruby
Arrays.sort(arr, new Comparator<Integer>() {
@Override
public int compare(Integer o1, Integer o2) {
    return o2 - o1;
}
```

可以用Lambda简化:

```ruby
Arrays.sort(arr, (o1, o2)->o2 - o1 );
```

方法引用:

```ruby
//表示引用FunctionDemo1类里面的subtraction方法
//把这个方法当做抽象方法的方法体
Arrays.sort(arr, FunctionDemo1::subtraction);

public static int subtraction(int num1, int num2) {
        return num2 - num1;
    }
```
"::" 是方法引用符

**方法引用细节:**

1.引用处需要是函数式接口

2.被引用的方法需要已经存在

3.被引用方法的形参和返回值需要跟抽象方法的形参和返回值保持一致

4.被引用方法的功能需要满足当前的要求

## 方法引用的分类

1.引用静态方法

2.引用成员方法

```ruby
1.引用其他类的成员方法
2.引用本类的成员方法
3.引用父类的成员方法
```

3.引用构造方法

4.其它调用方式

```ruby
1.使用类名引用成员方法
2.引用数组的构造方法
```

### 引用静态方法

格式:类名::静态方法

范例:Integer : : parseInt

```ruby
需求：
   集合中有以下数字，要求把他们都变成int类型
   "1","2","3","4","5"
*/
//1.创建集合并添加元素
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list,"1","2","3","4","5");

//2.把他们都变成int类型
list.stream().map(new Function<String, Integer>() {
   @Override
   public Integer apply(String s) {
       int i = Integer.parseInt(s);
       return i;
   }
}).forEach(s -> System.out.println(s));
```

方法引用:

```ruby
list.stream()
        .map(Integer::parseInt)
        .forEach(s-> System.out.println(s));
```

### 引用成员方法

格式:对象::成员方法

其他类: 其他类对象::方法名

本类: this::方法名(引用处不能是静态方法)

父类: super::方法名(引用处不能是静态方法)

```ruby
StringOperation so = new StringOperation();
list.stream().filter(so::stringJudge)
        .forEach(s-> System.out.println(s));
```

```ruby
public class StringOperation {
    public boolean stringJudge(String s){
        return s.startsWith("张") && s.length() == 3;
    }
}
```

如果方法写在本类,不能直接用this :: 方法名()调用

因为静态方法(main方法)是没有this的
```ruby
静态方法没有this是因为静态方法是属于类而不是属于对象的。在Java和其他一些面向对象编程语言中，类是一个模板，用于创建具有相似属性和方法的对象。当创建对象时，会使用该类的构造函数来初始化对象的属性，并为该对象分配内存。因此，对象是类的一个实例，每个对象都有自己的状态和行为。

与此不同的是，静态方法是直接属于类本身的，而不是属于类的每个对象。这意味着在静态方法中，您不能使用this关键字来引用对象的实例变量或方法。相反，您只能访问静态变量和其他静态方法，因为它们属于类本身，而不是属于对象。

因此，当您需要访问类级别的变量或执行类级别的操作时，可以使用静态方法。而当您需要访问对象级别的变量或执行对象级别的操作时，则需要使用实例方法，并使用this关键字引用当前对象的实例变量或方法。
```

可以创建本类对象再调用:

```ruby
list.stream().filter(new FunctionDemo3()::stringJudge)
            .forEach(s-> System.out.println(s));

```

### 引用构造方法

格式:类名 :: new

范例:student :: new

```ruby
//需求：
//     集合里面存储姓名和年龄，要求封装成Student对象并收集到List集合中
List<Student> newList = list.stream().map(new Function<String, Student>() {
    @Override
    public Student apply(String s) {
        String[] arr = s.split(",");
        String name = arr[0];
        int age = Integer.parseInt(arr[1]);
        return new Student(name, age);
    }
}).collect(Collectors.toList());

```

```ruby
List<Student> newList2 = list.stream().map(Student::new).collect(Collectors.toList());

//下面是重载的构造方法,没有返回值,Student::new引用时返回该对象
public Student(String str) {
    String[] arr = str.split(",");
    this.name = arr[0];
    this.age = Integer.parseInt(arr[1]);
}
```

### 其它调用方式

**使用类名引用成员方法**

格式:类名::成员方法

范例:string : : substring

```ruby
/*
方法引用（类名引用成员方法）
格式
        类名::成员方法
需求：
     集合里面一些字符串，要求变成大写后进行输出

抽象方法形参的详解：
第一个参数：表示被引用方法的调用者，决定了可以引用哪些类中的方法
            在Stream流当中，第一个参数一般都表示流里面的每一个数据。
            假设流里面的数据是字符串，那么使用这种方式进行方法引用，只能引用String这个类中的方法

第二个参数到最后一个参数：跟被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法

局限性：
    不能引用所有类中的成员方法。
    是跟抽象方法的第一个参数有关，这个参数是什么类型的，那么就只能引用这个类中的方法。

*/

//1.创建集合对象
ArrayList<String> list = new ArrayList<>();
//2.添加数据
Collections.addAll(list, "aaa", "bbb", "ccc", "ddd");
//3.变成大写后进行输出
//map(String::toUpperCase)
//拿着流里面的每一个数据，去调用String类中的toUpperCase方法，方法的返回值就是转换之后的结果。
list.stream().map(String::toUpperCase).forEach(s -> System.out.println(s));

```

引用数组的构造方法

```ruby
格式:数据类型[] :: new
范例: int[]  :: new
```

# 异常

![image](https://user-images.githubusercontent.com/88382462/221524168-252df432-9151-42f8-b44f-10d16a555a1f.png)

**Error:代表的系统级别错误（属于严重问题)**

系统一旦出现问题，sun公司会把这些错误封装成Error对象。Error是给sun公司自己用的，不是给我们程序员用的。

因此我们开发人员不用管它。

**Exception:叫做异常，代表程序可能出现的问题。**

我们通常会用Exception以及他的子类来封装程序出现的问题。

运行时异常:RuntimeException及其子类，编译阶段不会出现异常提醒。运行时出现的异常（如:数组索引越界异常)

编译时异常:编译阶段就会出现异常提醒的。（如:日期解析异常)

1．异常是什么?

程序中可能出现的问题

2．异常体系的最上层父类是谁?异常分为几类?

父类:Exception

异常分为两类∶编译时异常、运行时异常

3．编译时异常和运行时异常的区别?

**编译时异常**:没有继承RuntimeExcpetion的异常，直接继承于Excpetion。编译阶段就会错误提示

**运行时异常**:RuntimeException本身和子类。编译阶段没有错误提示，运行时出现的

```ruby
//编译时异常(在编译阶段，必须要手动处理，否则代码报错)
String time = "2030年1月1日";
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");
Date date = sdf.parse(time);  //需要在方法后加上throws ParseException 
System.out.println(date);

//运行时异常（在编译阶段是不需要处理的，是代码运行时出现的异常）
int[] arr = {1,2,3,4,5};
System.out.println(arr[10]);//ArrayIndexOutOfBoundsException

```

![image](https://user-images.githubusercontent.com/88382462/221530518-370ccedf-e232-4e64-8e91-481b8bdf48ab.png)

## 异常的作用

作用一:异常是用来查询bug的关键参考信息

作用二:异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况

## 异常的处理方式

### 1.JVM默认的处理方式

把异常的名称，异常原因及异常出现的位置等信息输出在了控制台

程序停止执行，下面的代码不会再执行了

### 2.自己处理(捕获异常)

格式:

```ruby
try {
   可能出现异常的代码;
} catch(异常类名 变量名) {
   异常的处理代码;
}
```

例程

```ruby
int[] arr = {1, 2, 3, 4, 5, 6};
try{
    //可能出现异常的代码;
    System.out.println(arr[10]);//此处出现了异常，程序就会在这里创建一个ArrayIndexOutOfBoundsException对象
                                //new ArrayIndexOutOfBoundsException();
                                //拿着这个对象到catch的小括号中对比，看括号中的变量是否可以接收这个对象
                                //如果能被接收，就表示该异常就被捕获（抓住），执行catch里面对应的代码
                                //当catch里面所有的代码执行完毕，继续执行try...catch体系下面的其他代码
}catch(ArrayIndexOutOfBoundsException e){
    //如果出现了ArrayIndexOutOfBoundsException异常，我该如何处理
    System.out.println("索引越界了");
}

System.out.println("看看我执行了吗？");  //执行了
```

#### 自己处理（灵魂四问)

**灵魂一问:如果try中没有遇到问题，怎么执行?**

会把try里面所有的代码全部执行完毕，不会执行catch里面的代码

注意：
只有当出现了异常才会执行catch里面的代码


**灵魂二问:如果try中可能会遇到多个问题，怎么执行?**

 会写多个catch与之对应

 细节：
     如果我们要捕获多个异常，这些异常中如果存在父子关系的话，那么父类一定要写在下面

 了解性：
     在JDK7之后，我们可以在catch中同时捕获多个异常，中间用|进行隔开
     表示如果出现了A异常或者B异常的话，采取同一种处理方案

```ruby
 //JDK7
 int[] arr = {1, 2, 3, 4, 5, 6};

 try{
     System.out.println(arr[10]);//ArrayIndexOutOfBoundsException
     System.out.println(2/0);//ArithmeticException
     String s = null;
     System.out.println(s.equals("abc"));
 }catch (ArrayIndexOutOfBoundsException | ArithmeticException e){
     System.out.println("数组越界或者空指针异常");
 }catch (NullPointerException e){
     System.out.println("空指针异常");
 }
```


**灵魂三问:如果try中遇到的问题没有被捕获，怎么执行?**

如果try中遇到的问题没有被捕获，怎么执行？

相当于try...catch的代码白写了，最终还是会交给虚拟机进行处理。


**灵魂四问:如果try中遇到了问题，那么try下面的其他代码还会执行吗?**

下面的代码就不会执行了，直接跳转到对应的catch当中，执行catch里面的语句体

但是如果没有对应catch与之匹配，那么还是会交给虚拟机进行处理

Throwable 成员方法

| 方法名称 |	说明 |
| --- | --- |
| public string getMessage() |	返回此 throwable的详细消息字符串 |
| public string tostring() |	返回此可抛出的简短描述 |
| public voidprintstackTrace() |	把异常的错误信息输出在控制台 |

```ruby
try {
    System.out.println(arr[10]);
} catch (ArrayIndexOutOfBoundsException e) {
    String message = e.getMessage();
    System.out.println(message);//Index 10 out of bounds for length 6

    String str = e.toString();
    System.out.println(str);//java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 6

    e.printStackTrace();

}
System.out.println("看看我执行了吗？");
```


### 3.抛出异常

Throw 和 Throws

![image](https://user-images.githubusercontent.com/88382462/221766057-30a8592c-9ad0-4259-bfa3-770d1e3d2623.png)

```ruby
 public static void main(String[] args) {
/*
     throws：写在方法定义处，表示声明一个异常。告诉调用者，使用本方法可能会有哪些异常。
     throw ：写在方法内，结束方法。手动抛出异常对象，交给调用者。方法中下面的代码不再执行了。

     需求：
         定义一个方法求数组的最大值
*/

     int[] arr = {};
     int max = 0;
     try {
         max = getMax(arr);
     } catch (NullPointerException e) {
         System.out.println("空指针异常");
     } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("索引越界异常");
     }

     System.out.println(max);

 }

 public static int getMax(int[] arr)/* throws NullPointerException,ArrayIndexOutOfBoundsException*/{
     if(arr == null){
         //手动创建一个异常对象，并把这个异常交给方法的调用者处理
         //此时方法就会结束，下面的代码不会再执行了
        throw new NullPointerException();
     }

     if(arr.length == 0){
         //手动创建一个异常对象，并把这个异常交给方法的调用者处理
         //此时方法就会结束，下面的代码不会再执行了
         throw new ArrayIndexOutOfBoundsException();
     }

     System.out.println("看看我执行了吗？");
     int max = arr[0];
     for (int i = 1; i < arr.length; i++) {
         if(arr[i] > max){
             max = arr[i];
         }
     }
     return max;
 }
```

1．虚拟机默认处理异常的方式

把异常信息以红色字体打印在控制台，并结束程序

2．捕获: try...catch

一般用在调用处，能让代码继续往下运行。

3．抛出: throw throws

在方法中，出现异常了。方法就没有继续运行下去的意义了，采取抛出处理。
让该方法结束运行并告诉调用者出现了问题。

```ruby
public void setName(String name)  {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new RuntimeException();
    }
    this.name = name;
}
```

```ruby
/*
    需求：
        键盘录入自己心仪的女朋友姓名和年龄。
        姓名的长度在 3 - 10之间，
        年龄的范围为 18 - 40岁,
        超出这个范围是异常数据不能赋值，需要重新录入,一直录到正确为止。
    提示：
        需要考虑用户在键盘录入时的所有情况。
        比如：录入年龄时超出范围，录入年龄时录入了abc等情况
*/


//1.创建键盘录入的对象
Scanner sc = new Scanner(System.in);
//2.创建女朋友的对象
GirlFriend gf = new GirlFriend();
while (true) {
    //3.接收女朋友的姓名
    try {
        System.out.println("请输入你心仪的女朋友的名字");
        String name = sc.nextLine();
        gf.setName(name);
        //4.接收女朋友的年龄
        System.out.println("请输入你心仪的女朋友的年龄");
        String ageStr = sc.nextLine();
        int age = Integer.parseInt(ageStr);
        gf.setAge(age);
        //如果所有的数据都是正确的，那么跳出循环
        break;
    } catch (NumberFormatException e) {
        System.out.println("年龄的格式有误，请输入数字");
        //continue;
    } catch (RuntimeException e) {
        System.out.println("姓名的长度或者年龄的范围有误");
        //continue;
    }
}
//5.打印
System.out.println(gf);
```

```ruby
public void setAge(int age) {
    if(age < 18 || age > 40){
        throw new RuntimeException();
    }
    this.age = age;
}
public void setName(String name)  {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new RuntimeException();
    }
    this.name = name;
}
```

### 自定义异常

意义:就是为了让控制台的报错信息更加的见名知意

**写自定义异常步骤**

1.定义异常类

2.写继承关系

3.空参构造

4.带参构造

异常类:

```ruby
public class NameFormatException extends RuntimeException{
    //技巧：
    //NameFormat：当前异常的名字，表示姓名格式化问题
    //Exception：表示当前类是一个异常类

    // 继承:
    //运行时：RuntimeException 核心 就表示由于参数错误而导致的问题
    //编译时：Exception 核心 提醒程序员检查本地信息


    public NameFormatException() {
    }

    public NameFormatException(String message) {
        super(message);
    }
}

public class AgeOutOfBoundsException extends RuntimeException{

    public AgeOutOfBoundsException() {
    }

    public AgeOutOfBoundsException(String message) {
        super(message);
    }
}
```

调用:

```ruby
public void setName(String name) {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new NameFormatException(name + "格式有误，长度应该为：3~10");
    }
    this.name = name;
}

public void setAge(int age) {
    if(age < 18 || age > 40){
       throw new AgeOutOfBoundsException(age + "超出了范围");
    }
    this.age = age;
}

catch (NumberFormatException e) {
    e.printStackTrace();
} catch (NameFormatException e) {
    e.printStackTrace();
}catch (AgeOutOfBoundsException e) {
    e.printStackTrace();
}
```

# File

File对象就表示一个路径，可以是文件的路径、也可以是文件夹的路径

这个路径可以是存在的，也允许是不存在的

## File构造方法:

|方法名称 |	说明 |
|---|---|
|public File(string pathname) |	根据文件路径创建文件对象 |
|public File(string parent，string child) |	根据父路径名字符串和子路径名字符串创建文件对象 |
|public File(File parent，string child) |	根据父路径对应文件对象和子路径名字符串创建文件对象 |

```ruby
//1.根据字符串表示的路径，变成File对象
String str = "C:\\Users\\tql\\Desktop\\a.txt";
File f1 = new File(str);
System.out.println(f1);//C:\Users\tql\Desktop\a.txt

//2.父级路径：C:\Users\tql\Desktop
//子级路径：a.txt
String parent = "C:\\Users\\tql\\Desktop";
String child = "a.txt";
File f2 = new File(parent,child);
System.out.println(f2);//C:\Users\tql\Desktop\a.txt

File f3 = new File(parent + "\\" + child);
System.out.println(f3);//C:\Users\tql\Desktop\a.txt

//3.把一个File表示的路径和String表示路径进行拼接
File parent2 = new File("C:\\Users\\tql\\Desktop");
String child2 = "a.txt";
File f4 = new File(parent2,child2);
System.out.println(f4);//C:\Users\tql\Desktop\a.txt
```

## File成员方法

### 判断/获取

| 方法名称 |	说明 |
|---|---|
| public boolean isDirectory() |	判断此路径名表示的File是否为文件夹 |
| public boolean isFile() |	判断此路径名表示的File是否为文件 |
| public boolean exists() |	判断此路径名表示的File是否存在 |
| public long length() |	返回文件的大小（字节数量)|
| public string getAbsolutePath() |	返回文件的绝对路径|
| public string getPath() |	返回定义文件时使用的路径|
| public string getName() |	返回文件的名称，带后缀|
| public long lastModified() |	返回文件的最后修改时间（时间毫秒值)|

```ruby
//对一个文件的路径进行判断
File f1 = new File("D:\\aaa\\a.txt");
System.out.println(f1.isDirectory());//false
System.out.println(f1.isFile());//true
System.out.println(f1.exists());//true
```

```ruby
//1.length  返回文件的大小（字节数量）
//细节1：这个方法只能获取文件的大小，单位是字节
//如果单位我们要是M，G，可以不断的除以1024
//细节2：这个方法无法获取文件夹的大小
//如果我们要获取一个文件夹的大小，需要把这个文件夹里面所有的文件大小都累加在一起。

File f1 = new File("D:\\aaa\\a.txt");
long len = f1.length();
System.out.println(len);//3

File f2 = new File("D:\\aaa\\bbb");
long len2 = f2.length();
System.out.println(len2);//0

//2.getAbsolutePath 返回文件的绝对路径
File f3 = new File("D:\\aaa\\a.txt");
String path1 = f3.getAbsolutePath();
System.out.println(path1);

File f4 = new File("myFile\\a.txt");
String path2 = f4.getAbsolutePath();
System.out.println(path2);  //C:\Users\tql\IdeaProjects\basic-code\myFile\a.txt

//3.getPath 返回定义文件时使用的路径
File f5 = new File("D:\\aaa\\a.txt");
String path3 = f5.getPath();
System.out.println(path3);//D:\aaa\a.txt

File f6 = new File("myFile\\a.txt");
String path4 = f6.getPath();
System.out.println(path4);//myFile\a.txt

//4.getName 获取名字
//细节1：
//a.txt:
//      a 文件名
//      txt 后缀名、扩展名
//细节2：
//文件夹：返回的就是文件夹的名字
File f7 = new File("D:\\aaa\\a.txt");
String name1 = f7.getName();
System.out.println(name1);


File f8 = new File("D:\\aaa\\bbb");
String name2 = f8.getName();
System.out.println(name2);//bbb

//5.lastModified  返回文件的最后修改时间（时间毫秒值）
File f9 = new File("D:\\aaa\\a.txt");
long time = f9.lastModified();
System.out.println(time);//1667380952425

//如何把时间的毫秒值变成字符串表示的时间呢？
//课堂练习：
//yyyy年MM月dd日 HH：mm：ss
Date date = new Date(time);
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
System.out.println(sdf.format(date));

```

### 创建/删除

|方法名称|	说明|
|---|---|
|public boolean createNewFile()	|创建一个新的空的文件|
|public boolean mkdir()|	创建单级文件夹|
|public boolean mkdirs()	|创建多级文件夹|
|public boolean delete()	|删除文件、空文件夹|

**delete方法默认只能删除文件和空文件夹，delete方法直接删除不走回收站**

```ruby
//1.createNewFile 创建一个新的空的文件
//细节1：如果当前路径表示的文件是不存在的，则创建成功，方法返回true
//      如果当前路径表示的文件是存在的，则创建失败，方法返回false
//细节2：如果父级路径是不存在的，那么方法会有异常IOException
//细节3：createNewFile方法创建的一定是文件，如果路径中不包含后缀名，则创建一个没有后缀的文件
File f1 = new File("D:\\aaa\\ddd");
boolean b1 = f1.createNewFile();
System.out.println(b1);//true


//2.mkdir   make Directory，文件夹（目录）
//细节1：windows当中路径是唯一的，如果当前路径已经存在，则创建失败，返回false
//细节2：mkdir方法只能创建单级文件夹，无法创建多级文件夹。
File f2 = new File("D:\\aaa\\aaa\\bbb\\ccc");
boolean b2 = f2.mkdir();
System.out.println(b2);

//3.mkdirs   创建多级文件夹
//细节：既可以创建单级的，又可以创建多级的文件夹
File f3 = new File("D:\\aaa\\ggg");
boolean b3 = f3.mkdirs();
System.out.println(b3);//true
```

```ruby
/*
  public boolean delete()             删除文件、空文件夹
  细节：
      如果删除的是文件，则直接删除，不走回收站。
      如果删除的是空文件夹，则直接删除，不走回收站
      如果删除的是有内容的文件夹，则删除失败
*/


  //1.创建File对象
  File f1 = new File("D:\\aaa\\eee");
  //2.删除
  boolean b = f1.delete();
  System.out.println(b);
```

### 获取/遍历

|方法名称|	说明 |
|---|---|
|public static File[] listRoots()                |列出可用的文件系统根|
|public String[] list()                          |获取当前该路径下所有内容|
|public String[] list(FilenameFilter filter)     |利用文件名过滤器获取当前该路径下所有内容|
|（掌握）public File[] listFiles()               |获取当前该路径下所有内容|
|public File[] listFiles(FileFilter filter)      |利用文件名过滤器获取当前该路径下所有内容|
|public File[] listFiles(FilenameFilter filter)  |利用文件名过滤器获取当前该路径下所有内容|


public File[] listFiles()       获取当前该路径下所有内容

当调用者File表示的路径不存在时，返回null当调用者File表示的路径是文件时，返回null

当调用者File表示的路径是一个空文件夹时，返回一个长度为0的数组

当调用者File表示的路径是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回

当调用者File表示的路径是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件夹

调用者File表示的路径是需要权限才能访问的文件夹时，返回null

```ruby
//1.创建File对象
File f = new File("D:\\aaa");
//2.listFiles方法
//作用：获取aaa文件夹里面的所有内容，把所有的内容放到数组中返回
File[] files = f.listFiles();
for (File file : files) {
    //file依次表示aaa文件夹里面的每一个文件或者文件夹
    System.out.println(file);
}
```

```ruby
//1.创建File对象
File f = new File("D:\\aaa");
//2.需求：打印里面所有的txt文件
File[] arr = f.listFiles();
for (File file : arr) {
    //file依次表示aaa文件夹里面每一个文件或者文件夹的路径
    if(file.isFile() && file.getName().endsWith(".txt")){
        System.out.println(file);
    }
}
```

```ruby
/*
 public File[] listFiles(FileFilter filter)      利用文件名过滤器获取当前该路径下所有内容
 public File[] listFiles(FilenameFilter filter)  利用文件名过滤器获取当前该路径下所有内容
*/

 //创建File对象
 File f = new File("D:\\aaa");
 //调用listFiles(FileFilter filter)
 File[] arr1 = f.listFiles(new FileFilter() {
     @Override
     public boolean accept(File pathname) {
         return pathname.isFile() && pathname.getName().endsWith(".txt");
     }
 });

 //调用listFiles(FilenameFilter filter)
 File[] arr2 = f.listFiles(new FilenameFilter() {
     @Override
     public boolean accept(File dir, String name) {
         File src = new File(dir, name);
         return src.isFile() && name.endsWith(".txt");
     }
 });
 System.out.println(Arrays.toString(arr2));
```

## File例程

File递归的套路

1，进入文件夹

2，遍历数组

3，判断

4，判断

1.找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）

```ruby
//需求：在当前模块下的aaa文件夹中创建一个a.txt文件

//1.创建a.txt的父级路径
File file = new File("myfile\\aaa");
//2.创建父级路径
//如果aaa是存在的，那么此时创建失败的。
//如果aaa是不存在的，那么此时创建成功的。
file.mkdirs();
//3.拼接父级路径和子级路径
File src = new File(file,"a.txt");
boolean b = src.createNewFile();
if(b){
    System.out.println("创建成功");
}else{
    System.out.println("创建失败");
}
```

```ruby
/* 需求：
    找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）


    套路：
        1，进入文件夹
        2，遍历数组
        3，判断
        4，判断

    */

    findAVI();


public static void findAVI(){
    //获取本地所有的盘符
    File[] arr = File.listRoots();
    for (File f : arr) {
        findAVI(f);
    }
}

public static void findAVI(File src){//"C:\\
    //1.进入文件夹src
    File[] files = src.listFiles();
    //2.遍历数组,依次得到src里面每一个文件或者文件夹
    if(files != null){
        for (File file : files) {
            if(file.isFile()){
                //3，判断，如果是文件，就可以执行题目的业务逻辑
                String name = file.getName();
                if(name.endsWith(".avi")){
                    System.out.println(file);
                }
            }else{
                //4，判断，如果是文件夹，就可以递归
                //细节：再次调用本方法的时候，参数一定要是src的次一级路径
                findAVI(file);
            }

        }
    }
}
```

2.删除一个多级文件夹

```ruby
/*
       删除一个多级文件夹
       如果我们要删除一个有内容的文件夹
       1.先删除文件夹里面所有的内容
       2.再删除自己
    */

    File file = new File("D:\\aaa\\src");
    delete(file);

/*
* 作用：删除src文件夹
* 参数：要删除的文件夹
* */
public static void delete(File src){
    //1.先删除文件夹里面所有的内容
    //进入src
    File[] files = src.listFiles();
    //遍历
    for (File file : files) {
        //判断,如果是文件，删除
        if(file.isFile()){
            file.delete();
        }else {
            //判断,如果是文件夹，就递归
            delete(file);
        }
    }
    //2.再删除自己
    src.delete();
}
```

3.统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）

```ruby
public static void main(String[] args) {
           /*
        需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）
        打印格式如下：
        txt:3个
        doc:4个
        jpg:6个


    */
    File file = new File("D:\\3dStar");
    //创建HashMap存文件夹类型和数量
    HashMap<String , Integer> hm = new HashMap<>();
    HashMap<String, Integer> hm1 = getCount(file, hm);
    System.out.println(hm1.toString());
}

/*
 * 作用：
 *       统计一个文件夹中每种文件的个数
 * 参数：
 *       要统计的那个文件夹
 * 返回值：
 *       用来统计map集合
 *       键：后缀名 值：次数
 *
 *       a.txt
 *       a.a.txt
 *       aaa（不需要统计的）
 *
 *
 * */
public static HashMap<String , Integer> getCount(File file ,HashMap<String , Integer> hm){
    //进入file文件夹
    File[] files = file.listFiles();
    //如果文件夹不为空则遍历文件夹
    if(files != null) {
        for (File file1 : files) {
            if (file1.isFile()) {
                //判断,如果是文件,取出后缀,注意:"."要用转义的点
                String[] split = file1.getName().split("\\.");
                //如果文件是没有后缀的文件,不统计
                if(split.length >= 2) {
                    String end = split[split.length - 1];
                    if (hm.containsKey(end)) {
                        //键存在
                        Integer count = hm.get(end);
                        count++;
                        hm.put(end, count);
                    } else {
                        //键不存在
                        hm.put(end, 1);
                    }
                }
            } else {
                //进入下一轮递归
                getCount(file1, hm);
            }
        }
    }
    //返回最终的集合
    return hm;
}
```









