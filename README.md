# basic-code
学习java  来自“黑马程序员”
自己学着写的一些代码和笔记
www.bilibili.com/video/BV17F411T7Ao/

# ASCII码表
![image](https://user-images.githubusercontent.com/88382462/191399708-bb773f47-edba-4dc2-bd5e-e0a0f3a02a49.png)

# StringBulider
![image](https://user-images.githubusercontent.com/88382462/191155163-0dd85d31-26d6-4895-b6db-71f2d8e48e37.png)
![image](https://user-images.githubusercontent.com/88382462/191155287-762282d0-aa3b-4bdd-914f-8a16fd8168b6.png)


# StringJoiner
![image](https://user-images.githubusercontent.com/88382462/191153955-746ade56-8bb6-4977-a477-283ca3bc60a8.png)
![image](https://user-images.githubusercontent.com/88382462/191154100-0753ce4d-bed5-4464-90f6-6e571ac6a467.png)

# String 原理
![image](https://user-images.githubusercontent.com/88382462/191155697-a474ae17-1173-4f39-b7e1-50ad72a37499.png)
![image](https://user-images.githubusercontent.com/88382462/191155904-e568b602-ad33-4c75-878e-065b95103c9d.png)

## 在涉及变量的拼接：
![image](https://user-images.githubusercontent.com/88382462/191156880-ece65d93-e280-4cec-bf0f-25e77dac2d1d.png)

![image](https://user-images.githubusercontent.com/88382462/191157706-1e27a209-d65a-46c9-bb26-355eb8a9a50d.png)
![image](https://user-images.githubusercontent.com/88382462/191157852-7e1150a1-6dc9-41c2-a8f1-c083fe3ed9d1.png)

![image](https://user-images.githubusercontent.com/88382462/191158030-5208296e-7707-43b3-8512-1b8b639d74b2.png)

# 集合
## 集合和数组的区别
![image](https://user-images.githubusercontent.com/88382462/191681113-d181f93b-dc67-463e-9b6d-de873e11c33d.png)

## 创建集合
![image](https://user-images.githubusercontent.com/88382462/191681168-12a4df9e-556c-4890-99c0-425ee8b83e4a.png)
## ArrayList成员方法
![image](https://user-images.githubusercontent.com/88382462/191681202-a6828d87-5eac-4c7d-9125-196664de8416.png)

![image](https://user-images.githubusercontent.com/88382462/191681249-8ae97d4b-f69d-4d5c-b8b2-a8f252fdf324.png)
![image](https://user-images.githubusercontent.com/88382462/191681279-d47458c5-8cc2-4f5c-b31d-10c501e768a0.png)
## 基本数据类型的包装类
![image](https://user-images.githubusercontent.com/88382462/191681309-dbce7e0d-16d5-4614-835a-a61f72a16740.png)
![image](https://user-images.githubusercontent.com/88382462/191681357-4e1e2a00-12bc-4f50-a64b-504f986c4408.png)

## 当循环嵌套时想退出外面的循环
![image](https://user-images.githubusercontent.com/88382462/191693489-485ca7dc-03ff-4051-9732-f7c087ecbdff.png)

# static
## 内存分析
![image](https://user-images.githubusercontent.com/88382462/192304073-f85684a5-954f-4247-94ed-fd353dc365c5.png)
![image](https://user-images.githubusercontent.com/88382462/192304670-74834351-597c-419f-81ae-a937055c4527.png)
![image](https://user-images.githubusercontent.com/88382462/192304854-b2bc9c63-b6af-40a4-97dd-7702be041948.png)
![image](https://user-images.githubusercontent.com/88382462/192305802-505213c1-8d53-464e-aaa1-3dad22fde0fb.png)

## 工具类
### 工具类描述
![image](https://user-images.githubusercontent.com/88382462/192308437-5af3525f-8043-4630-884f-09229393036d.png)
![image](https://user-images.githubusercontent.com/88382462/192309085-c3b4002e-7258-40f9-96b9-6c6544032a8d.png)

## static 关键字
![image](https://user-images.githubusercontent.com/88382462/192316588-29ac02f0-db94-4db4-9e70-36f0d0739e66.png)

## static 注意事项
![image](https://user-images.githubusercontent.com/88382462/192316904-a425d31f-c6b4-4136-ae32-9f9706334dc3.png)


# 封装和继承
## 封装图解
![image](https://user-images.githubusercontent.com/88382462/192415469-a34ea306-7f65-4740-a7f8-a45de43af7d6.png)

## 继承

### 继承的定义及好处
![image](https://user-images.githubusercontent.com/88382462/192416569-a9f9a1c5-1e18-40b9-93c6-d66e6796cab8.png)

![image](https://user-images.githubusercontent.com/88382462/192416738-f0a01b2a-2978-47e7-a9a8-44a8f0367ab3.png)

![image](https://user-images.githubusercontent.com/88382462/192416905-b47ee3e4-53af-4321-947e-32c27edff7d6.png)

### 继承的格式
![image](https://user-images.githubusercontent.com/88382462/192417934-f56a5bfe-5ad1-42a5-aa6b-70eba4e3608e.png)

![image](https://user-images.githubusercontent.com/88382462/192418395-a71d9e29-980e-41d6-a9e1-dafb78cdb9f5.png)

### 继承中成员变量的访问特点
![image](https://user-images.githubusercontent.com/88382462/192470608-a3ab47c5-96f0-410c-b124-2aad27d55e94.png)

![image](https://user-images.githubusercontent.com/88382462/192729991-69d7e9e4-02f7-4055-9c1f-014acd9bf3b7.png)

![image](https://user-images.githubusercontent.com/88382462/192730532-b4b46699-12e4-45f4-8e87-8c03b445ca37.png)

![image](https://user-images.githubusercontent.com/88382462/192733170-5553bda4-2439-49e5-b234-2851ef02bf16.png)

### 继承中成员方法的访问特点
![image](https://user-images.githubusercontent.com/88382462/192733283-923e1df5-c625-4112-a248-e74e5a94cfcb.png)

![image](https://user-images.githubusercontent.com/88382462/192735006-f4046805-d193-4dc9-bbda-5903fc419dfd.png)

![image](https://user-images.githubusercontent.com/88382462/192735504-55e535e9-eee0-49fe-a52a-f2b3108a3d1d.png)

![image](https://user-images.githubusercontent.com/88382462/192736250-1be90fd5-642c-4b35-91a7-76ad5f3419d4.png)

![image](https://user-images.githubusercontent.com/88382462/192742068-11b7d9a9-1d72-4f36-afd8-be42e9f89454.png)

### 继承中构造方法的访问特点
![image](https://user-images.githubusercontent.com/88382462/192742588-5d1e408a-ae98-44f2-89ce-a75ba33267d8.png)

![image](https://user-images.githubusercontent.com/88382462/192744675-ac244198-c158-4cab-827a-8151e9766c6e.png)

### this/super 使用总结
![image](https://user-images.githubusercontent.com/88382462/192746319-824bdb7d-011a-41a3-ad74-2950e53495c3.png)

![image](https://user-images.githubusercontent.com/88382462/192746886-4d33f32a-db60-4a65-a6da-3ce87af066e9.png)

## 多态

### 什么是多态
![image](https://user-images.githubusercontent.com/88382462/193443335-096a6f91-f6f7-4176-a72d-c11d7d5d0ef4.png)

![image](https://user-images.githubusercontent.com/88382462/193443788-4539d724-0449-4690-b311-4defa0559bdb.png)

### 多态调用成员变量和成员方法的特点
![image](https://user-images.githubusercontent.com/88382462/193443816-72ea183c-721b-44b7-b120-0baeb34adcf4.png)

**调用成员变量:编译看左边，运行也看左边**

编译看左边: javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。

运行也看左边: java运行代码的时候，实际获取的就是左边父类中成员变量的值

**调用成员方法:编译看左边，运行看右边**

编译看左边: javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。

运行看右边: java运行代码的时候，实际上运行的是子类中的方法。

### 多态的优势
![image](https://user-images.githubusercontent.com/88382462/193444370-6abd8aba-8969-4499-85c4-4a866aa16d8e.png)

### 多态的弊端
**不能调用子类的特有功能**

调用会报错,报错的原因?

当调用成员方法的时候，编译看左边，运行看右边

那么在编译的时候会先检查左边的父类中有没有这个方法，如果没有直接报错。

解决方案:

变回子类类型就可以了（可以用强制转换）（但是瞎转转成其他的对象就会报错）

可以用instanceof来判断对象是什么类型的

![image](https://user-images.githubusercontent.com/88382462/193444895-5379e9b7-707e-4bd1-bda4-1df4ff106bb9.png)

![image](https://user-images.githubusercontent.com/88382462/193445015-6ce2109b-6a93-47dd-84ae-2c35afcd67bf.png)

![image](https://user-images.githubusercontent.com/88382462/193445071-d6231b8c-3518-44cf-b915-22fab0dc3d17.png)

### 多态总结
![image](https://user-images.githubusercontent.com/88382462/193445126-da9512d4-5399-4961-9c7f-af2eb7e1876c.png)

# 包
## 包的定义
![image](https://user-images.githubusercontent.com/88382462/193446805-7f347726-8623-455a-aa3f-488d0baeec2a.png)
## 导包
![image](https://user-images.githubusercontent.com/88382462/193446840-70b0a958-a83c-4b3a-9698-3b907a67be27.png)
![image](https://user-images.githubusercontent.com/88382462/193446859-b8d12557-8e98-47a1-9795-2f6e17670ac5.png)
![image](https://user-images.githubusercontent.com/88382462/193447098-53feddfa-3c23-4920-bf77-2f6459d4fe41.png)

## final关键字
![image](https://user-images.githubusercontent.com/88382462/193462016-7ec4148f-427c-45f8-b036-cc376f876385.png)

![image](https://user-images.githubusercontent.com/88382462/193462339-431f325e-516d-4dd2-a834-eaf93fc3dcc9.png)

![image](https://user-images.githubusercontent.com/88382462/194689623-3bc7be28-2a4c-4f96-b9fe-a8ef5b5b9c7d.png)
 
 ## 权限修饰符分类和使用规则
![image](https://user-images.githubusercontent.com/88382462/194888059-6035f9b8-c882-4d9a-ad46-316fc4566c7f.png)

## 构造代码块
![image](https://user-images.githubusercontent.com/88382462/194889136-d35f4f08-620b-4d4b-8868-6d54f440fe3d.png)

但是构造代码块很少使用，如果多个构造方法有一些相同的代码可以用以下的方式
![image](https://user-images.githubusercontent.com/88382462/194890863-95023260-7f07-44ee-b90c-26ffe50786f6.png)

### 静态代码块

![image](https://user-images.githubusercontent.com/88382462/194895174-20e9d72a-646d-4411-b7a8-6b1451143d6c.png)

## 抽象方法和抽象类
![image](https://user-images.githubusercontent.com/88382462/194896373-61105c1f-8748-42fd-988a-8b181332aba0.png)

![image](https://user-images.githubusercontent.com/88382462/194896523-1654cc9a-df52-4efa-a152-1e091bdefc1a.png)
 
 ![image](https://user-images.githubusercontent.com/88382462/194897297-542c908f-421d-4a3c-a74a-865f9d02dc19.png)

 # 接口
 ## 接口定义和使用
 ![image](https://user-images.githubusercontent.com/88382462/195065577-fbdf768a-5060-4811-a685-61abccaeec94.png)

 ![image](https://user-images.githubusercontent.com/88382462/195073694-05c38cc1-a574-41c3-9e9a-86dce0e12e99.png)
 
## 接口中成员特点 
![image](https://user-images.githubusercontent.com/88382462/195078798-3681c96d-6718-4f16-8291-82278773fe14.png)

## 接口和类的关系
![image](https://user-images.githubusercontent.com/88382462/195083063-26424218-1de6-4d89-bb2e-9d469f7b8402.png)

## JDK8和JDK9接口新增方法
![image](https://user-images.githubusercontent.com/88382462/195088563-1fb53c54-045b-48d8-b510-7ccb82b32e49.png)

![image](https://user-images.githubusercontent.com/88382462/195090214-7be3fda3-19a7-4f11-a869-0a65d41d6142.png)

![image](https://user-images.githubusercontent.com/88382462/195091618-c05e421b-0d9b-433b-bf9b-51433cbedb00.png)
 
![image](https://user-images.githubusercontent.com/88382462/195093990-dc58c43b-025e-44dc-9c97-7dc6ce19d777.png)

![image](https://user-images.githubusercontent.com/88382462/195094439-fb2cb0da-d8d9-4d97-8323-c15e7721e7de.png)
  
 ![image](https://user-images.githubusercontent.com/88382462/195094808-f6a4c0c4-1903-41bb-a94b-bfac6c4f9589.png)

![image](https://user-images.githubusercontent.com/88382462/195252965-d6816991-33a0-441d-8502-e849aa031a6f.png)

## 接口多态
当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。
![image](https://user-images.githubusercontent.com/88382462/195253161-c69b1e31-1e7a-4a97-a587-78dff5b2e33f.png)

## 适配器设计模式
![image](https://user-images.githubusercontent.com/88382462/195254134-50fc1e71-96f5-4cb4-a337-f9bce80aa09e.png)

# 内部类
## 什么是内部类
![image](https://user-images.githubusercontent.com/88382462/195254292-1a41f7e2-ab97-48f3-b150-018170f2d1ed.png)

![image](https://user-images.githubusercontent.com/88382462/195254397-53904668-9f72-4e0b-9434-6cb4d413520c.png)

![image](https://user-images.githubusercontent.com/88382462/195254619-7c654814-f7a8-489a-8f24-be07ca01de38.png)

## 内部类分类
![image](https://user-images.githubusercontent.com/88382462/195256185-7aef5fc1-85d2-4be1-907a-c49d9dca4596.png)
### 成员内部类
![image](https://user-images.githubusercontent.com/88382462/195256696-9eb4026c-fa5c-4693-bb03-22065e2bcd6f.png)
![image](https://user-images.githubusercontent.com/88382462/195256859-66e2ceea-ce8e-4ea3-bef8-2f9baea508eb.png)
![image](https://user-images.githubusercontent.com/88382462/195257342-e49f4f13-ddea-443d-bec8-5c89d630ffad.png)
#### 内部类内存图
![image](https://user-images.githubusercontent.com/88382462/195263171-1bfd870d-b798-4901-a7d8-e9d752a3a8f3.png)
#### 成员内部类总结
![image](https://user-images.githubusercontent.com/88382462/195263454-432b485c-6c2c-40c0-97ea-c0e13d9dbe15.png)
### 静态内部类
![image](https://user-images.githubusercontent.com/88382462/195263693-86c89bbe-33aa-4625-8743-70fd6a976428.png)
### 局部内部类
![image](https://user-images.githubusercontent.com/88382462/195792742-0a970046-f7eb-4283-a96e-036502c5f61d.png)

### 匿名内部类(重要)
![image](https://user-images.githubusercontent.com/88382462/195794365-d429243f-b87e-4bce-a16a-5c23d8af1cf6.png)
![image](https://user-images.githubusercontent.com/88382462/195796546-a7d68049-352a-4c40-8e2c-baa1bd8fe3c4.png)
![image](https://user-images.githubusercontent.com/88382462/196916464-8b47eaca-d82d-4964-8244-40bc1494f54d.png)
![image](https://user-images.githubusercontent.com/88382462/196920860-7b162a88-584f-419f-8055-182fb4d5a757.png)

# GUI(Jframe)
![image](https://user-images.githubusercontent.com/88382462/196923244-775afbb2-8060-4180-9380-1359fe8f6c9f.png)
![image](https://user-images.githubusercontent.com/88382462/197311400-95c798c7-8aef-4889-9161-9ddabb3bd62c.png)
![image](https://user-images.githubusercontent.com/88382462/197311393-a51119d9-8f19-4c12-8f15-ab97719ec90a.png)
![image](https://user-images.githubusercontent.com/88382462/197311465-67557037-1e27-440f-9f19-568d9efe1dd1.png)
![image](https://user-images.githubusercontent.com/88382462/197311490-e726f93c-595d-4631-8b37-d5393f15b2e8.png)
![image](https://user-images.githubusercontent.com/88382462/197316325-30d3b4e3-e44f-4368-805f-d7172e3508d5.png)
![image](https://user-images.githubusercontent.com/88382462/197316480-e1679369-d7b3-423c-842e-05a8ed6855f7.png)
![image](https://user-images.githubusercontent.com/88382462/197980394-ac2e4889-8a87-4f15-b355-911d259c8e1a.png)
![image](https://user-images.githubusercontent.com/88382462/197989772-d1602dde-ca13-4023-a284-58ad0c24227e.png)
![image](https://user-images.githubusercontent.com/88382462/197989820-81550170-7a16-4654-adb8-16b06dbb5062.png)
![image](https://user-images.githubusercontent.com/88382462/197994468-5dc80479-3257-438a-8f06-4c8e6e8ff296.png)
![image](https://user-images.githubusercontent.com/88382462/197994598-977efe20-8e35-455b-aee9-612fd103364a.png)

# 一些常用工具类
## MATH类
![image](https://user-images.githubusercontent.com/88382462/200764190-add2f3ff-7071-4071-b3dc-d7459cfad150.png)
![image](https://user-images.githubusercontent.com/88382462/201478751-88158b35-9573-4560-8666-e6d6a60d3f9a.png)
![image](https://user-images.githubusercontent.com/88382462/201479007-4d835e91-944c-4cfd-9d09-63902ce8fbd0.png)

## SYSTEM
![image](https://user-images.githubusercontent.com/88382462/201480948-747235d7-4ee7-4247-8323-ea8e334bb10a.png)
![image](https://user-images.githubusercontent.com/88382462/201480916-681590ad-dfc9-4f01-b29b-7edf57f5a6a6.png)
![image](https://user-images.githubusercontent.com/88382462/201482246-f7a516da-df49-456a-b281-d3617273214a.png)

## RUNTIME
![image](https://user-images.githubusercontent.com/88382462/201514149-0d7deccb-1cc6-4e42-b0bc-8b6bd64125cd.png)
![image](https://user-images.githubusercontent.com/88382462/201514159-35c94581-09c1-45b9-b09c-8536a88b4b61.png)

## OBJECT
### Object构造方法
![image](https://user-images.githubusercontent.com/88382462/201514278-3ac501be-4849-409f-b462-496bd1682f7c.png)
### Object成员方法
![image](https://user-images.githubusercontent.com/88382462/201514302-75ea8fa9-2a31-4df3-93f3-37b2ceab4338.png)
 #### 重写toString
 ![image](https://user-images.githubusercontent.com/88382462/201514715-57b9d985-4a52-4457-a2bf-d5c6ad72b670.png)

![image](https://user-images.githubusercontent.com/88382462/201514989-434ce7c2-7c42-4f75-883f-7c168386e60d.png)
#### 重写equals
![image](https://user-images.githubusercontent.com/88382462/201515215-4164c423-e8f8-45d1-adab-7f0e079b6771.png)
![image](https://user-images.githubusercontent.com/88382462/201515557-bad20d9e-b956-473e-bea1-6dba832f6a0c.png)
#### 对象克隆(浅克隆和深克隆)
![image](https://user-images.githubusercontent.com/88382462/201515746-d5ce739d-7abf-4033-a68c-d34d22e2060c.png)
![image](https://user-images.githubusercontent.com/88382462/201516056-5640170d-598f-447d-93d9-42b2f6e18310.png)
![image](https://user-images.githubusercontent.com/88382462/201516124-5bf37ad7-e7a6-4a9d-a0ae-10d8b105e285.png)
![image](https://user-images.githubusercontent.com/88382462/201516181-544615e3-a52f-445d-afe6-bf347922bf86.png)
![image](https://user-images.githubusercontent.com/88382462/201516200-a6203523-0440-44f4-9c9b-6d48a1b6db4d.png)
![image](https://user-images.githubusercontent.com/88382462/201516281-18aa38a7-d90d-41f0-992b-92ec1464736c.png)
##### 第三方工具实现深克隆
![image](https://user-images.githubusercontent.com/88382462/201516765-cb35da72-235e-4658-b6e0-a7002a3be0f3.png)
### Object总结
![image](https://user-images.githubusercontent.com/88382462/201516792-8fc81685-3c07-4076-a7f3-591ec34126f3.png)

## OBJECTS
![image](https://user-images.githubusercontent.com/88382462/201690011-372cf37d-0e12-447c-b798-77ce08830a97.png)
![image](https://user-images.githubusercontent.com/88382462/201691646-428c632f-4839-42b0-9922-d7d0dcb3cae2.png)

## BigInteger
![image](https://user-images.githubusercontent.com/88382462/201692963-c96f9e39-0412-4c6b-bef3-da4ffa52da7e.png)
![image](https://user-images.githubusercontent.com/88382462/201699816-16fd12bf-1f51-4e0d-a4d0-a4bb4c4a6bbc.png)
![image](https://user-images.githubusercontent.com/88382462/201700211-fc75ea3e-d7ea-450b-b6a4-8e3b93f4e562.png)


## BigDecimal
![image](https://user-images.githubusercontent.com/88382462/201882203-a45ba5d2-f136-4b7b-b15c-00548dc1809e.png)
![image](https://user-images.githubusercontent.com/88382462/201885104-d50ef8b8-c98a-40c6-b3c5-957b8f1c30bc.png)
![image](https://user-images.githubusercontent.com/88382462/201885266-1bd73863-eb04-4777-a8f9-17b8164b2b92.png)
![image](https://user-images.githubusercontent.com/88382462/201888770-8783e06d-f643-48a9-be1e-928c8f94ed7b.png)

## Regex:正则表达式
![image](https://user-images.githubusercontent.com/88382462/201891646-35a26245-721d-41a6-babe-cd7b72d0846c.png)
![image](https://user-images.githubusercontent.com/88382462/201895122-97145d02-c0a1-4726-816d-e8c99c234f19.png)
![image](https://user-images.githubusercontent.com/88382462/201907062-e2d2178f-c424-49e8-8488-046e336ecab9.png)
![image](https://user-images.githubusercontent.com/88382462/201907135-ab359d3e-e114-4059-bbef-d7096e851079.png)
![image](https://user-images.githubusercontent.com/88382462/202378983-caf2d3ff-5b28-49da-aa9f-44ce40229342.png)
![image](https://user-images.githubusercontent.com/88382462/202379282-b9b949e9-f4e5-4c19-83d5-7ca6f15b59f3.png)
![image](https://user-images.githubusercontent.com/88382462/202381946-5fdf2a68-de36-4952-b9d0-cb4728429b3d.png)
![image](https://user-images.githubusercontent.com/88382462/202381707-ff552fba-6ed7-4209-adcf-f860bc6cdc6c.png)
![image](https://user-images.githubusercontent.com/88382462/202384021-835bf7eb-50f7-4147-b6c0-7a8061ddbeb3.png)
![image](https://user-images.githubusercontent.com/88382462/202396066-fa97c7c4-063f-4b4e-946e-36793d139985.png)
![image](https://user-images.githubusercontent.com/88382462/202397774-ac59c0d8-6a75-437b-a06c-93ae2920ae64.png)
![image](https://user-images.githubusercontent.com/88382462/202397837-a7d8be09-8e71-498c-a359-74739af8d980.png)
 ![image](https://user-images.githubusercontent.com/88382462/202402297-a0f728a0-8611-4c6c-8ee8-4fb8a7a38f75.png)
![image](https://user-images.githubusercontent.com/88382462/202896767-c63628d6-7b28-45eb-8a7a-9ace7a9778b8.png)
![image](https://user-images.githubusercontent.com/88382462/202897128-e32b547c-b209-4337-a7af-57e5a12888b2.png)
![image](https://user-images.githubusercontent.com/88382462/202897150-d2d0c30b-c247-45c6-bdc5-baf392e0180e.png)
![image](https://user-images.githubusercontent.com/88382462/202897249-10cfb18a-caa6-4a0f-b681-4c4661dd3d2f.png)
![image](https://user-images.githubusercontent.com/88382462/202897296-9d4f2289-76b4-4e29-9dde-0f06e5baac57.png)
![image](https://user-images.githubusercontent.com/88382462/202897438-7488ebcd-f9bc-46f7-be2a-e15f5bd07a19.png)
## Date
![image](https://user-images.githubusercontent.com/88382462/202897519-4ec553e9-35da-4ca9-b5e3-e39077141c72.png)
![image](https://user-images.githubusercontent.com/88382462/202897625-7919bea0-732b-4f10-a493-4be8d0fcaca2.png)
![image](https://user-images.githubusercontent.com/88382462/202899396-8a052354-fc84-47ee-8f19-9e935d86af34.png)
## SimpleDateFormat (时间格式化和解析)
![image](https://user-images.githubusercontent.com/88382462/202899912-18fea89a-87f4-47c6-b44d-e24a4acd6950.png)
![image](https://user-images.githubusercontent.com/88382462/202899960-babd0bab-95a3-4fb4-b063-4be4679a7a47.png)
![image](https://user-images.githubusercontent.com/88382462/202900038-d3f8f862-561f-49dc-ab6c-f18d80b43447.png)
 ![image](https://user-images.githubusercontent.com/88382462/202900074-2bdac03f-ae4d-49f7-b7f8-56c84d3505f0.png)
![image](https://user-images.githubusercontent.com/88382462/202900513-78ecfe63-b42e-40f3-818e-bdac7df157b8.png)
![image](https://user-images.githubusercontent.com/88382462/202900516-43fc6521-2c63-45b7-a704-7e96d02acfb5.png)
![image](https://user-images.githubusercontent.com/88382462/202901290-f3639bf6-54a1-4ba0-be06-cf003098f28f.png)
## Calendar
 ![image](https://user-images.githubusercontent.com/88382462/202901362-473c798f-a850-4d74-8617-6ffb22119f7b.png)
![image](https://user-images.githubusercontent.com/88382462/202901698-05eabdb5-2053-4593-b96f-cfecbb2134dc.png)
![image](https://user-images.githubusercontent.com/88382462/202902188-746bb30a-6127-47cf-833e-e57464239a08.png)
![image](https://user-images.githubusercontent.com/88382462/202902498-f8ed29ef-4580-4544-a0d2-23f4122327cb.png)
## Jdk8以后时间类
![image](https://user-images.githubusercontent.com/88382462/202902519-75dcc771-1d28-4578-9ec4-fb775e4b553d.png)
### ZoneId 时区
![image](https://user-images.githubusercontent.com/88382462/202902569-9819cbd4-f0b2-4453-b8af-f4d0eb0ae724.png)
![image](https://user-images.githubusercontent.com/88382462/202902578-302921e8-6423-4ea5-99d7-ac0bf4bb246a.png)
![image](https://user-images.githubusercontent.com/88382462/202902982-4d5f9175-d64d-4b6f-8073-cc14e07d3752.png)
### Instant 时间戳
![image](https://user-images.githubusercontent.com/88382462/202903027-4fb5cb6e-66c0-4f73-ae6e-754b30789bfa.png)
![image](https://user-images.githubusercontent.com/88382462/202903553-1250c6e6-9c23-47b4-b283-0c64e30c862a.png)
### ZoneDateTime 带时区的时间
![image](https://user-images.githubusercontent.com/88382462/202903594-5f38298d-d683-44b0-80d3-9fb6a06aac2b.png)
![image](https://user-images.githubusercontent.com/88382462/202903883-a41d9760-b0be-44e0-aed6-1c858f0bc47e.png)
### DateTimeFormatter 用于时间的格式化和解析
![image](https://user-images.githubusercontent.com/88382462/202903984-ba2bc7af-d687-4013-9e74-1b5d574a3083.png)
![image](https://user-images.githubusercontent.com/88382462/202903989-3e048940-bb5c-4da4-a1c7-b5d4c4195b87.png)
## LocalDate LocalTime LocalDateTime
![image](https://user-images.githubusercontent.com/88382462/203062932-e0db39e1-a8a6-4427-882e-1e680379d5cb.png)
![image](https://user-images.githubusercontent.com/88382462/203067139-14949efd-d5d6-48f6-bcc5-cf6cd01afa7a.png)
![image](https://user-images.githubusercontent.com/88382462/203067711-89ac5ade-b35c-46fe-95ee-4c3470e073ce.png)
![image](https://user-images.githubusercontent.com/88382462/203068644-2aa13d94-21f0-4f07-ac95-9c442b85ce00.png)


# 包装类
![image](https://user-images.githubusercontent.com/88382462/203069149-21c93513-2bec-4107-800b-f822cf8b6dff.png)
![image](https://user-images.githubusercontent.com/88382462/203070078-edbcfe8b-290b-40cb-8e0d-8fd1af4dc5c7.png)
![image](https://user-images.githubusercontent.com/88382462/203071231-3a79771a-bcb3-4d58-9818-5ee5c531eb79.png)
![image](https://user-images.githubusercontent.com/88382462/203071418-57ff286a-4e93-4abd-8c42-c81b9eaf6d57.png)
![image](https://user-images.githubusercontent.com/88382462/203071642-4c31716d-0150-4492-b93c-8b215265d65d.png)
## Integer
![image](https://user-images.githubusercontent.com/88382462/203071759-b534efe5-d69a-4228-9d29-dcb017e830f0.png)
![image](https://user-images.githubusercontent.com/88382462/203072800-9f54bcba-f358-44b3-9559-5d758ffdf046.png)
# 键盘录入更规范的写法
![image](https://user-images.githubusercontent.com/88382462/203073493-8a53cfa2-c812-49e8-bf02-6d87fe6b2462.png)

练习
![image](https://user-images.githubusercontent.com/88382462/203094884-4ec17fd0-63d1-4d1c-a735-acfdf5d132ce.png)
![image](https://user-images.githubusercontent.com/88382462/203094789-03a71d43-3914-4aa0-b784-1dc978f9d607.png)

====================================================================================
# 查找
## 基本查找/顺序查找
![image](https://user-images.githubusercontent.com/88382462/203272542-b0860da3-10c5-43ac-ad50-b9d472cd718b.png)
## 二分查找
![image](https://user-images.githubusercontent.com/88382462/203273128-bb9b0a2b-9458-41d2-9c3c-e0efebb7685e.png)
![image](https://user-images.githubusercontent.com/88382462/203274122-60f823c0-6c78-4559-88f2-b6582b676d3e.png)
![image](https://user-images.githubusercontent.com/88382462/203276350-00e33a09-164c-493a-a60e-25e54d4c2746.png)
## 插值查找
![image](https://user-images.githubusercontent.com/88382462/203276840-b9e801c8-4f2d-494d-8dd3-8534ae2faa22.png)
## 斐波那契查找
![image](https://user-images.githubusercontent.com/88382462/203277104-1939a944-e8f1-473d-adb6-974e3f174721.png)
## 二分/插值/斐波那契查找各自的特点
![image](https://user-images.githubusercontent.com/88382462/203277398-33d58c8a-99b1-4cba-a8f4-8b2f239ebf35.png)
## 分块查找
![image](https://user-images.githubusercontent.com/88382462/203277952-d6d1a2f0-7cf6-4751-9f88-97fe985c118d.png)
### 拓展的分块查找
![image](https://user-images.githubusercontent.com/88382462/203280577-960902ae-985e-4029-b315-d099fe1ca836.png)
![image](https://user-images.githubusercontent.com/88382462/203281332-267a683a-8a38-4a0c-8adb-70e68dd0d522.png)
## 七种查找方式
![image](https://user-images.githubusercontent.com/88382462/203281476-6d25d58b-b998-4ac2-9790-82318be9ed3a.png)

# 排序
## 四种排序
![image](https://user-images.githubusercontent.com/88382462/204125316-0fea450a-efc3-4653-a8e1-ea9136c5147a.png)
## 冒泡排序
![image](https://user-images.githubusercontent.com/88382462/204125441-8a380509-07f8-443d-ab95-d3887dd7e1c6.png)
![image](https://user-images.githubusercontent.com/88382462/204125608-b4049365-926b-4e13-9a51-a5c49d96352e.png)
## 选择排序
![image](https://user-images.githubusercontent.com/88382462/204125779-e2556b86-4247-4bc9-8fc0-4b020f5c2b38.png)
## 插入排序
![image](https://user-images.githubusercontent.com/88382462/204126092-bcb803a5-3781-4c06-8893-47b3caa5d02f.png)
## 递归
![image](https://user-images.githubusercontent.com/88382462/204126188-d4d1fec1-a095-48ae-b5b7-27242e6d6d8b.png)
![image](https://user-images.githubusercontent.com/88382462/204126218-9e7b8468-2c80-4b7c-ab00-7ed91274e81b.png)
![image](https://user-images.githubusercontent.com/88382462/204126447-f7c01fee-3ec3-4544-b947-4b0ba751fd68.png)
![image](https://user-images.githubusercontent.com/88382462/204126604-d6f5cd47-d5d5-4380-8040-d22a6180e829.png)
## 快速排序
![image](https://user-images.githubusercontent.com/88382462/204126791-6564be36-508b-4c8e-a5e4-69921f2de601.png)
![image](https://user-images.githubusercontent.com/88382462/204128602-ac11012e-0486-4f81-869e-fcc4d42c4452.png)
## 排序总结
![image](https://user-images.githubusercontent.com/88382462/204128653-c75cf7cf-edb2-4d5c-ba00-fb0ddc33175d.png)

# Arrays
![image](https://user-images.githubusercontent.com/88382462/204129419-2c2990fe-ecd9-434e-a642-0397bbb63549.png)
![image](https://user-images.githubusercontent.com/88382462/212838345-b5df044a-c7f0-4987-8758-0a85a3f40fc4.png)
![image](https://user-images.githubusercontent.com/88382462/212838577-6c0f78ee-a296-485a-95dd-13d66b733cc9.png)
![image](https://user-images.githubusercontent.com/88382462/212840022-05df4f80-1740-40d0-887d-e66a1941d416.png)
![image](https://user-images.githubusercontent.com/88382462/212841260-4843be3b-938d-4066-bae3-195775ba72cc.png)
![image](https://user-images.githubusercontent.com/88382462/212843080-3344b9e5-1e09-4d7d-9b2a-e5ced56a77ef.png)
# Lambda表达式
![image](https://user-images.githubusercontent.com/88382462/212844111-18b06548-a878-471b-87f4-894c2965c257.png)
![image](https://user-images.githubusercontent.com/88382462/212844491-e2585351-7c52-47d4-a41d-72dc36b01929.png)
![image](https://user-images.githubusercontent.com/88382462/212844821-312a043d-cfe7-4e08-9a12-524b2b7691f2.png)
![image](https://user-images.githubusercontent.com/88382462/212846790-87b04796-d288-499d-9b06-24e390d604bf.png)
![image](https://user-images.githubusercontent.com/88382462/212846834-4a9a184a-873d-46ab-a2b5-bab380d2a37f.png)
![image](https://user-images.githubusercontent.com/88382462/212846974-1b2780e0-8f0a-474d-93ff-4eef4da674a3.png)
![image](https://user-images.githubusercontent.com/88382462/212847403-ef1b6ee4-3396-49f6-88d3-48cb08b5b018.png)
![image](https://user-images.githubusercontent.com/88382462/212847886-5f52aa37-6322-499b-aa7b-04c215adf758.png)
![image](https://user-images.githubusercontent.com/88382462/212848511-b143a293-219f-4d98-90b4-d77b1cd86244.png)
![image](https://user-images.githubusercontent.com/88382462/212850833-ec22ddc5-b582-4d90-9875-cc6e1802fbe0.png)

![image](https://user-images.githubusercontent.com/88382462/213338212-f465bea6-6138-4ff0-b4bd-1b97160efe7e.png)

# 集合进阶
![image](https://user-images.githubusercontent.com/88382462/216255773-8767ecee-e2c0-496e-8ae7-8d1f83fb36e9.png)
![image](https://user-images.githubusercontent.com/88382462/216256092-b126e33c-6113-4340-854b-f23a78dd2ae6.png)
## Collection集合
![image](https://user-images.githubusercontent.com/88382462/216256372-243aa9f5-39d4-41b1-bff8-af549627d4af.png)
![image](https://user-images.githubusercontent.com/88382462/216264717-872ce773-53b6-481e-a456-86ef27d1c4fe.png)
![image](https://user-images.githubusercontent.com/88382462/219992068-0b791076-6178-46e2-b2ba-777f776c1ce5.png)
![image](https://user-images.githubusercontent.com/88382462/219992083-1537850c-11dd-44ad-9366-194b265c77ab.png)
### Collection遍历方式
![image](https://user-images.githubusercontent.com/88382462/219992435-020faff8-1778-4115-842f-d817575c7eda.png)
#### 迭代器遍历
![image](https://user-images.githubusercontent.com/88382462/219992689-84aaea5c-50f8-495a-9b38-cf969119d9b4.png)
![image](https://user-images.githubusercontent.com/88382462/219993400-3e620c3e-2fca-4725-ae00-ebc4f17f30f9.png)
![image](https://user-images.githubusercontent.com/88382462/219993565-83b9b82d-d667-4361-a943-22ce3e514c72.png)
![image](https://user-images.githubusercontent.com/88382462/219993693-a31ea552-5484-45d8-b369-967ab5150c29.png)
![image](https://user-images.githubusercontent.com/88382462/219995025-e929098d-7ba4-4f51-80cb-f6737eb51e87.png)
![image](https://user-images.githubusercontent.com/88382462/219995141-8a890ec6-eaad-44fa-90b7-143aff9273c9.png)
![image](https://user-images.githubusercontent.com/88382462/219996316-29f7c66c-4233-4fc8-817f-c2c432454569.png)
![image](https://user-images.githubusercontent.com/88382462/219996961-2bf8b440-148b-4873-ada2-6dbb23acd9c4.png)
![image](https://user-images.githubusercontent.com/88382462/219997025-6f13b13c-f790-4166-8f86-5db02aac3f79.png)

#### 增强for遍历
![image](https://user-images.githubusercontent.com/88382462/219997360-cf27e5a1-6876-4209-9e4d-cd161c82a0d6.png)
![image](https://user-images.githubusercontent.com/88382462/219997562-9924c26f-1836-4550-a22e-b56e1446bf69.png)
![image](https://user-images.githubusercontent.com/88382462/219998454-e59fad6e-18bc-45f2-9ecc-0664acf0fa1c.png)

#### lambda表达式遍历
![image](https://user-images.githubusercontent.com/88382462/219998998-d200c272-aaa1-415b-98c8-a9cd82ef6ea5.png)
![image](https://user-images.githubusercontent.com/88382462/219999476-31d36b56-b155-4010-add3-d2efe674a982.png)
![image](https://user-images.githubusercontent.com/88382462/219999888-9ea24500-925e-48bd-8f9d-b4d43959137d.png)

## list集合
![image](https://user-images.githubusercontent.com/88382462/220021481-4ef87a57-3a2d-47a0-8a80-80ba90cf587e.png)

```
        List系列集合独有的方法：
            void add(int index,E element)       在此集合中的指定位置插入指定的元素
            E remove(int index)                 删除指定索引处的元素，返回被删除的元素
            E set(int index,E element)          修改指定索引处的元素，返回被修改的元素
            E get(int index)                    返回指定索引处的元素
```

```ruby
        //1.创建一个集合(接口多态)
        List<String> list = new ArrayList<>();

        //2.添加元素
        list.add("aaa");
        list.add("bbb");//1
        list.add("ccc");

        list.add(1,"ddd"); 

        //E remove(int index)                 
        // 删除指定索引处的元素，返回被删除的元素
        String remove = list.remove(0);
        System.out.println(remove);//aaa


        //E set(int index,E element)         
        //修改指定索引处的元素，返回被修改的元素
        String result = list.set(0, "QQQ");   //aaa
        System.out.println(result);

        // E get(int index)                   
        //返回指定索引处的元素
        String s = list.get(0);
        System.out.println(s);


        //3.打印集合
        System.out.println(list);
```

list.remove 删除的小细节

```ruby
//List系列集合中的两个删除的方法
        //1.直接删除元素
        //2.通过索引进行删除

        //1.创建集合并添加元素
        List<Integer> list = new ArrayList<>();

        list.add(1);
        list.add(2);
        list.add(3);


        //2.删除元素
        //请问：此时删除的是1这个元素，还是1索引上的元素？
        //为什么？
        //因为在调用方法的时候，如果方法出现了重载现象
        //优先调用，实参跟形参类型一致的那个方法。

        list.remove(1);


        //手动装箱，手动把基本数据类型的1，变成Integer类型
        Integer i = Integer.valueOf(1);

        list.remove(i);

        System.out.println(list);
```

### list集合的5种遍历方式

```
  1.迭代器
  2.列表迭代器
  3.增强for
  4.Lambda表达式
  5.普通for循环
```

1.迭代器

```ruby
 Iterator<String> it = list.iterator();
  while(it.hasNext()){
      String str = it.next();
      System.out.println(str);
  }
        
```

2.增强for

```ruby
 //2.增强for
 //下面的变量s，其实就是一个第三方的变量而已。
 //在循环的过程中，依次表示集合中的每一个元素
 for (String s : list) {
     System.out.println(s);
 }

```

3.lambda表达式

```ruby
 //3.Lambda表达式
 //forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素
 //并把每一个元素传递给下面的accept方法
 //accept方法的形参s，依次表示集合中的每一个元素
 list.forEach(s->System.out.println(s) );

```
4.普通for循环

```ruby
 //4.普通for循环
 //size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素
 for (int i = 0; i < list.size(); i++) {
     //i:依次表示集合中的每一个索引
     String s = list.get(i);
     System.out.println(s);
 }

```

5.列表迭代器

```ruby
 // 5.列表迭代器
 //获取一个列表迭代器的对象，里面的指针默认也是指向0索引的

 //额外添加了一个方法：在遍历的过程中，可以添加元素
 ListIterator<String> it = list.listIterator();
 while(it.hasNext()){
     String str = it.next();
     if("bbb".equals(str)){
         //qqq
         it.add("qqq");
     }
 }
 System.out.println(list);

```

![image](https://user-images.githubusercontent.com/88382462/220029603-96efbf8d-b49b-4974-ac78-47342988b7ea.png)


# 数据结构
![image](https://user-images.githubusercontent.com/88382462/220030693-20573337-597f-4131-bed8-a05af3cd3f1a.png)
![image](https://user-images.githubusercontent.com/88382462/220030845-183ccf5b-9267-4139-8172-f0e05a51830f.png)

## 栈
![image](https://user-images.githubusercontent.com/88382462/220031566-16336ede-14de-4606-bb63-0f60e507b623.png)
![image](https://user-images.githubusercontent.com/88382462/220031700-a1310d5a-eafa-4eab-98e0-f0c598013b8d.png)

## 队列
![image](https://user-images.githubusercontent.com/88382462/220031941-63421719-1488-49ae-b291-c8d88008b9f9.png)

## 数组
![image](https://user-images.githubusercontent.com/88382462/220032502-f43751fa-6224-454a-82c7-996be2313b05.png)

## 链表
![image](https://user-images.githubusercontent.com/88382462/220033617-ca82eb99-5c0e-4a98-b59b-47fae0ce2c42.png)
![image](https://user-images.githubusercontent.com/88382462/220033748-714670e0-3521-4bf9-97fd-94733303eb71.png)
![image](https://user-images.githubusercontent.com/88382462/220033952-4e2de156-0361-4c9d-9872-2aba86982a1a.png)
![image](https://user-images.githubusercontent.com/88382462/220034119-77170c52-3e1e-4e88-b0b5-47a2b67bad49.png)

## 树
![image](https://user-images.githubusercontent.com/88382462/220077681-0adc38c2-a15f-46c3-bb6b-6bea0e51b1ec.png)
![image](https://user-images.githubusercontent.com/88382462/220077745-b0d9cf38-bf54-4bdc-b829-027490b8546d.png)

## 二叉树
![image](https://user-images.githubusercontent.com/88382462/220077871-70d5e10f-8474-4236-956a-ae099f74267d.png)
![image](https://user-images.githubusercontent.com/88382462/220077976-756e4654-5a5b-4b3d-bee3-dd4fd7414232.png)

### 二叉查找树（排序树/搜索树）
![image](https://user-images.githubusercontent.com/88382462/220078162-cd7913eb-c1f1-4675-b930-9f62ef5b8e2e.png)
![image](https://user-images.githubusercontent.com/88382462/220078242-b93266b1-1217-4f09-bb40-4b9f4bc2111f.png)

#### 二叉查找树遍历方式
![image](https://user-images.githubusercontent.com/88382462/220078399-84bb6ff5-e67e-4280-95d1-f5d08753e613.png)
##### 1、前序遍历
![image](https://user-images.githubusercontent.com/88382462/220078578-53edca32-361d-47c0-b44b-5db96da491c3.png)
##### 2、中序遍历
![image](https://user-images.githubusercontent.com/88382462/220078664-01927b26-94f0-47a6-a0f2-29ba418f7800.png)
##### 3、后序遍历
![image](https://user-images.githubusercontent.com/88382462/220078967-4921a529-30f2-47ad-a7cf-81801d567505.png)

##### 4、层序遍历
![image](https://user-images.githubusercontent.com/88382462/220079228-ea6102ae-a273-4cc6-a579-c48f71a3dd0a.png)

![image](https://user-images.githubusercontent.com/88382462/220079280-1bbf7c32-a25d-400c-94b2-69197d116cf6.png)

#### 二叉查找树弊端
![image](https://user-images.githubusercontent.com/88382462/220080659-5e0b85bc-8289-4ebb-9c9c-4551c700a645.png)

### 平衡二叉树
![image](https://user-images.githubusercontent.com/88382462/220081164-ac9b47b2-b06c-4e9a-bafe-aeccd276cce3.png)
![image](https://user-images.githubusercontent.com/88382462/220081346-8424b556-649a-4b43-a1f3-e79cbf2323a3.png)
![image](https://user-images.githubusercontent.com/88382462/220081701-ead02489-5b0a-41fe-a199-91555ba3b47a.png)

#### 平衡二叉树旋转机制
![image](https://user-images.githubusercontent.com/88382462/220082023-19fab3df-bbc4-4272-a7c2-d43558096cbd.png)
![image](https://user-images.githubusercontent.com/88382462/220082481-3cfb93f3-0cbf-47ca-9d66-8d441fef2f4e.png)
![image](https://user-images.githubusercontent.com/88382462/220082692-3d10d1dc-32c7-469a-8f11-57e16d3d1f16.png)
![image](https://user-images.githubusercontent.com/88382462/220083019-f18f2656-1219-47c1-a204-ad40f2f3742d.png)
![image](https://user-images.githubusercontent.com/88382462/220083899-eef0faac-75dd-447a-8e2e-3353d943b40f.png)
![image](https://user-images.githubusercontent.com/88382462/220084067-cdfef676-5899-44df-9a53-d87fd0262aa5.png)

##### 平衡二叉树需要旋转的四种情况
1.左左 - 一次右旋
![image](https://user-images.githubusercontent.com/88382462/220085041-a28807fb-1b8f-4c76-8fa3-90433bd510b2.png)
2.左右-先局部左旋，再整体右旋
![image](https://user-images.githubusercontent.com/88382462/220092710-7063af79-2d44-4512-a728-2261391229c6.png)
![image](https://user-images.githubusercontent.com/88382462/220092811-8592dca1-e9d1-4f50-98c1-2ef720b348e6.png)
3.右右-一次左旋
![image](https://user-images.githubusercontent.com/88382462/220093359-9c282351-204c-4e2b-ba44-5a264e6b2aea.png)
4.右左-先局部右旋，再整体左旋
![image](https://user-images.githubusercontent.com/88382462/220093685-02f7c131-c4a1-4a60-9baa-b33562a501a1.png)
![image](https://user-images.githubusercontent.com/88382462/220093846-31340ca7-a4cb-406d-aa94-5e8234b9d08f.png)

![image](https://user-images.githubusercontent.com/88382462/220093950-07bf92d7-8603-4aa3-b758-591886a7b055.png)
![image](https://user-images.githubusercontent.com/88382462/220093992-f13e770e-b693-4505-8e34-1ee3379825f7

### 红黑树
![image](https://user-images.githubusercontent.com/88382462/220095287-0a6e24a3-80d9-4ea8-9353-5e1d6d7da9a6.png)
![image](https://user-images.githubusercontent.com/88382462/220095732-87425e79-a880-4f76-bc5e-62b4dcc80068.png)
#### 红黑树添加节点的规则
![image](https://user-images.githubusercontent.com/88382462/220097996-294dee22-873d-43b6-b74e-9cafebcdc24e.png)



# LinkedList(list的一种实现类)
以下几种方法不常用
![image](https://user-images.githubusercontent.com/88382462/220034890-e337f11e-aeb4-4e2f-a9f9-7e9e4197b339.png)

# 泛型

## 泛型概述
![image](https://user-images.githubusercontent.com/88382462/220035567-477f2fe9-0972-4331-a11b-8117c199203a.png)

## 没有泛型的时候，集合如何存储数据？
    结论：
    
    如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型
    
    此时可以往集合添加任意的数据类型。
    
    **带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。**
    
    此时推出了泛型，可以在添加数据的时候就把类型进行统一。
    
    而且我们在获取数据的时候，也省的强转了，非常的方便。
    
没有泛型时
```ruby
 //1.创建集合的对象
 ArrayList<String> list = new ArrayList<>();

 //2.添加数据
 list.add(123);
 list.add("aaa");
 list.add(new Student("zhangsan",123));


 //3.遍历集合获取里面的每一个元素
 Iterator<String> it = list.iterator();
 while(it.hasNext()){
     String str = it.next();
     //多态的弊端是不能访问子类的特有功能
     //obj.length();
     //str.length();
     System.out.println(str);
 }
```

## 泛型的好处

1.统一数据类型。

2.把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。

Java里的泛型是伪泛型

## 泛型的细节

1.泛型中不能写基本数据类型

2.指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型

3.如果不写泛型，类型默认是Object

![image](https://user-images.githubusercontent.com/88382462/220038439-d0f7d5d2-35c8-4812-9be1-9c163b700ab8.png)

## 泛型类
![image](https://user-images.githubusercontent.com/88382462/220038644-5e32c8e9-8082-4d31-8366-53952503563a.png)

编写泛型类
```ruby
/*
*       当我在编写一个类的时候，如果不确定类型，那么这个类就可以定义为泛型类。
* */
public class MyArrayList<E> {

    Object[] obj = new Object[10];
    int size;

    /*
    E : 表示是不确定的类型。该类型在类名后面已经定义过了。
    e：形参的名字，变量名
    * */
    public boolean add(E e){
        obj[size] = e;
        size++;
        return true;
    }


    public E get(int index){
        return (E)obj[index];
    }


    @Override
    public String toString() {
        return Arrays.toString(obj);
    }
}

```
对应的实现方法
```ruby
MyArrayList<String> list = new MyArrayList<>();

list.add("aaa");
list.add("bbb");
list.add("ccc");


System.out.println(list);


MyArrayList<Integer> list2 = new MyArrayList<>();
list2.add(123);
list2.add(456);
list2.add(789);


int i = list2.get(0);
System.out.println(i);


System.out.println(list2);
```


## 泛型方法
![image](https://user-images.githubusercontent.com/88382462/220041595-e08bfa9b-b8da-44fe-9383-7d65c55d454e.png)
![image](https://user-images.githubusercontent.com/88382462/220041741-bc760f8d-61d8-4be7-9817-d667e1020726.png)

定义一个工具类：ListUtil
类中定义一个静态方法addAll，用来添加多个集合的元素。

```ruby
public class ListUtil {
    private ListUtil(){}

    //类中定义一个静态方法addAll，用来添加多个集合的元素。


    /*
    *   参数一：集合
    *   参数二~最后：要添加的元素
    *
    * */
    public static<E> void addAll(ArrayList<E> list, E e1,E e2,E e3,E e4){
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
    }

/*    public static<E> void addAll2(ArrayList<E> list, E...e){
        //e为可变参数
        for (E element : e) {
            list.add(element);
        }
    }*/


    public void show(){
        System.out.println("阿玮");
    }
}

```
实现类
```ruby
public class GenericsDemo3 {
    public static void main(String[] args) {

        ArrayList<String> list1 = new ArrayList<>();
        ListUtil.addAll(list1, "aaa", "bbb", "ccc", "ddd");
        System.out.println(list1);


        ArrayList<Integer> list2 = new ArrayList<>();
        ListUtil.addAll(list2,1,2,3,4);
        System.out.println(list2);

    }
}
```

## 泛型接口

![image](https://user-images.githubusercontent.com/88382462/220043693-99882c7d-baa6-4f11-9844-917edc7f0135.png)

泛型接口的两种使用方式：
   1.实现类给出具体的类型
   2.实现类延续泛型，创建实现类对象时再确定类型
   
```ruby
//1.实现类给出具体的类型
public class MyArrayList2 implements List<String> {}
//2.实现类延续泛型，创建实现类对象时再确定类型
public class MyArrayList3<E> implements List<E>{}
```

## 泛型的继承和通配符

**泛型不具备继承性，数据具备继承性**

```ruby
public  static <E> void method(ArrayList<E> list) {

}
```

需求： 定义一个方法，形参是一个集合，但是集合中的数据类型不确定。
 
```ruby
 /*
     * 此时，泛型里面写的是什么类型，那么只能传递什么类型的数据。
     * 弊端：
     *      利用泛型方法有一个小弊端，此时他可以接受任意的数据类型
     *      Ye  Fu   Zi    Student
     *
     * 希望：本方法虽然不确定类型，但是以后我希望只能传递Ye Fu Zi
     *
     * 此时我们就可以使用泛型的通配符：
     *      ?也表示不确定的类型
     *      他可以进行类型的限定
     *      ? extends E: 表示可以传递E或者E所有的子类类型
     *      ? super E:表示可以传递E或者E所有的父类类型
     *
     * 应用场景：
     *      1.如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。
     *      2.如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符
     * 泛型的通配符：
     *      关键点：可以限定类型的范围。
     *
     * */
```

```ruby
public static void method(ArrayList<? super Fu> list) {

}
```

# set
![image](https://user-images.githubusercontent.com/88382462/220497939-72e2b8c5-3436-4f30-baa7-0d42f8a49ae9.png)

```ruby
/*
   利用Set系列的集合，添加字符串，并使用多种方式遍历。
    迭代器
    增强for
    Lambda表达式

*/


//1.创建一个Set集合的对象（接口多态）
Set<String> s = new HashSet<>();

//2,添加元素
//如果当前元素是第一次添加，那么可以添加成功，返回true
//如果当前元素是第二次添加，那么添加失败，返回false
System.out.println(s.add("张三"));    //true
System.out.println(s.add("张三"));    //false
s.add("李四");
s.add("王五");

//3.打印集合
//无序
//System.out.println(s);//[李四, 张三, 王五]

//迭代器遍历
Iterator<String> it = s.iterator();
while (it.hasNext()){
    String str = it.next();
    System.out.println(str);
}


//增强for
 for (String str : s) {
    System.out.println(str);
}

// Lambda表达式
s.forEach( str->System.out.println(str));
```
 
## HashSet
![image](https://user-images.githubusercontent.com/88382462/220499392-81665b21-31f3-448b-80cd-c4cd42f44065.png)

### 哈希值
![image](https://user-images.githubusercontent.com/88382462/220499720-4abae5b3-82dd-4e6c-aa25-75babbb5955c.png)

```ruby
/*
   哈希值：
       对象的整数表现形式
       1. 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
       2. 如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
       3. 但是在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（哈希碰撞）

*/

//1.创建对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("zhangsan",23);

//2.如果没有重写hashCode方法，不同对象计算出的哈希值是不同的
//  如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
System.out.println(s1.hashCode());//-1461067292
System.out.println(s2.hashCode());//-1461067292


//在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。
//哈希碰撞
System.out.println("abc".hashCode());//96354
System.out.println("acD".hashCode());//96354
```

### JDK8以前的HashSet
![image](https://user-images.githubusercontent.com/88382462/220501348-36f12f78-f097-47f9-bdff-ee6db3ff9386.png)
![image](https://user-images.githubusercontent.com/88382462/220501183-2980e9b7-4fc6-457f-ab9b-b018c888a11c.png)

**扩容时机：当数组存了0.75*当前的数组长度时，数组长度加倍 （0.75为加载因子）**

**JDK8以后当链表长度大于等于8且数组长度大于等于64时链表转换为红黑树。**

![image](https://user-images.githubusercontent.com/88382462/220502690-ea1b960f-7900-4f60-af0d-554a40431f82.png)

**重写Equals一定要重写HashCode**

```ruby
/* 需求：创建一个存储学生对象的集合，存储多个学生对象。
            使用程序实现在控制台遍历该集合。
            要求：学生对象的成员变量值相同，我们就认为是同一个对象

*/
  //1.创建三个学生对象
  Student s1 = new Student("zhangsan",23);
  Student s2 = new Student("lisi",24);
  Student s3 = new Student("wangwu",25);
  Student s4 = new Student("zhangsan",23);


  //2.创建集合用来添加学生
  HashSet<Student> hs = new HashSet<>();

  //3.添加元素，重写hashCode和equals方法后true，true，true，false
  System.out.println(hs.add(s1));
  System.out.println(hs.add(s2));
  System.out.println(hs.add(s3));
  System.out.println(hs.add(s4));

  //4.打印集合
  System.out.println(hs);
```

## LinkedHashSet
比HashSet多了一条双向链表用来存顺序
![image](https://user-images.githubusercontent.com/88382462/220504932-f7348ac5-e5d8-4433-95cd-e1cd36b39f61.png)

```ruby
 //1.创建4个学生对象
Student s1 = new Student("zhangsan",23);
Student s2 = new Student("lisi",24);
Student s3 = new Student("wangwu",25);
Student s4 = new Student("zhangsan",23);

//2.创建集合的对象
LinkedHashSet<Student> lhs = new LinkedHashSet<>();

//3.添加元素
System.out.println(lhs.add(s3));    //true
System.out.println(lhs.add(s2));    //true
System.out.println(lhs.add(s1));    //true
System.out.println(lhs.add(s4));    //false

//4.打印集合
System.out.println(lhs); //顺序打印
```

![image](https://user-images.githubusercontent.com/88382462/220505517-879f648c-7d87-41ab-9f4d-e16480a89725.png)

## TreeSet
![image](https://user-images.githubusercontent.com/88382462/220505662-e807d99a-b997-44d8-8e17-c4b891a2918a.png)
### 创建和遍历
```ruby
/*
*
*       需求：利用TreeSet存储整数并进行排序
*
* */

//1.创建TreeSet集合对象
TreeSet<Integer> ts = new TreeSet<>();

//2.添加元素
ts.add(4);
ts.add(5);
ts.add(1);
ts.add(3);
ts.add(2);

//3.打印集合
System.out.println(ts);   //1,2,3,4,5(存入时自动排序，从小到大)

//4.遍历集合（三种遍历）
//迭代器
Iterator<Integer> it = ts.iterator();
while(it.hasNext()){
    int i = it.next();
    System.out.println(i);
}

System.out.println("--------------------------");
//增强for
for (int t : ts) {
    System.out.println(t);
}
System.out.println("--------------------------");
//lambda
ts.forEach( integer -> System.out.println(integer));
```

![image](https://user-images.githubusercontent.com/88382462/220507628-ff46df59-386b-40c5-aff7-fba84b4c1124.png)

### 两种排序规则
#### 1.默认排序/自然排序
```ruby
需求：创建TreeSet集合，并添加3个学生对象
            学生对象属性：
                姓名，年龄。
                要求按照学生的年龄进行排序
                同年龄按照姓名字母排列（暂不考虑中文）
                同姓名，同年龄认为是同一个人

            方式一：
                默认的排序规则/自然排序
                Student实现Comparable接口，重写里面的抽象方法，再指定比较规则
```

**实现Comparable接口，重写里面的抽象方法，再指定比较规则**

**存到TreeSet不用重写hashCode和eauals 因为TreeSet底层没有使用HashSet而是红黑树.**

**如果要往TreeSet存入自定义对象，要重写compareTo来按照自定义规则排序**


```ruby
public class Student implements Comparable<Student>{ //实现Comparable接口，泛型为Student
...
...
 //this：表示当前要添加的元素
    //o：表示已经在红黑树存在的元素

    //返回值：
    //负数：表示当前要添加的元素是小的，存左边
    //正数：表示当前要添加的元素是大的，存右边
    //0 :表示当前要添加的元素已经存在，舍弃
    public int compareTo(Student o) {
        //指定排序的规则
        //只看年龄，我想要按照年龄的升序进行排列
        return this.getAge() - o.getAge();
    }
 }
```

#### 2.比较器排序
```ruby
//o1:表示当前要添加的元素
//o2：表示已经在红黑树存在的元素
//返回值规则跟之前是一样的
TreeSet<String> ts = new TreeSet<>((o1, o2)->{
        // 按照长度排序
        int i = o1.length() - o2.length();
        //如果一样长则按照首字母排序
        i = i == 0 ? o1.compareTo(o2) : i;
        return i;
});
```

```
第一种：默认排序/自然排序
第二种：比较器排序
 默认情况下，用第一种排序方式，如果第一种不能满足当前的需求，采取第二种方式。
```

```ruby
/* 按照总分从高到低输出到控制台
如果总分一样，按照语文成绩排
如果语文一样，按照数学成绩排
如果数学成绩一样，按照英语成绩排
如果英文成绩一样，按照年龄排
如果年龄一样，按照姓名的字母顺序排
如果都一样，认为是同一个学生，不存。*/
@Override
public int compareTo(Student2 o) {
    int sum1 = this.getChinese() + this.getMath() + this.getEnglish();
    int sum2 = o.getChinese() + o.getMath() + o.getEnglish();

    //比较两者的总分
    int i = sum1 - sum2;
    //如果总分一样，就按照语文成绩排序
    i = i == 0 ? this.getChinese() - o.getChinese() : i;
    //如果语文成绩一样，就按照数学成绩排序
    i = i == 0 ? this.getMath() - o.getMath() : i;
    //如果数学成绩一样，按照英语成绩排序（可以省略不写）
    i = i == 0 ? this.getEnglish() - o.getEnglish() : i;
    //如果英文成绩一样，按照年龄排序
    i = i == 0 ? this.getAge() - o.getAge() : i;
    //如果年龄一样，按照姓名的字母顺序排序
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```
### TreeSet总结
```
1. TreeSet集合的特点是怎么样的?
可排序、不重复、无索引
底层基于红黑树实现排序，增删改查性能较好
```
```
2. TreeSet集合自定义排序规则有几种方式?
方式一: Javabean类实现Comparable接口，指定比较规则
方式二∶创建集合时，自定义Comparator比较器对象，指定比较规则
方式一和方式二同时存在时，以方式二为准
```
```
3．方法返回值的特点
负数:表示当前要添加的元素是小的，存左边
正数:表示当前要添加的元素是大的，存右边
0:表示当前要添加的元素已经存在，舍弃
```

## 各种单列集合应用场景

1．如果想要集合中的元素**可重复**

用ArrayList集合，基于数组的。**（用的最多)**

2．如果想要集合中的元素**可重复**，**而且当前的增删操作明显多于查询**

用LinkedList集合，基于链表的。

3．如果想对集合中的元素**去重**

用HashSet集合，基于哈希表的。**（用的最多)**

4．如果想对集合中的元素**去重，而且保证存取顺序**

用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。

5．如果想对集合中的元素进行**排序**

用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。

# 双列集合
![image](https://user-images.githubusercontent.com/88382462/220558939-68c3c1e3-4395-4c45-85b1-6cb66dce0131.png)
## 双列集合特点
①双列集合一次需要存一对数据，分别为键和值键不能重复，值可以重复

③键和值是一一对应的，每一个键只能找到自己对应的值

④键＋值这个整体我们称之为“键值对”或者“键值对对象”，在3ava中叫做“Entry对象”

## Map
![image](https://user-images.githubusercontent.com/88382462/220559398-836fd29a-5fc5-4e9e-8dd0-6e5e8b1b23c8.png)

```ruby
//创建Map对象
Map<String, String> m = new HashMap();
//添加元素
//put方法的细节
//添加/覆盖

//在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null
//在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。
m.put("郭靖", "黄蓉");
m.put("韦小宝", "沐剑屏");
m.put("尹志平", "小龙女");

String value2 = m.put("韦小宝","双儿");
System.out.println(value2);     //沐剑屏

//删除
String result = m.remove("郭靖");
System.out.println(result);     //黄蓉

//判断是否包含
System.out.println(m.containsKey("韦小宝"));
System.out.println(m.containsValue("双儿"));

//集合长度
int size = m.size();

//清空
m.clear();

System.out.println(size);
System.out.println(m);
```

put方法 

在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中，方法返回null 

在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。

### Map的遍历方式

1.键找值

2.键值对

3.Lambda表达式

#### 键找值遍历
**map.keySet()**

```ruby
//创建Map集合
Map<String, String> map = new HashMap();

//添加元素
map.put("尹志平", "小龙女");
map.put("郭靖", "穆念慈");
map.put("欧阳克", "黄蓉");

//通过键找值
//获取所有的键，把这些键放到一个单列集合中
Set<String> keys = map.keySet();
//遍历单列集合，得到每一个键
for (String key : keys) {
    //利用Map中的键获取对应的值 get
    String value = map.get(key);
    System.out.println(key + "=" + value);

}

//迭代器
Iterator<String> it = keys.iterator();
while (it.hasNext()){
    String key = it.next();
    String value = map.get(key);
    System.out.println(key + "=" + value);
}

//Lambda表达式
keys.forEach((String s) -> {
        String value = map.get(s);
        System.out.println(s + "=" + value);
    }
);
```

#### 键值对遍历
**map.entrySet()**

```ruby
//创建Map集合的对象
Map<String, String> map = new HashMap();
//添加元素
map.put("标枪选手", "马超");
map.put("人物挂件", "明世隐");
map.put("御龙骑士", "尹志平");

//通过键值对方式遍历
//通过一个方法获取所有的键值对对象，方法返回一个set集合
Set<Map.Entry<String, String>> entries = map.entrySet();
//遍历entries集合，获取其中所有键值对
for (Map.Entry<String, String> entry : entries) {
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//迭代器
Iterator<Map.Entry<String, String>> it = entries.iterator();
while (it.hasNext()){
    Map.Entry<String, String> entry = it.next();
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

//内部类（可简化Lambda表达式）
entries.forEach(new Consumer<Map.Entry<String, String>>() {
    @Override
    public void accept(Map.Entry<String, String> stringStringEntry) {
        System.out.println(stringStringEntry.getKey()+"="+stringStringEntry.getValue());
    }
});
```

#### Lambda表达式遍历
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```ruby
//利用Lambda表达式遍历
 map.forEach(new BiConsumer<String, String>() {
     @Override
     public void accept(String key, String value) {
         System.out.println(key + "=" + value);
     }
 });
```

利用Lambda简化后

```ruby
map.forEach(( key, value) -> System.out.println(key + "=" + value));
```







底层:
forEach其实就是利用第二种方式进行遍历，依次得到每一个键和值,再调用accept方法

### HashMap
**HashMap的特点**

HashMap是Map里面的一个实现类。

没有额外需要学习的特有方法，直接使用Map里面的方法就可以了

特点都是由键决定的:无序、不重复、无索引

HashMap跟HashSet底层原理是一模一样的，都是哈希表结构

**总结**

1. HashMap底层是哈希表结构的

2．依赖hashCode方法和equals方法保证键的唯一

3．如果键存储的是自定义对象，需要重写hashCode和equals方法 
如果值存储自定义对象，不需要重写hashCode和equals方法


#### HashMap集合案例
需求
某个班级80名学生，现在需要组成秋游活动，班长提供了四个景点依次是(A、B、C、D),每个学生只能选择一个景点，请统计出最终哪个景点想去的人数最多。

```ruby
//先让同学们投票
//定义一个数组储存景点
String[] arr = {"A","B","C","D"};
//利用随机数模拟80个同学的投票，，并把投票存起来
ArrayList<String> list = new ArrayList<>();
Random r = new Random();
for (int i = 0; i < 80; i++) {
    int index = r.nextInt(arr.length);
    list.add(arr[index]);
}

//如果要统计的东西比较多，不方便使用计数器思想
//可以定义Map集合，利用集合进行统计
HashMap<String,Integer> hm = new HashMap<>();
for (String name : list) {
    //判断当前景点在集合中是否存在
    if(hm.containsKey(name)){
        //存在
        //先获取当前景点被投票的次数
        Integer count = hm.get(name);
        count ++;
        //把新的次数添加到集合
        hm.put(name,count);
    }else {
        //不存在
        hm.put(name,1);
    }
}
System.out.println(hm);

//求最大值
int max = 0;
Set<Map.Entry<String, Integer>> entries = hm.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() > max) max = entry.getValue();
}

//判断那个景点最多，打印出来
for (Map.Entry<String, Integer> entry : entries) {
    if(entry.getValue() == max) System.out.println(entry.getKey());
}
```
 
### LinkedHashMap

由键决定:有序、不重复、无索引。

这里的有序指的是保证存储和取出的元素顺序一致

原理∶底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。

```ruby
//创建集合
LinkedHashMap<String , Integer> lhm =new LinkedHashMap<>();
//添加元素
lhm.put("c",789);
lhm.put("b",456);
lhm.put("a",123);
lhm.put("a",111);

System.out.println(lhm);    //{c=789, b=456, a=111}
```

### TreeMap
TreeMap跟TreeSet底层原理一样，都是红黑树结构的。

由键决定特性:不重复、无索引、可排序

可排序:对键进行排序。

注意:默认按照键的从小到大进行排序，也可以自己规定键的排序规则 
 
**代码书写两种排序规则:**

实现Comparable接口，指定比较规则。

创建集合时传递comparator比较器对象，指定比较规则。

```ruby
//降序排列 o2 - o1 ,(默认升序)
 TreeMap<Integer,String> tm = new TreeMap<>((o1, o2) -> o2-o1);
 tm.put(5, "可恰可乐");
 tm.put(4, "雷碧");
 tm.put(3, "九个核桃");
 tm.put(2, "康帅傅");
 tm.put(1, "粤利粤");
 System.out.println(tm); //{5=可恰可乐, 4=雷碧, 3=九个核桃, 2=康帅傅, 1=粤利粤}
```

```ruby
public class Student implements Comparable<Student>
...
...
public int compareTo(Student o) {
    int i = this.getAge() - o.getAge();
    i = i == 0 ? this.getName().compareTo(o.getName()) : i;
    return i;
}
```

TreeMap例程

```ruby
/*
需求:字符串“aababcabcdabcde"
请统计字符串中每一个字符出现的次数，并按照以下格式输出输出结果:
a (5) b (4) c (3) d (2) e (1) */
//定义字符串
String str = "aababcabcdabcde";
//创建TreeMap对象
TreeMap <Character , Integer> tm =new TreeMap<>();
//遍历得到字符串每一个字符
for (int i = 0; i < str.length(); i++) {
    if(tm.containsKey(str.charAt(i))){
        //如果键已存在,值加一
        Integer count = tm.get(str.charAt(i));
        count ++;
        tm.put(str.charAt(i),count);
    }else {
        //键不存在,添加新的键
        tm.put(str.charAt(i),1);
    }
}
//格式化输出(利用Lambda表达式)
tm.forEach((character, integer) -> System.out.print(character+"("+ integer + ")")         
```

# 可变参数
可变参数:一个大胖子,有多少吃多少

1．可变参数本质上就是一个数组

2．作用:在形参中接收多个数据

3．格式:数据类型...参数名称

举例: int...a

4．注意事项:

形参列表中可变参数只能有一个可变参数必须放在形参列表的最后面

```ruby
public static void main(String[] args) {
    //JDK5
    //可变参数
    //方法形参的个数是可以发生变化的，0 1 2 3 ...
    //格式:属性类型...名字
    //int. . .args
    System.out.println(getSum(1, 2, 3, 4, 5, 6, 7));
}

//底层:
//可变参数底层就是一个数组
//只不过不需要我们自己创建了，Java会帮我们创建好
public static int getSum(int ... args){
    int sum = 0;
    for (int arg : args) {
        sum += arg;
    }
    return sum;
}
```

# Collections
java.util.Collections:是集合工具类

作用:Collections不是集合，而是集合的工具类。

Collections常用API
![image](https://user-images.githubusercontent.com/88382462/220858621-3db3b304-c5ca-4be9-b12f-41f0b91f7d5d.png)
![image](https://user-images.githubusercontent.com/88382462/220858751-2fec447e-19a2-494b-9e62-8d7f261ee4f5.png)

**Arraylist排序可以用collection里的sort方法，不需要转成TreeSet**

```ruby
ArrayList<String> list = new ArrayList<>();

//批量添加元素
Collections.addAll(list,"abc","abc","abc","qwer","zxcv");
System.out.println(list);   //[abc, abc, abc, qwer, zxcv]

//shuffle
Collections.shuffle(list);
System.out.println(list);   //[abc, zxcv, qwer, abc, abc]
```

**序号排序法**

如果原始数据的规律非常复杂，我们可以先手动排序让每一个数据跟唯一的序号产生对应关系。

序号就是数字，规律非常简单，后续的所有操作，我们以序号为准

当真正需要操作原始数据时候，再通过序号找到原始数据即可。


# 不可变集合

不可变集合应用场景:

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

## 创建不可变集合书写格式

在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合。

|方法名称	|说明 |
| --- | --- |
|static<E> List<E> of(E...elements) |	创建一个具有指定元素的List集合对象 |
|static<E> Set<E> of(E...elements)	  |创建一个具有指定元素的Set集合对象 |
|static<K , V> Map<K , V> of(E...elements) |	创建一个具有指定元素的Map集合对象 |

注意:这个集合不能添加，不能删除，不能修改。

当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
 
 ```
 创建Map的不可变集合
 细节1：
     键是不能重复的
 细节2：
     Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对
 细节3：
     如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法
     ofEntries(Entry<? extends K, ? extends V>... entries)
 ```

不可变集合创建例程

```ruby
List<String> list = List.of("张三", "李四", "王五", "赵六");
Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");
Map<String, String> map = Map.of("张三", "南京", "张三", "北京", "王五", "上海",
                "赵六", "广州", "孙七", "深圳", "周八", "杭州",
                "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
                "陈二", "嘉兴");
```

如果要存超过10对键值对的不可变map集合

```ruby
//1.创建一个普通的Map集合
HashMap<String, String> hm = new HashMap<>();
hm.put("张三", "南京");
hm.put("李四", "北京");
hm.put("王五", "上海");
hm.put("赵六", "北京");
hm.put("孙七", "深圳");
hm.put("周八", "杭州");
hm.put("吴九", "宁波");
hm.put("郑十", "苏州");
hm.put("刘一", "无锡");
hm.put("陈二", "嘉兴");
hm.put("aaa", "111");

//2.利用上面的数据来获取一个不可变的集合
//获取到所有的键值对对象（Entry对象）
Set<Map.Entry<String, String>> entries = hm.entrySet();
//把entries变成一个数组
Map.Entry[] arr1 = new Map.Entry[0];
//toArray方法在底层会比较集合的长度跟数组的长度两者的大小
//如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组
//如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用
Map.Entry[] arr2 = entries.toArray(arr1);
//不可变的map集合
Map map = Map.ofEntries(arr2);
```

简化写法

```ruby
Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));
//或者:Jdk10以后 copyOf() 生成不可变集合
Map<String, String> map = Map.copyOf(hm);
```

## 不可变集合总结 
1．不可变集合的特点?

定义完成后不可以修改，或者添加、删除

2．如何创建不可变集合?

List、Set.Map接口中，都存在of方法可以创建不可变集合

3.三种方式的细节

List:直接用

Set:元素不能重复

Map:元素不能重复、键值对数量最多是10个。

超过10个用ofEntries方法,如果Jdk版本大于10,可以用copyOf 方法

# Stream流

## Stream作用 
结合了Lambda表达式，简化集合、数组的操作

| 获取方式 |	方法名 |	说明 |
| --- | --- | --- |
| 单列集合 |	default Stream<E> stream()	|collection中的默认方法 | 
| 双列集合 |	无	| 无法直接使用stream流 |
| 数组 |	public static <T> Stream<T> stream(T[] array) |	Arrays工具类中的静态方法 |
| 一堆零散数据 |	public static<T> Stream<T> of(T... values) |	Stream接口中的静态方法 |

## Stream流的使用步骤:

1.先得到一条Stream流（流水线），并把数据放上去

2.使用中间方法对流水线上的数据进行操作

3.使用终结方法对流水线上的数据进行操作

![image](https://user-images.githubusercontent.com/88382462/221397588-4007395f-24af-40e1-9027-2013836f129f.png)

### 单列集合Stream流

```ruby
//1.单列集合获取Stream流
 ArrayList<String> list = new ArrayList<>();
 Collections.addAll(list,"a","b","c","d","e");
 //获取到一条流水线，并把集合中的数据放到流水线上
 Stream<String> stream1 = list.stream();
 //使用终结方法打印一下流水线上的所有数据
 stream1.forEach(new Consumer<String>() {
     @Override
     public void accept(String s) {
         //s:依次表示流水线上的每一个数据
         System.out.println(s);
     }
 });
```

简化写法

```ruby
list.stream().forEach(s -> System.out.println(s));
```

### 双列集合Stream流

获取键或者获取键值对再获取stream流

```ruby
//1.创建双列集合
HashMap<String,Integer> hm = new HashMap<>();
//2.添加数据
hm.put("aaa",111);
hm.put("bbb",222);
hm.put("ccc",333);
hm.put("ddd",444);

//3.第一种获取stream流

hm.keySet().stream().forEach(s -> System.out.println(s));

//4.第二种获取stream流

hm.entrySet().stream().forEach(s-> System.out.println(s));
```

### 集合Stream流
```ruby
// 数组          public static <T> Stream<T> stream(T[] array)        Arrays工具类中的静态方法

//1.创建数组
int[] arr1 = {1,2,3,4,5,6,7,8,9,10};
String[] arr2 = {"a","b","c"};

//2.获取stream流
 Arrays.stream(arr1).forEach(s-> System.out.println(s));
System.out.println("============================");

Arrays.stream(arr2).forEach(s-> System.out.println(s));
```

### 零散数据Stream流
```ruby
//一堆零散数据   public static<T> Stream<T> of(T... values)    Stream接口中的静态方法

Stream.of(1,2,3,4,5).forEach(s-> System.out.println(s));
Stream.of("a","b","c","d","e").forEach(s-> System.out.println(s));
```

注意：

**Stream接口中静态方法of的细节**

方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组

但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。

```ruby
int[] arr1 = {1,2,3,4,5,6,7,8,9,10};
Stream.of(arr1).forEach(s-> System.out.println(s));//[I@41629346
```

## Stream流中间方法

|名称	| 说明 |
| --- | --- |
|Stream<T> filter(Predicate<? super T> predicate)	| 过滤 |
|Stream<T> limit(long maxSize)| 	获取前几个元素 |
|Stream<T> skip(long n) |	跳过前几个元素 |
|Stream<T> distinct()	| 元素去重，依赖(hashCode和equals方法) |
|static<T> Stream<T> concat(Stream a, Stream b)	| 合并a和b两个流为一个流 |
|stream<R> map(Function<T， R> mapper)	| 转换流中的数据类型 | 

**注意1**∶中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程

**注意2**:修改Stream流中的数据，不会影响原来集合或者数组中的数据

### filter 过滤

匿名内部类写法

```ruby
//filter   过滤  把张开头的留下，其余数据过滤不要
list.stream().filter(new Predicate<String>() {
    @Override
    public boolean test(String s) {
        //如果返回值为true，表示当前数据留下
        //如果返回值为false，表示当前数据舍弃不要
        return s.startsWith("张");
    }
}).forEach(s -> System.out.println(s));
```

Lambda表达式写法

```ruby
list.stream()
          .filter(s -> s.startsWith("张"))
          .filter(s -> s.length() == 3)
          .forEach(s -> System.out.println(s));
```

### limit 获取前几个元素 和 skip 跳过前几个元素

```ruby
//"张无忌", "周芷若", "赵敏", "张强", "张三丰", "张翠山", "张良", "王二麻子", "谢广坤"
list.stream().limit(3)
        .forEach(s -> System.out.println(s));   //张无忌 周芷若 赵敏
list.stream().skip(4)
        .forEach(s -> System.out.println(s));   //张三丰 张翠山 张良 王二麻子 谢广坤
```

### distinct 元素去重 和 concat 流合并

distinct  元素去重，依赖(hashCode和equals方法)

 concat   合并a和b两个流为一个流

```ruby
// distinct            元素去重，依赖(hashCode和equals方法)
list1.stream().distinct().forEach(s -> System.out.println(s));

// concat   合并a和b两个流为一个流
Stream.concat(list1.stream(),list2.stream()).forEach(s -> System.out.println(s));
```

### map 转换流中的数据类型

```ruby
/*
    map                 转换流中的数据类型

    注意1：中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程
    注意2：修改Stream流中的数据，不会影响原来集合或者数组中的数据
*/

ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张无忌-15", "周芷若-14", "赵敏-13", "张强-20", "张三丰-100", "张翠山-40", "张良-35", "王二麻子-37", "谢广坤-41");
//需求：只获取里面的年龄并进行打印
//String->int

//第一个类型：流中原本的数据类型
//第二个类型：要转成之后的类型

//apply的形参s：依次表示流里面的每一个数据
//返回值：表示转换之后的数据

//当map方法执行完毕之后，流上的数据就变成了整数
//所以在下面forEach当中，s依次表示流里面的每一个数据，这个数据现在就是整数了
list.stream().map(new Function<String, Integer>() {
    @Override
    public Integer apply(String s) {
        String[] arr = s.split("-");    //把字符串按"-"切割,返回数组
        String ageString = arr[1];
        int age = Integer.parseInt(ageString);
        return age;
    }
}).forEach(s-> System.out.println(s));

System.out.println("------------------------");

```

使用Lambda表达式

```ruby

list.stream()
        .map(s-> Integer.parseInt(s.split("-")[1]))
        .forEach(s-> System.out.println(s));
}
```

## Stream流 终结方法

|名称	| 说明 |
| --- | --- |
|void forEach(Consumer action) |	遍历 |
|long count()	| 统计 |
|toArray()	| 收集流中的数据，放到数组中 |
|collect(Collector collector) |	收集流中的数据，放到集合中 |

### forEach 遍历 count 统计 toArray 收集流中的数据，放到数组中

```ruby
//void forEach(Consumer action)           遍历

//Consumer的泛型：表示流中数据的类型
//accept方法的形参s：依次表示流里面的每一个数据
//方法体：对每一个数据的处理操作（打印）
list.stream().forEach(new Consumer<String>() {
    @Override
    public void accept(String s) {
        System.out.println(s);
    }
});

list.stream().forEach(s -> System.out.println(s));
```

```ruby
 // long count()                            统计
 long count = list.stream().count();
 System.out.println(count);
```

```ruby
// toArray()                               收集流中的数据，放到数组中
Object[] arr1 = list.stream().toArray();
System.out.println(Arrays.toString(arr1));
```

```ruby
//IntFunction的泛型：具体类型的数组
//apply的形参:流中数据的个数，要跟数组的长度保持一致
//apply的返回值：具体类型的数组
//方法体：就是创建数组

//toArray方法的参数的作用：负责创建一个指定类型的数组
//toArray方法的底层，会依次得到流里面的每一个数据，并把数据放到数组当中
//toArray方法的返回值：是一个装着流里面所有数据的数组
String[] arr = list.stream().toArray(new IntFunction<String[]>() {
    @Override
    public String[] apply(int value) {
        return new String[value];
    }
});

System.out.println(Arrays.toString(arr));
```

Lambda表达式写法

```ruby
 String[] arr2 = list.stream().toArray(value -> new String[value]);
 System.out.println(Arrays.toString(arr2));
```

### collect 收集流中的数据，放到集合中 (List Set Map)

收集到List集合和Set集合中

```ruby
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list, "张无忌-男-15", "周芷若-女-14", "赵敏-女-13", "张强-男-20",
        "张三丰-男-100", "张翠山-男-40", "张良-男-35", "王二麻子-男-37", "谢广坤-男-41");

//收集List集合当中
//需求：
//我要把所有的男性收集起来
List<String> newList1 = list.stream()
        .filter(s -> "男".equals(s.split("-")[1]))
        .collect(Collectors.toList());
System.out.println(newList1);

//收集Set集合当中
//需求：
//我要把所有的男性收集起来
Set<String> newList2 = list.stream().filter(s -> "男".equals(s.split("-")[1]))
        .collect(Collectors.toSet());
System.out.println(newList2);
```

**收集到Map集合中(注意键和值和参数)**

注意点：

    如果我们要收集到Map集合当中，键不能重复，否则会报错

```ruby
//收集Map集合当中
//谁作为键,谁作为值.
//我要把所有的男性收集起来
//键：姓名。 值：年龄
Map<String, Integer> map = list.stream()
        .filter(s -> "男".equals(s.split("-")[1]))
        /*
         *   toMap : 参数一表示键的生成规则
         *           参数二表示值的生成规则
         *
         * 参数一：
         *       Function泛型一：表示流中每一个数据的类型
         *               泛型二：表示Map集合中键的数据类型
         *
         *        方法apply形参：依次表示流里面的每一个数据
         *               方法体：生成键的代码
         *               返回值：已经生成的键
         *
         *
         * 参数二：
         *        Function泛型一：表示流中每一个数据的类型
         *                泛型二：表示Map集合中值的数据类型
         *
         *       方法apply形参：依次表示流里面的每一个数据
         *               方法体：生成值的代码
         *               返回值：已经生成的值
         *
         * */
        .collect(Collectors.toMap(new Function<String, String>() {
                                      @Override
                                      public String apply(String s) {
                                          //张无忌-男-15
                                          return s.split("-")[0];
                                      }
                                  },
                new Function<String, Integer>() {
                    @Override
                    public Integer apply(String s) {
                        return Integer.parseInt(s.split("-")[2]);
                    }
                }));
```

收集到Map集合的Lambda表达式

```ruby
 Map<String, Integer> map2 = list.stream()
         .filter(s -> "男".equals(s.split("-")[1]))
         .collect(Collectors.toMap(
                 s -> s.split("-")[0],
                 s -> Integer.parseInt(s.split("-")[2])));
```

## Stream流总结

**1. Stream流的作用**

结合了Lambda表达式，简化集合、数组的操作

**2. Stream的使用步骤**

获取Stream流对象使用中间方法处理数据使用终结方法处理数据

**3．如何获取Stream流对象**

单列集合:Collection中的默认方法

stream双列集合:不能直接获取

数组:Arrays工具类型中的静态方法stream一堆零散的数据:Stream接口中的静态方法of

**4．常见方法**

中间方法:
filter，limit，skip，distinct,concat,map

终结方法:
forEach, count,collect

## 练习

```ruby
现在有两个ArrayList集合，
第一个集合中∶存储6名男演员的名字和年龄。第二个集合中:存储6名女演员的名字和年龄。姓名和年龄中间用逗号隔开。比如:张三,23
要求完成如下的操作:
1，男演员只要名字为3个字的前两人2，女演员只要姓杨的，并且不要第一个
3，把过滤后的男演员姓名和女演员姓名合并到一起4，将上一步的演员信息封装成Actor对象。
5，将所有的演员对象都保存到List集合中。备注:演员类Actor，属性有:name,age
```

```ruby
//创建集合并添加元素
ArrayList<String> maleActorList = new ArrayList<>();
ArrayList<String> femaleActorList = new ArrayList<>();
Collections.addAll(maleActorList, "蔡坤坤,24", "叶齁咸,23", "刘不甜,22", "吴签,24", "谷嘉,30", "肖梁梁,27");
Collections.addAll(femaleActorList, "赵小颖,35", "杨颖,36", "高元元,43", "张天天,31", "刘诗,35", "杨小幂,33");
//分别对两个集合进行流处理,得到两个流
Stream<String> maleStream = maleActorList.stream()
        .filter(s -> s.split(",")[0].length() == 3)
        .limit(2);
Stream<String> femaleStream = femaleActorList.stream()
        .filter(s -> s.split(",")[0].startsWith("杨"))
        .skip(1);
//使用concat进行流合并再用map把流转换成actor,最后打包成list
List<Actor> actorList =
        Stream.concat(maleStream, femaleStream)
        .map(s -> new Actor(s.split(",")[0], Integer.parseInt(s.split(",")[1])))
                .collect(Collectors.toList());

System.out.println(actorList);
```

# 方法引用

把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体

原来的写法:

```ruby
Arrays.sort(arr, new Comparator<Integer>() {
@Override
public int compare(Integer o1, Integer o2) {
    return o2 - o1;
}
```

可以用Lambda简化:

```ruby
Arrays.sort(arr, (o1, o2)->o2 - o1 );
```

方法引用:

```ruby
//表示引用FunctionDemo1类里面的subtraction方法
//把这个方法当做抽象方法的方法体
Arrays.sort(arr, FunctionDemo1::subtraction);

public static int subtraction(int num1, int num2) {
        return num2 - num1;
    }
```
"::" 是方法引用符

**方法引用细节:**

1.引用处需要是函数式接口

2.被引用的方法需要已经存在

3.被引用方法的形参和返回值需要跟抽象方法的形参和返回值保持一致

4.被引用方法的功能需要满足当前的要求

## 方法引用的分类

1.引用静态方法

2.引用成员方法

```ruby
1.引用其他类的成员方法
2.引用本类的成员方法
3.引用父类的成员方法
```

3.引用构造方法

4.其它调用方式

```ruby
1.使用类名引用成员方法
2.引用数组的构造方法
```

### 引用静态方法

格式:类名::静态方法

范例:Integer : : parseInt

```ruby
需求：
   集合中有以下数字，要求把他们都变成int类型
   "1","2","3","4","5"
*/
//1.创建集合并添加元素
ArrayList<String> list = new ArrayList<>();
Collections.addAll(list,"1","2","3","4","5");

//2.把他们都变成int类型
list.stream().map(new Function<String, Integer>() {
   @Override
   public Integer apply(String s) {
       int i = Integer.parseInt(s);
       return i;
   }
}).forEach(s -> System.out.println(s));
```

方法引用:

```ruby
list.stream()
        .map(Integer::parseInt)
        .forEach(s-> System.out.println(s));
```

### 引用成员方法

格式:对象::成员方法

其他类: 其他类对象::方法名

本类: this::方法名(引用处不能是静态方法)

父类: super::方法名(引用处不能是静态方法)

```ruby
StringOperation so = new StringOperation();
list.stream().filter(so::stringJudge)
        .forEach(s-> System.out.println(s));
```

```ruby
public class StringOperation {
    public boolean stringJudge(String s){
        return s.startsWith("张") && s.length() == 3;
    }
}
```

如果方法写在本类,不能直接用this :: 方法名()调用

因为静态方法(main方法)是没有this的
```ruby
静态方法没有this是因为静态方法是属于类而不是属于对象的。在Java和其他一些面向对象编程语言中，类是一个模板，用于创建具有相似属性和方法的对象。当创建对象时，会使用该类的构造函数来初始化对象的属性，并为该对象分配内存。因此，对象是类的一个实例，每个对象都有自己的状态和行为。

与此不同的是，静态方法是直接属于类本身的，而不是属于类的每个对象。这意味着在静态方法中，您不能使用this关键字来引用对象的实例变量或方法。相反，您只能访问静态变量和其他静态方法，因为它们属于类本身，而不是属于对象。

因此，当您需要访问类级别的变量或执行类级别的操作时，可以使用静态方法。而当您需要访问对象级别的变量或执行对象级别的操作时，则需要使用实例方法，并使用this关键字引用当前对象的实例变量或方法。
```

可以创建本类对象再调用:

```ruby
list.stream().filter(new FunctionDemo3()::stringJudge)
            .forEach(s-> System.out.println(s));

```

### 引用构造方法

格式:类名 :: new

范例:student :: new

```ruby
//需求：
//     集合里面存储姓名和年龄，要求封装成Student对象并收集到List集合中
List<Student> newList = list.stream().map(new Function<String, Student>() {
    @Override
    public Student apply(String s) {
        String[] arr = s.split(",");
        String name = arr[0];
        int age = Integer.parseInt(arr[1]);
        return new Student(name, age);
    }
}).collect(Collectors.toList());

```

```ruby
List<Student> newList2 = list.stream().map(Student::new).collect(Collectors.toList());

//下面是重载的构造方法,没有返回值,Student::new引用时返回该对象
public Student(String str) {
    String[] arr = str.split(",");
    this.name = arr[0];
    this.age = Integer.parseInt(arr[1]);
}
```

### 其它调用方式

**使用类名引用成员方法**

格式:类名::成员方法

范例:string : : substring

```ruby
/*
方法引用（类名引用成员方法）
格式
        类名::成员方法
需求：
     集合里面一些字符串，要求变成大写后进行输出

抽象方法形参的详解：
第一个参数：表示被引用方法的调用者，决定了可以引用哪些类中的方法
            在Stream流当中，第一个参数一般都表示流里面的每一个数据。
            假设流里面的数据是字符串，那么使用这种方式进行方法引用，只能引用String这个类中的方法

第二个参数到最后一个参数：跟被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法

局限性：
    不能引用所有类中的成员方法。
    是跟抽象方法的第一个参数有关，这个参数是什么类型的，那么就只能引用这个类中的方法。

*/

//1.创建集合对象
ArrayList<String> list = new ArrayList<>();
//2.添加数据
Collections.addAll(list, "aaa", "bbb", "ccc", "ddd");
//3.变成大写后进行输出
//map(String::toUpperCase)
//拿着流里面的每一个数据，去调用String类中的toUpperCase方法，方法的返回值就是转换之后的结果。
list.stream().map(String::toUpperCase).forEach(s -> System.out.println(s));

```

引用数组的构造方法

```ruby
格式:数据类型[] :: new
范例: int[]  :: new
```

# 异常

![image](https://user-images.githubusercontent.com/88382462/221524168-252df432-9151-42f8-b44f-10d16a555a1f.png)

**Error:代表的系统级别错误（属于严重问题)**

系统一旦出现问题，sun公司会把这些错误封装成Error对象。Error是给sun公司自己用的，不是给我们程序员用的。

因此我们开发人员不用管它。

**Exception:叫做异常，代表程序可能出现的问题。**

我们通常会用Exception以及他的子类来封装程序出现的问题。

运行时异常:RuntimeException及其子类，编译阶段不会出现异常提醒。运行时出现的异常（如:数组索引越界异常)

编译时异常:编译阶段就会出现异常提醒的。（如:日期解析异常)

1．异常是什么?

程序中可能出现的问题

2．异常体系的最上层父类是谁?异常分为几类?

父类:Exception

异常分为两类∶编译时异常、运行时异常

3．编译时异常和运行时异常的区别?

**编译时异常**:没有继承RuntimeExcpetion的异常，直接继承于Excpetion。编译阶段就会错误提示

**运行时异常**:RuntimeException本身和子类。编译阶段没有错误提示，运行时出现的

```ruby
//编译时异常(在编译阶段，必须要手动处理，否则代码报错)
String time = "2030年1月1日";
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");
Date date = sdf.parse(time);  //需要在方法后加上throws ParseException 
System.out.println(date);

//运行时异常（在编译阶段是不需要处理的，是代码运行时出现的异常）
int[] arr = {1,2,3,4,5};
System.out.println(arr[10]);//ArrayIndexOutOfBoundsException

```

![image](https://user-images.githubusercontent.com/88382462/221530518-370ccedf-e232-4e64-8e91-481b8bdf48ab.png)

## 异常的作用

作用一:异常是用来查询bug的关键参考信息

作用二:异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况

## 异常的处理方式

### 1.JVM默认的处理方式

把异常的名称，异常原因及异常出现的位置等信息输出在了控制台

程序停止执行，下面的代码不会再执行了

### 2.自己处理(捕获异常)

格式:

```ruby
try {
   可能出现异常的代码;
} catch(异常类名 变量名) {
   异常的处理代码;
}
```

例程

```ruby
int[] arr = {1, 2, 3, 4, 5, 6};
try{
    //可能出现异常的代码;
    System.out.println(arr[10]);//此处出现了异常，程序就会在这里创建一个ArrayIndexOutOfBoundsException对象
                                //new ArrayIndexOutOfBoundsException();
                                //拿着这个对象到catch的小括号中对比，看括号中的变量是否可以接收这个对象
                                //如果能被接收，就表示该异常就被捕获（抓住），执行catch里面对应的代码
                                //当catch里面所有的代码执行完毕，继续执行try...catch体系下面的其他代码
}catch(ArrayIndexOutOfBoundsException e){
    //如果出现了ArrayIndexOutOfBoundsException异常，我该如何处理
    System.out.println("索引越界了");
}

System.out.println("看看我执行了吗？");  //执行了
```

#### 自己处理（灵魂四问)

**灵魂一问:如果try中没有遇到问题，怎么执行?**

会把try里面所有的代码全部执行完毕，不会执行catch里面的代码

注意：
只有当出现了异常才会执行catch里面的代码


**灵魂二问:如果try中可能会遇到多个问题，怎么执行?**

 会写多个catch与之对应

 细节：
     如果我们要捕获多个异常，这些异常中如果存在父子关系的话，那么父类一定要写在下面

 了解性：
     在JDK7之后，我们可以在catch中同时捕获多个异常，中间用|进行隔开
     表示如果出现了A异常或者B异常的话，采取同一种处理方案

```ruby
 //JDK7
 int[] arr = {1, 2, 3, 4, 5, 6};

 try{
     System.out.println(arr[10]);//ArrayIndexOutOfBoundsException
     System.out.println(2/0);//ArithmeticException
     String s = null;
     System.out.println(s.equals("abc"));
 }catch (ArrayIndexOutOfBoundsException | ArithmeticException e){
     System.out.println("数组越界或者空指针异常");
 }catch (NullPointerException e){
     System.out.println("空指针异常");
 }
```


**灵魂三问:如果try中遇到的问题没有被捕获，怎么执行?**

如果try中遇到的问题没有被捕获，怎么执行？

相当于try...catch的代码白写了，最终还是会交给虚拟机进行处理。


**灵魂四问:如果try中遇到了问题，那么try下面的其他代码还会执行吗?**

下面的代码就不会执行了，直接跳转到对应的catch当中，执行catch里面的语句体

但是如果没有对应catch与之匹配，那么还是会交给虚拟机进行处理

Throwable 成员方法

| 方法名称 |	说明 |
| --- | --- |
| public string getMessage() |	返回此 throwable的详细消息字符串 |
| public string tostring() |	返回此可抛出的简短描述 |
| public voidprintstackTrace() |	把异常的错误信息输出在控制台 |

```ruby
try {
    System.out.println(arr[10]);
} catch (ArrayIndexOutOfBoundsException e) {
    String message = e.getMessage();
    System.out.println(message);//Index 10 out of bounds for length 6

    String str = e.toString();
    System.out.println(str);//java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 6

    e.printStackTrace();

}
System.out.println("看看我执行了吗？");
```


### 3.抛出异常

Throw 和 Throws

![image](https://user-images.githubusercontent.com/88382462/221766057-30a8592c-9ad0-4259-bfa3-770d1e3d2623.png)

```ruby
 public static void main(String[] args) {
/*
     throws：写在方法定义处，表示声明一个异常。告诉调用者，使用本方法可能会有哪些异常。
     throw ：写在方法内，结束方法。手动抛出异常对象，交给调用者。方法中下面的代码不再执行了。

     需求：
         定义一个方法求数组的最大值
*/

     int[] arr = {};
     int max = 0;
     try {
         max = getMax(arr);
     } catch (NullPointerException e) {
         System.out.println("空指针异常");
     } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("索引越界异常");
     }

     System.out.println(max);

 }

 public static int getMax(int[] arr)/* throws NullPointerException,ArrayIndexOutOfBoundsException*/{
     if(arr == null){
         //手动创建一个异常对象，并把这个异常交给方法的调用者处理
         //此时方法就会结束，下面的代码不会再执行了
        throw new NullPointerException();
     }

     if(arr.length == 0){
         //手动创建一个异常对象，并把这个异常交给方法的调用者处理
         //此时方法就会结束，下面的代码不会再执行了
         throw new ArrayIndexOutOfBoundsException();
     }

     System.out.println("看看我执行了吗？");
     int max = arr[0];
     for (int i = 1; i < arr.length; i++) {
         if(arr[i] > max){
             max = arr[i];
         }
     }
     return max;
 }
```

1．虚拟机默认处理异常的方式

把异常信息以红色字体打印在控制台，并结束程序

2．捕获: try...catch

一般用在调用处，能让代码继续往下运行。

3．抛出: throw throws

在方法中，出现异常了。方法就没有继续运行下去的意义了，采取抛出处理。
让该方法结束运行并告诉调用者出现了问题。

```ruby
public void setName(String name)  {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new RuntimeException();
    }
    this.name = name;
}
```

```ruby
/*
    需求：
        键盘录入自己心仪的女朋友姓名和年龄。
        姓名的长度在 3 - 10之间，
        年龄的范围为 18 - 40岁,
        超出这个范围是异常数据不能赋值，需要重新录入,一直录到正确为止。
    提示：
        需要考虑用户在键盘录入时的所有情况。
        比如：录入年龄时超出范围，录入年龄时录入了abc等情况
*/


//1.创建键盘录入的对象
Scanner sc = new Scanner(System.in);
//2.创建女朋友的对象
GirlFriend gf = new GirlFriend();
while (true) {
    //3.接收女朋友的姓名
    try {
        System.out.println("请输入你心仪的女朋友的名字");
        String name = sc.nextLine();
        gf.setName(name);
        //4.接收女朋友的年龄
        System.out.println("请输入你心仪的女朋友的年龄");
        String ageStr = sc.nextLine();
        int age = Integer.parseInt(ageStr);
        gf.setAge(age);
        //如果所有的数据都是正确的，那么跳出循环
        break;
    } catch (NumberFormatException e) {
        System.out.println("年龄的格式有误，请输入数字");
        //continue;
    } catch (RuntimeException e) {
        System.out.println("姓名的长度或者年龄的范围有误");
        //continue;
    }
}
//5.打印
System.out.println(gf);
```

```ruby
public void setAge(int age) {
    if(age < 18 || age > 40){
        throw new RuntimeException();
    }
    this.age = age;
}
public void setName(String name)  {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new RuntimeException();
    }
    this.name = name;
}
```

### 自定义异常

意义:就是为了让控制台的报错信息更加的见名知意

**写自定义异常步骤**

1.定义异常类

2.写继承关系

3.空参构造

4.带参构造

异常类:

```ruby
public class NameFormatException extends RuntimeException{
    //技巧：
    //NameFormat：当前异常的名字，表示姓名格式化问题
    //Exception：表示当前类是一个异常类

    // 继承:
    //运行时：RuntimeException 核心 就表示由于参数错误而导致的问题
    //编译时：Exception 核心 提醒程序员检查本地信息


    public NameFormatException() {
    }

    public NameFormatException(String message) {
        super(message);
    }
}

public class AgeOutOfBoundsException extends RuntimeException{

    public AgeOutOfBoundsException() {
    }

    public AgeOutOfBoundsException(String message) {
        super(message);
    }
}
```

调用:

```ruby
public void setName(String name) {
    int len = name.length();
    if(len < 3 || len > 10){
        throw new NameFormatException(name + "格式有误，长度应该为：3~10");
    }
    this.name = name;
}

public void setAge(int age) {
    if(age < 18 || age > 40){
       throw new AgeOutOfBoundsException(age + "超出了范围");
    }
    this.age = age;
}

catch (NumberFormatException e) {
    e.printStackTrace();
} catch (NameFormatException e) {
    e.printStackTrace();
}catch (AgeOutOfBoundsException e) {
    e.printStackTrace();
}
```

# File

File对象就表示一个路径，可以是文件的路径、也可以是文件夹的路径

这个路径可以是存在的，也允许是不存在的

## File构造方法:

|方法名称 |	说明 |
|---|---|
|public File(string pathname) |	根据文件路径创建文件对象 |
|public File(string parent，string child) |	根据父路径名字符串和子路径名字符串创建文件对象 |
|public File(File parent，string child) |	根据父路径对应文件对象和子路径名字符串创建文件对象 |

```ruby
//1.根据字符串表示的路径，变成File对象
String str = "C:\\Users\\tql\\Desktop\\a.txt";
File f1 = new File(str);
System.out.println(f1);//C:\Users\tql\Desktop\a.txt

//2.父级路径：C:\Users\tql\Desktop
//子级路径：a.txt
String parent = "C:\\Users\\tql\\Desktop";
String child = "a.txt";
File f2 = new File(parent,child);
System.out.println(f2);//C:\Users\tql\Desktop\a.txt

File f3 = new File(parent + "\\" + child);
System.out.println(f3);//C:\Users\tql\Desktop\a.txt

//3.把一个File表示的路径和String表示路径进行拼接
File parent2 = new File("C:\\Users\\tql\\Desktop");
String child2 = "a.txt";
File f4 = new File(parent2,child2);
System.out.println(f4);//C:\Users\tql\Desktop\a.txt
```

## File成员方法

### 判断/获取

| 方法名称 |	说明 |
|---|---|
| public boolean isDirectory() |	判断此路径名表示的File是否为文件夹 |
| public boolean isFile() |	判断此路径名表示的File是否为文件 |
| public boolean exists() |	判断此路径名表示的File是否存在 |
| public long length() |	返回文件的大小（字节数量)|
| public string getAbsolutePath() |	返回文件的绝对路径|
| public string getPath() |	返回定义文件时使用的路径|
| public string getName() |	返回文件的名称，带后缀|
| public long lastModified() |	返回文件的最后修改时间（时间毫秒值)|

```ruby
//对一个文件的路径进行判断
File f1 = new File("D:\\aaa\\a.txt");
System.out.println(f1.isDirectory());//false
System.out.println(f1.isFile());//true
System.out.println(f1.exists());//true
```

```ruby
//1.length  返回文件的大小（字节数量）
//细节1：这个方法只能获取文件的大小，单位是字节
//如果单位我们要是M，G，可以不断的除以1024
//细节2：这个方法无法获取文件夹的大小
//如果我们要获取一个文件夹的大小，需要把这个文件夹里面所有的文件大小都累加在一起。

File f1 = new File("D:\\aaa\\a.txt");
long len = f1.length();
System.out.println(len);//3

File f2 = new File("D:\\aaa\\bbb");
long len2 = f2.length();
System.out.println(len2);//0

//2.getAbsolutePath 返回文件的绝对路径
File f3 = new File("D:\\aaa\\a.txt");
String path1 = f3.getAbsolutePath();
System.out.println(path1);

File f4 = new File("myFile\\a.txt");
String path2 = f4.getAbsolutePath();
System.out.println(path2);  //C:\Users\tql\IdeaProjects\basic-code\myFile\a.txt

//3.getPath 返回定义文件时使用的路径
File f5 = new File("D:\\aaa\\a.txt");
String path3 = f5.getPath();
System.out.println(path3);//D:\aaa\a.txt

File f6 = new File("myFile\\a.txt");
String path4 = f6.getPath();
System.out.println(path4);//myFile\a.txt

//4.getName 获取名字
//细节1：
//a.txt:
//      a 文件名
//      txt 后缀名、扩展名
//细节2：
//文件夹：返回的就是文件夹的名字
File f7 = new File("D:\\aaa\\a.txt");
String name1 = f7.getName();
System.out.println(name1);


File f8 = new File("D:\\aaa\\bbb");
String name2 = f8.getName();
System.out.println(name2);//bbb

//5.lastModified  返回文件的最后修改时间（时间毫秒值）
File f9 = new File("D:\\aaa\\a.txt");
long time = f9.lastModified();
System.out.println(time);//1667380952425

//如何把时间的毫秒值变成字符串表示的时间呢？
//课堂练习：
//yyyy年MM月dd日 HH：mm：ss
Date date = new Date(time);
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
System.out.println(sdf.format(date));

```

### 创建/删除

|方法名称|	说明|
|---|---|
|public boolean createNewFile()	|创建一个新的空的文件|
|public boolean mkdir()|	创建单级文件夹|
|public boolean mkdirs()	|创建多级文件夹|
|public boolean delete()	|删除文件、空文件夹|

**delete方法默认只能删除文件和空文件夹，delete方法直接删除不走回收站**

```ruby
//1.createNewFile 创建一个新的空的文件
//细节1：如果当前路径表示的文件是不存在的，则创建成功，方法返回true
//      如果当前路径表示的文件是存在的，则创建失败，方法返回false
//细节2：如果父级路径是不存在的，那么方法会有异常IOException
//细节3：createNewFile方法创建的一定是文件，如果路径中不包含后缀名，则创建一个没有后缀的文件
File f1 = new File("D:\\aaa\\ddd");
boolean b1 = f1.createNewFile();
System.out.println(b1);//true


//2.mkdir   make Directory，文件夹（目录）
//细节1：windows当中路径是唯一的，如果当前路径已经存在，则创建失败，返回false
//细节2：mkdir方法只能创建单级文件夹，无法创建多级文件夹。
File f2 = new File("D:\\aaa\\aaa\\bbb\\ccc");
boolean b2 = f2.mkdir();
System.out.println(b2);

//3.mkdirs   创建多级文件夹
//细节：既可以创建单级的，又可以创建多级的文件夹
File f3 = new File("D:\\aaa\\ggg");
boolean b3 = f3.mkdirs();
System.out.println(b3);//true
```

```ruby
/*
  public boolean delete()             删除文件、空文件夹
  细节：
      如果删除的是文件，则直接删除，不走回收站。
      如果删除的是空文件夹，则直接删除，不走回收站
      如果删除的是有内容的文件夹，则删除失败
*/


  //1.创建File对象
  File f1 = new File("D:\\aaa\\eee");
  //2.删除
  boolean b = f1.delete();
  System.out.println(b);
```

### 获取/遍历

|方法名称|	说明 |
|---|---|
|public static File[] listRoots()                |列出可用的文件系统根|
|public String[] list()                          |获取当前该路径下所有内容|
|public String[] list(FilenameFilter filter)     |利用文件名过滤器获取当前该路径下所有内容|
|（掌握）public File[] listFiles()               |获取当前该路径下所有内容|
|public File[] listFiles(FileFilter filter)      |利用文件名过滤器获取当前该路径下所有内容|
|public File[] listFiles(FilenameFilter filter)  |利用文件名过滤器获取当前该路径下所有内容|


public File[] listFiles()       获取当前该路径下所有内容

当调用者File表示的路径不存在时，返回null当调用者File表示的路径是文件时，返回null

当调用者File表示的路径是一个空文件夹时，返回一个长度为0的数组

当调用者File表示的路径是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回

当调用者File表示的路径是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件夹

调用者File表示的路径是需要权限才能访问的文件夹时，返回null

```ruby
//1.创建File对象
File f = new File("D:\\aaa");
//2.listFiles方法
//作用：获取aaa文件夹里面的所有内容，把所有的内容放到数组中返回
File[] files = f.listFiles();
for (File file : files) {
    //file依次表示aaa文件夹里面的每一个文件或者文件夹
    System.out.println(file);
}
```

```ruby
//1.创建File对象
File f = new File("D:\\aaa");
//2.需求：打印里面所有的txt文件
File[] arr = f.listFiles();
for (File file : arr) {
    //file依次表示aaa文件夹里面每一个文件或者文件夹的路径
    if(file.isFile() && file.getName().endsWith(".txt")){
        System.out.println(file);
    }
}
```

```ruby
/*
 public File[] listFiles(FileFilter filter)      利用文件名过滤器获取当前该路径下所有内容
 public File[] listFiles(FilenameFilter filter)  利用文件名过滤器获取当前该路径下所有内容
*/

 //创建File对象
 File f = new File("D:\\aaa");
 //调用listFiles(FileFilter filter)
 File[] arr1 = f.listFiles(new FileFilter() {
     @Override
     public boolean accept(File pathname) {
         return pathname.isFile() && pathname.getName().endsWith(".txt");
     }
 });

 //调用listFiles(FilenameFilter filter)
 File[] arr2 = f.listFiles(new FilenameFilter() {
     @Override
     public boolean accept(File dir, String name) {
         File src = new File(dir, name);
         return src.isFile() && name.endsWith(".txt");
     }
 });
 System.out.println(Arrays.toString(arr2));
```

## File例程

File递归的套路

1，进入文件夹

2，遍历数组

3，判断

4，判断

1.找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）

```ruby
//需求：在当前模块下的aaa文件夹中创建一个a.txt文件

//1.创建a.txt的父级路径
File file = new File("myfile\\aaa");
//2.创建父级路径
//如果aaa是存在的，那么此时创建失败的。
//如果aaa是不存在的，那么此时创建成功的。
file.mkdirs();
//3.拼接父级路径和子级路径
File src = new File(file,"a.txt");
boolean b = src.createNewFile();
if(b){
    System.out.println("创建成功");
}else{
    System.out.println("创建失败");
}
```

```ruby
/* 需求：
    找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）


    套路：
        1，进入文件夹
        2，遍历数组
        3，判断
        4，判断

    */

    findAVI();


public static void findAVI(){
    //获取本地所有的盘符
    File[] arr = File.listRoots();
    for (File f : arr) {
        findAVI(f);
    }
}

public static void findAVI(File src){//"C:\\
    //1.进入文件夹src
    File[] files = src.listFiles();
    //2.遍历数组,依次得到src里面每一个文件或者文件夹
    if(files != null){
        for (File file : files) {
            if(file.isFile()){
                //3，判断，如果是文件，就可以执行题目的业务逻辑
                String name = file.getName();
                if(name.endsWith(".avi")){
                    System.out.println(file);
                }
            }else{
                //4，判断，如果是文件夹，就可以递归
                //细节：再次调用本方法的时候，参数一定要是src的次一级路径
                findAVI(file);
            }

        }
    }
}
```

2.删除一个多级文件夹

```ruby
/*
       删除一个多级文件夹
       如果我们要删除一个有内容的文件夹
       1.先删除文件夹里面所有的内容
       2.再删除自己
    */

    File file = new File("D:\\aaa\\src");
    delete(file);

/*
* 作用：删除src文件夹
* 参数：要删除的文件夹
* */
public static void delete(File src){
    //1.先删除文件夹里面所有的内容
    //进入src
    File[] files = src.listFiles();
    //遍历
    for (File file : files) {
        //判断,如果是文件，删除
        if(file.isFile()){
            file.delete();
        }else {
            //判断,如果是文件夹，就递归
            delete(file);
        }
    }
    //2.再删除自己
    src.delete();
}
```

3.统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）

```ruby
public static void main(String[] args) {
           /*
        需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）
        打印格式如下：
        txt:3个
        doc:4个
        jpg:6个


    */
    File file = new File("G:\英雄联盟");
    //创建HashMap存文件夹类型和数量
    HashMap<String , Integer> hm = new HashMap<>();
    HashMap<String, Integer> hm1 = getCount(file, hm);
    System.out.println(hm1.toString());
}

/*
 * 作用：
 *       统计一个文件夹中每种文件的个数
 * 参数：
 *       要统计的那个文件夹
 * 返回值：
 *       用来统计map集合
 *       键：后缀名 值：次数
 *
 *       a.txt
 *       a.a.txt
 *       aaa（不需要统计的）
 *
 *
 * */
public static HashMap<String , Integer> getCount(File file ,HashMap<String , Integer> hm){
    //进入file文件夹
    File[] files = file.listFiles();
    //如果文件夹不为空则遍历文件夹
    if(files != null) {
        for (File file1 : files) {
            if (file1.isFile()) {
                //判断,如果是文件,取出后缀,注意:"."要用转义的点
                String[] split = file1.getName().split("\\.");
                //如果文件是没有后缀的文件,不统计
                if(split.length >= 2) {
                    String end = split[split.length - 1];
                    if (hm.containsKey(end)) {
                        //键存在
                        Integer count = hm.get(end);
                        count++;
                        hm.put(end, count);
                    } else {
                        //键不存在
                        hm.put(end, 1);
                    }
                }
            } else {
                //进入下一轮递归
                getCount(file1, hm);
            }
        }
    }
    //返回最终的集合
    return hm;
}
```


# IO流

File:表示系统中的文件或者文件夹的路径

注意:File类只能对文件本身进行操作，不能读写文件里面存储的数据。

IO流:用于读写文件中的数据（可以读写文件，或网络中的数据...)

## IO流的分类

![image](https://user-images.githubusercontent.com/88382462/222043508-dbf285fc-e491-4abd-a289-51bd01ce605e.png)

纯文本文件:用windows自带的记事本打开能读懂的文件

**1．什么是IO流?**

存储和读取数据的解决方案  

I: input O: output  

流:像水流一样传输数据

**2．IO流的作用?**

用于读写数据（本地文件，网络)

**3．IO流按照流向可以分类哪两种流?**

输出流:程序 -> 文件

输入流:文件 -> 程序

**4.IO流按照操作文件的类型可以分类哪两种流?**

字节流:可以操作所有类型的文件

字符流:只能操作纯文本文件

**5．什么是纯文本文件?**

用windows系统自带的记事本打开并且能读懂的文件

txt文件，md文件，xml文件，lrc文件等


![image](https://user-images.githubusercontent.com/88382462/222044467-2ace8b28-9a68-4075-9734-b445499f5285.png)

## FileOutputStream/字节输出流

```ruby
/*
      字节输出流的细节：
          1.创建字节输出流对象
                细节1：参数是字符串表示的路径或者是File对象都是可以的
                细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的。
                细节3：如果文件已经存在，则会清空文件
          2.写数据
                细节：write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符
                ‘9’
                ‘7’
          3.释放资源
                每次使用完流之后都要释放资源

*/
    //1.创建对象
    FileOutputStream fos = new FileOutputStream("day28-code/src/a.txt");
    //2.写出数据
    fos.write(57);
    fos.write(56);
    //3.释放资源
    fos.close();

}
```

**1.创建字节输出流对象**

细节1:参数是字符串表示的路径或者File对象都是可以的

细节2:如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的。

细节3:如果文件已经存在，则会清空文件

**2.写数据**

细节: write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符

**3.释放资源**

细节:每次使用完流之后都要释放资源

### FileOutputStream写数据的三种方式

|方法名称	| 说明 |
|---|---|
|void write(int b) |	一次写一个字节数据 |
|void write(byte[]b) |	一次写一个字节数组数据 |
|void write(byte[] b， int off， int len) |	一次写一个字节数组的部分数据 |

```ruby
/*
   void write(int b)                       一次写一个字节数据
   void write(byte[] b)                    一次写一个字节数组数据
   void write(byte[] b, int off, int len)  一次写一个字节数组的部分数据
   参数一：
        数组
   参数二：
        起始索引  0
   参数三：
        个数      3
*/


//1.创建对象
FileOutputStream fos = new FileOutputStream("myio\\a.txt");
//2.写出数据
//fos.write(97); // a
//fos.write(98); // b
byte[] bytes = {97, 98, 99, 100, 101};
/* fos.write(bytes);*/

fos.write(bytes,1,2);// b c
//3.释放资源
fos.close();
```

**换行和续写**

```ruby
/*
    换行写：
        再次写出一个换行符就可以了
        windows： \r\n
        Linux:    \n
        Mac:      \r
    细节：
        在windows操作系统当中，java对回车换行进行了优化。
        虽然完整的是\r\n，但是我们写其中一个\r或者\n，
        java也可以实现换行，因为java在底层会补全。
    建议：
        不要省略，还是写全了。


    续写：
        如果想要续写，打开续写开关即可
        开关位置：创建对象的第二个参数
        默认false：表示关闭续写，此时创建对象会清空文件
        手动传递true：表示打开续写，此时创建对象不会清空文件

*/

//1.创建对象
FileOutputStream fos = new FileOutputStream("myio\\a.txt",true);
//2.写出数据
String str = "kankelaoyezuishuai";
byte[] bytes1 = str.getBytes();
fos.write(bytes1);

//再次写出一个换行符就可以了
String wrap = "\r\n";
byte[] bytes2 = wrap.getBytes();
fos.write(bytes2);

String str2 = "666";
byte[] bytes3 = str2.getBytes();
fos.write(bytes3);

//3.释放资源
fos.close();
```

**1. FileoutputStream的作用**

可以把程序中的数据写到本地文件上，是字节流的基本流。

**2．书写步骤**

创建对象，写出数据，释放资源

**3．三步操作的细节**

创建对象:文件存在、文件不存在、追加写入

写出数据:写出整数、写出字节数组、换行写

释放资源:关闭通道

## FileInputStream/字节输入流

FilelnputStream书写细节

1.创建字节输入流对象

细节1:如果文件不存在，就直接报错。

2.读取数据

细节1:一次读一个字节，读出来的是数据在ASCII上对应的数字

细节2:读到文件末尾了, read方法返回-1。

3.释放资源

细节1:每次使用完流必须要释放资源。

```ruby
/*
*   练习：
*       文件拷贝
*       把D:\itheima\movie.mp4拷贝到当前模块下。
*
*   注意：
*       选择一个比较小的文件，不要太大。大文件拷贝我们下一个视频会说。
*
*   课堂练习：
*       要求统计一下拷贝时间，单位毫秒
* */

long start = System.currentTimeMillis();

//1.创建对象
FileInputStream fis = new FileInputStream("F:\\BaiduNetdiskDownload\\day28-IO（字节流&字符流）\\资料\\文件3.xlsx");
FileOutputStream fos = new FileOutputStream("day28-code\\copy.xlsx");
//2.拷贝
//核心思想：边读边写
int b;
while((b = fis.read()) != -1){
    fos.write(b);
}
//3.释放资源
//规则：先开的最后关闭
fos.close();
fis.close();

long end = System.currentTimeMillis();

//看看运行了多少毫秒
System.out.println(end - start);
```

FilelnputStream一次读多个字节

注意:一次读一个字节数组的数据，每次读取会尽可能把数组装满

```ruby
/*
*   练习：
*       文件拷贝
*       把D:\itheima\movie.mp4 (16.8 MB) 拷贝到当前模块下。
*
* */


long start = System.currentTimeMillis();

//1.创建对象
FileInputStream fis = new FileInputStream("D:\\itheima\\movie.mp4");
FileOutputStream fos = new FileOutputStream("myio\\copy.mp4");
//2.拷贝
int len;
byte[] bytes = new byte[1024 * 1024 * 5];   //一次拷贝5M大小
//len是read()返回值,表示往bytes数组拷贝了多少字节数据
while((len = fis.read(bytes)) != -1){       
   fos.write(bytes,0,len);
}
//3.释放资源
fos.close();
fis.close();

long end = System.currentTimeMillis();

System.out.println(end - start);
```

## try...catch异常处理

```ruby
/*
*    利用try...catch...finally捕获拷贝文件中代码出现的异常

* */

 //1.创建对象
 FileInputStream fis = null;
 FileOutputStream fos = null;
 try {
     fis = new FileInputStream("D:\\itheima\\movie.mp4");
     fos = new FileOutputStream("myio\\copy.mp4");
     //2.拷贝
     int len;
     byte[] bytes = new byte[1024 * 1024 * 5];
     while((len = fis.read(bytes)) != -1){
         fos.write(bytes,0,len);
     }
 } catch (IOException e) {
     //e.printStackTrace();
 } finally {
     //3.释放资源
     if(fos != null){
         try {
             fos.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
     if(fis != null){
         try {
             fis.close();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }

 }
```

AutoCloseable接口自动关闭

![image](https://user-images.githubusercontent.com/88382462/222066026-dc9ec7ed-d319-4acb-88e3-c5598301f924.png)


```ruby
/*
 *    JDK7:IO流中捕获异常的写法
 *
 *      try后面的小括号中写创建对象的代码，
 *          注意：只有实现了AutoCloseable接口的类，才能在小括号中创建对象。
 *     try(){
 *
 *     }catch(){
 *
 *     }
 *
 * */
try (FileInputStream fis = new FileInputStream("D:\\itheima\\movie.mp4");
     FileOutputStream fos = new FileOutputStream("myio\\copy.mp4")) {
    //2.拷贝
    int len;
    byte[] bytes = new byte[1024 * 1024 * 5];
    while ((len = fis.read(bytes)) != -1) {
        fos.write(bytes, 0, len);
    }
} catch (IOException e) {
    e.printStackTrace();
}
}
```

```ruby
/*
 *
 *    JDK9:IO流中捕获异常的写法
 *
 * */

FileInputStream fis = new FileInputStream("D:\\itheima\\movie.mp4");
FileOutputStream fos = new FileOutputStream("myio\\copy.mp4");

try (fis;fos) {
    //2.拷贝
    int len;
    byte[] bytes = new byte[1024 * 1024 * 5];
    while ((len = fis.read(bytes)) != -1) {
        fos.write(bytes, 0, len);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

## 字符集

ASCII存英文
![image](https://user-images.githubusercontent.com/88382462/222073243-ba1c090a-ad52-4c9a-b530-0c8659e7f089.png)



计算机存储规则

1. GB2312字符集:1980年发布，1981年5月1日实施的简体中文汉字编码国家标准。
收录7445个图形字符，其中包括6763个简体汉字

2. BIG5字符集:台湾地区繁体中文标准字符集，共收录13053个中文字，1984年实施。

3.GBK字符集:2000年3月17日发布，收录21003个汉字。
包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字。

windows系统默认使用的就是GBK。系统显示:ANSI

4. Unicode字符集︰国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的
文本信息转换。

4. Unicode字符集︰国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的
文本信息转换。

### GBK

GBK存英文
![image](https://user-images.githubusercontent.com/88382462/222074106-6aa04ff9-7121-4ab7-af39-3253a5a88b44.png)

GBK存中文
![image](https://user-images.githubusercontent.com/88382462/222074948-5f1fb3ea-1e3c-4e66-833b-e9974f57c36b.png)

计算机的存储规则(汉字)(GBK)

规则1:汉字两个字节存储

规则2:高位字节二进制一定以1开头，转成十进制之后是一个负数

计算机的存储规则(英文)(GBK)

规则:英文一个字节存储，兼容ASCI1，二进制前面补0

```
1．在计算机中，任意数据都是以二进制的形式来存储的
2．计算机中最小的存储单元是一个字节
3. ASCII字符集中，一个英文占一个字节
4．简体中文版windows，默认使用GBK字符集
5. GBK字符集完全兼容ASCI字符集
一个英文占一个字节，二进制第一位是0
一个中文占两个字节，二进制高位字节的第一位是1
```

### Unicode

```
研发方:统一码联盟（也叫Unicode组织)总部位置:美国加州
研发时间:1990年
发布时间:1994年发布1.0版本，期间不断添加新的文字，
最新的版本是2022年9月13日发布的15.0版本。
联盟组成:世界各地主要的电脑制造商、软件开发商、数据库开发商、政府部门、研究机构、国际机构、及个人组成
```
utf-32 和 utf-16:

![image](https://user-images.githubusercontent.com/88382462/222076303-87e26462-9f15-4cfb-8b27-f94b2e56d0ae.png)

utf-8:

![image](https://user-images.githubusercontent.com/88382462/222076447-ebd26958-8f6d-45f5-b69f-c256890a09f8.png)

![image](https://user-images.githubusercontent.com/88382462/222076896-153d6648-87fe-4b3d-81c1-8ca0a7c5a511.png)

1. Unicode字符集的UTF-8编码格式

一个英文占一个字节，二进制第一位是0，转成十进制是正数

一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数

![image](https://user-images.githubusercontent.com/88382462/222078556-a9412644-12e1-4d25-9a1d-ea41d48fd6f1.png)


![image](https://user-images.githubusercontent.com/88382462/222078312-1e68b5de-495c-45b2-99da-b4c1739cfcf2.png)

如何不产生乱码?

1，不要用字节流读取文本文件

2，编码解码时使用同一个码表，同一个编码方式

## 编码和解码

Java中编码的方式

|String类中的方法	| 说明|
|---|---|
|public byte[] getBytes()	| 使用默认方式进行编码|
|public byte[] getBytes(string charsetName)	| 使用指定方式进行编码|

Java中解码的方式

|string类中的方法	|说明|
|---|---|
|string(byte[] bytes)	|使用默认方式进行解码|
|string(byte[]bytes，string charsetName)	|使用指定方式进行解码|

```ruby
 //1.编码
String str = "ai你哟";
byte[] bytes1 = str.getBytes();
System.out.println(Arrays.toString(bytes1));

byte[] bytes2 = str.getBytes("GBK");
System.out.println(Arrays.toString(bytes2));


//2.解码
String str2 = new String(bytes1);
System.out.println(str2);

String str3 = new String(bytes1,"GBK");
System.out.println(str3);
```

## 字符流

**字符流的底层其实就是字节流**

字符流 = 字节流 + 字符集

**特点**

输入流:一次读一个字节，遇到中文时，一次读多个字节

输出流:底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中

**使用场景**

对于纯文本文件进行读写操作

### FileReader

1.创建对象

|构造方法	|说明|
|---|---|
|public FileReader(File file)|	创建字符输入流关联本地文件|
|public FileReader(String pathname)	|创建字符输入流关联本地文件|

2.读取数据

|成员方法|	说明|
|---|---|
|public int read()|		读取数据，读到末尾返回-1|
|public int read(char[]buffer) | 读取多个数据，读到末尾返回-1|

细节1:按字节进行读取y遇到中文，一次读多个字节，读取后解码，返回一个整数

细节2:读到文件末尾了，read方法返回-1。

3.释放资源


```ruby
//1.创建对象并关联本地文件
FileReader fr = new FileReader("day28-code\\b.txt");
//2.读取数据 read()
//字符流的底层也是字节流，默认也是一个字节一个字节的读取的。
//如果遇到中文就会一次读取多个，GBK一次读两个字节，UTF-8一次读三个字节

//read（）细节：
//1.read():默认也是一个字节一个字节的读取的,如果遇到中文就会一次读取多个
//2.在读取之后，方法的底层还会进行解码并转成十进制。
//  最终把这个十进制作为返回值
//  这个十进制的数据也表示在字符集上的数字
//  英文：文件里面二进制数据 0110 0001
//          read方法进行读取，解码并转成十进制97
//  中文：文件里面的二进制数据 11100110 10110001 10001001
//          read方法进行读取，解码并转成十进制27721

// 我想看到中文汉字，就是把这些十进制数据，再进行强转就可以了

int ch;
while((ch = fr.read()) != -1){
    System.out.print((char)ch);
}

//3.释放资源
fr.close();
```

```ruby
//1.创建对象
FileReader fr = new FileReader("day28-code/b.txt");
//2.读取数据
char[] chars = new char[2];
int len;
//read(chars)：读取数据，解码，强转三步合并了，把强转之后的字符放到数组当中
//空参的read + 强转类型转换
while((len = fr.read(chars)) != -1){
    //把数组中的数据变成字符串再进行打印
    System.out.print(new String(chars,0,len));
}
//3.释放资源
fr.close();
```

### FileWriter/字符输出流

1.构造方法

|构造方法	|说明|
|---|---|
|public Filewriter(File file)	|创建字符输出流关联本地文件|
|public Filewriter(string pathname)	|创建字符输出流关联本地文件|
|public Filewriter(File file,boolean append)	|创建字符输出流关联本地文件，续写|
|public Filewriter(string pathname,boolean append)	|创建字符输出流关联本地文件，续写|

2.成员方法

|成员方法	|说明|
|---|---|
|void write(int c)	|写出一个字符|
|void write(string str)	|写出一个字符串|
|void write(String str， int off，int len)	|写出一个字符串的一部分|
|void write(char[]cbuf)	|写出一个字符数组|
|void write(char[] cbuf，int off，int len)	|写出字符数组的一部分|

FileWriter书写细节

I.创建字符输出流对象

细节1:参数是字符串表示的路径或者File对象都是可以的

细节2:如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的

细节3:如果文件已经存在，则会清空文件，如果不想清空可以打开续写开关

II.写数据

细节:如果write方法的参数是整数，但是实际上写到本地文件中的是整数在字符集上对应的字符

III.释放资源

细节:每次使用完流之后都要释放资源

```ruby
FileWriter fw = new FileWriter("myio\\a.txt",true);

fw.write(25105);
fw.write("你好威啊???");
char[] chars = {'a','b','c','我'};
fw.write(chars);

fw.close();        FileWriter fw = new FileWriter("myio\\a.txt",true);

fw.write(25105);
fw.write("你好威啊???");
char[] chars = {'a','b','c','我'};
fw.write(chars);

fw.close();
```

字符流原理解析

**创建字符输入流对象**

底层︰关联文件，并创建缓冲区（长度为8192的字节数组)

**读取数据**

底层:1.判断缓冲区中是否有数据可以读取

2.缓冲区没有数据:就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区
如果文件中也没有数据了，返回-1

3.缓冲区有数据:就从缓冲区中读取。

**空参的read方法**:一次读取一个字节，遇到中文一次读多个字节，把字节解码并转成十进制返回

**有参的read方法**:把读取字节，解码，强转三步合并了，强转之后的字符放到数组中

字符流有缓冲区

![image](https://user-images.githubusercontent.com/88382462/222093459-105581cd-7869-486d-ae5c-530b078b46d6.png)

字符流和字节流的使用场景

字节流:

拷贝任意类型的文件

字符流:

读取纯文本文件中的数据

往纯文本文件中写出数据


## 练习

拷贝文件夹

```ruby
/*
* 作用:拷贝文件夹
* 参数1:数据源
* 参数2:目的地
*
* */
private static void copyDir(File src, File dest) throws IOException {
    dest.mkdirs();
    //递归
    //1.进入数据源
    File[] files = src.listFiles();
    //2.遍历数组
    if(files != null) {
        for (File file : files) {
            if (file.isFile()) {
                //3.判断文件:拷贝
                FileInputStream fis = new FileInputStream(file);
                FileOutputStream fos = new FileOutputStream(new File(dest , file.getName()));
                byte[] bytes = new byte[1024];
                int len;

                while ((len = fis.read()) != -1){
                    fos.write(bytes , 0 , len);
                }
                fos.close();
                fis.close();
            }
            if (file.isDirectory()){
                //4.判断文件夹:递归
                copyDir(file , new File(dest , file.getName()));
            }
        }
    }
}
```

加密/解密

```ruby
/*
    为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。
    加密原理：
        对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。
    解密原理：
        读取加密之后的文件，按照加密的规则反向操作，变成原始文件。

     ^ : 异或
         两边相同：false
         两边不同：true

         0：false
         1：true

       100:1100100
       10: 1010

       1100100
     ^ 0001010
     __________
       1101110
     ^ 0001010
     __________
       1100100
*/
```

```ruby
public static void encryptionAndReduction(File src, File dest) throws IOException {
        //原始文件
        FileInputStream fis = new FileInputStream(src);
        //关联文件
        FileOutputStream fos = new FileOutputStream(dest);
        //加密 / 解密 将原始文件和目标文件路径更改即可加/解密
        int b;
        while ((b = fis.read()) != -1) {
            fos.write(b ^ 2);
        }
        //4.释放资源
        fos.close();
        fis.close();
    }
```

数据排序(字符流)

```ruby
/*
    文本文件中有以下的数据：
        2-1-9-4-7-8
    将文件中的数据进行排序，变成以下的数据：
        1-2-4-7-8-9
*/

//1.读取数据
FileReader fr = new FileReader("myio\\a.txt");
StringBuilder sb = new StringBuilder();
int ch;
while((ch = fr.read()) != -1){
    sb.append((char)ch);
}
fr.close();
System.out.println(sb);
//2.排序
String str = sb.toString();
String[] arrStr = str.split("-");//2-1-9-4-7-8

ArrayList<Integer> list = new ArrayList<>();
for (String s : arrStr) {
    int i = Integer.parseInt(s);
    list.add(i);
}
Collections.sort(list);
System.out.println(list);
//3.写出
FileWriter fw = new FileWriter("myio\\a.txt");
for (int i = 0; i < list.size(); i++) {
    if(i == list.size() - 1){
        fw.write(list.get(i) + "");
    }else{
        fw.write(list.get(i) + "-");
    }
}
fw.close();
```

简化写法:使用了Stream流和Arrays的replace

```ruby
/*
    文本文件中有以下的数据：
        2-1-9-4-7-8
    将文件中的数据进行排序，变成以下的数据：
        1-2-4-7-8-9
   细节1：
        文件中的数据不要换行
    细节2:
        bom头
*/
//1.读取数据
FileReader fr = new FileReader("myio\\a.txt");
StringBuilder sb = new StringBuilder();
int ch;
while((ch = fr.read()) != -1){
    sb.append((char)ch);
}
fr.close();
System.out.println(sb);
//2.排序
Integer[] arr = Arrays.stream(sb.toString()
        .split("-"))
        .map(Integer::parseInt)
        .sorted()
        .toArray(Integer[]::new);
//3.写出
FileWriter fw = new FileWriter("myio\\a.txt");
String s = Arrays.toString(arr).replace(", ","-");
String result = s.substring(1, s.length() - 1);
fw.write(result);
fw.close();
```

## 缓冲流

![image](https://user-images.githubusercontent.com/88382462/222373230-b90f8685-4d1a-4449-a8a1-b619ffaf4457.png)

![image](https://user-images.githubusercontent.com/88382462/222386508-b42de499-b926-4cc1-964c-ade2cbdcf124.png)

### 字节缓冲流

```ruby
/*
*   需求：
*       利用字节缓冲流拷贝文件
*
*   字节缓冲输入流的构造方法：
*           public BufferedInputStream(InputStream is)
*
*    字节缓冲输出流的构造方法：
*           public BufferedOutputStream(OutputStream os)
* */
//1.创建缓冲流的对象
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("myio\\a.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myio\\a.txt"));
//2.循环读取并写到目的地
int b;
while ((b = bis.read()) != -1) {
   bos.write(b);
}
//3.释放资源
bos.close();
bis.close(); 
```

一次读写多个字节

```ruby
//1.创建缓冲流的对象
BufferedInputStream bis = new BufferedInputStream(new FileInputStream("myio\\a.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("myio\\copy2.txt"));
//2.拷贝（一次读写多个字节）
byte[] bytes = new byte[1024];
int len;
while((len = bis.read(bytes)) != -1){
    bos.write(bytes,0,len);
}
//3.释放资源
bos.close();
bis.close();
```

字节缓冲流提高速度的原理
![image](https://user-images.githubusercontent.com/88382462/222393617-331e28be-5225-4413-8bc4-71917dec6969.png)

### 字符缓冲流

**字符缓冲流特有方法**

字符缓冲输入流特有方法:

|public string readLine()|读取一行数据，如果没有数据可读了，会返回null|

字符缓冲输出流特有方法

|public void newLine()|public void newLine()|


```ruby
/*
 *   字符缓冲输入流：
 *      构造方法：
 *           public BufferedReader(Reader r)
 *      特有方法：
 *           public String readLine()   读一整行
 *
 * */

//1.创建字符缓冲输入流的对象
BufferedReader br = new BufferedReader(new FileReader("myio\\a.txt"));
//2.读取数据
//细节：
//readLine方法在读取的时候，一次读一整行，遇到回车换行结束
//        但是他不会把回车换行读到内存当中
String line;
while ((( line = br.readLine()) != null)){
    System.out.println(line);
}

//3.释放资源
br.close();
```

```ruby
//1.创建字符缓冲输出流的对象 // 续写开关(写在writer里面)
BufferedWriter bw = new BufferedWriter(new FileWriter("b.txt",true));
//2.写出数据
bw.write("123");
bw.newLine();
bw.write("456");
bw.newLine();
//3.释放资源
bw.close();
```

### 总结
**1．缓冲流有几种?**

字节缓冲输入流:BufferedlnputStream

字节缓冲输出流:BufferedOutputStream字符缓冲输入流:BufferedReader

字符缓冲输出流:Bufferedwriter

**2.缓冲流为什么能提高性能?**

缓冲流自带长度为8192的缓冲区

可以显著提高字节流的读写性能

●对于字符流提升不明显，对于字符缓冲流而言关键点是两个特有的方法

**3.字符缓冲流两个特有的方法是什么?**

字符缓冲输入流BufferedReader: readLine ( )

字符缓冲输出流BufferedWriter: newLine ( )

### 练习

```ruby
/*
        需求：把《出师表》的文章顺序进行恢复到一个新文件中。
    */

//1.读取数据
BufferedReader br = new BufferedReader(new FileReader("myio\\csb.txt"));
String line;
ArrayList<String> list = new ArrayList<>();
while((line = br.readLine()) != null){
   list.add(line);
}
br.close();

//2.排序
//排序规则：按照每一行前面的序号进行排列
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String o1, String o2) {
        //获取o1和o2的序号
        int i1 = Integer.parseInt(o1.split("\\.")[0]);
        int i2 = Integer.parseInt(o2.split("\\.")[0]);
        return i1 - i2;
    }
});

//3.写出
BufferedWriter bw = new BufferedWriter(new FileWriter("myio\\result.txt"));
for (String str : list) {
    bw.write(str);
    bw.newLine();
}
bw.close();
```

使用TreeMap简化上面代码

```ruby
    /*
        需求：把《出师表》的文章顺序进行恢复到一个新文件中。
    */

//1.读取数据
BufferedReader br = new BufferedReader(new FileReader("myio\\csb.txt"));
String line;
TreeMap<Integer,String> tm = new TreeMap<>();
while((line = br.readLine()) != null){
    String[] arr = line.split("\\.");
    //0：序号  1 ：内容
    tm.put(Integer.parseInt(arr[0]),line);
}
br.close();

//2.写出数据
BufferedWriter bw = new BufferedWriter(new FileWriter("myio\\result2.txt"));
Set<Map.Entry<Integer, String>> entries = tm.entrySet();
for (Map.Entry<Integer, String> entry : entries) {
    String value = entry.getValue();
    bw.write(value);
    bw.newLine();
}
bw.close();
```

```ruby
/*
        实现一个验证程序运行次数的小程序，要求如下：
        1.当程序运行超过3次时给出提示:本软件只能免费使用3次,欢迎您注册会员后继续使用~
        2.程序运行演示如下:
            第一次运行控制台输出: 欢迎使用本软件,第1次使用免费~
            第二次运行控制台输出: 欢迎使用本软件,第2次使用免费~
            第三次运行控制台输出: 欢迎使用本软件,第3次使用免费~
            第四次及之后运行控制台输出:本软件只能免费使用3次,欢迎您注册会员后继续使用~

   */

//1.把文件中的数字读取到内存中
//原则：
//IO：随用随创建
//    什么时候不用什么时候关闭
BufferedReader br = new BufferedReader(new FileReader("myio\\count.txt"));
String line = br.readLine();
br.close();

System.out.println(line);//null
int count = Integer.parseInt(line);
//表示当前软件又运行了一次
count++;//1
//2.判断
if(count <= 3){
    System.out.println("欢迎使用本软件,第"+count+"次使用免费~");
}else{
    System.out.println("本软件只能免费使用3次,欢迎您注册会员后继续使用~");
}
BufferedWriter bw = new BufferedWriter(new FileWriter("myio\\count.txt"));
//3.把当前自增之后的count写出到文件当中
bw.write(count + ""); //97 + ""
bw.close();
```

**IO流：随用随创建,什么时候不用什么时候关闭,**因为创建时可能会清空原来的文件,没有关闭则会保持占用.

## 转换流

![image](https://user-images.githubusercontent.com/88382462/222624401-a7614452-741d-4a2f-81e7-92b1358dbaae.png)

字节流想要使用字符流里的方法

指定字符编码读取数据

```ruby
FileReader fr = new FileReader("day29-code/gbkfile.txt", Charset.forName("GBK"));

int ch;
while ((ch = fr.read()) != -1){
    System.out.print((char)ch);
}
```

```ruby
/*
    将本地文件中的GBK文件，转成UTF-8
*/

FileReader fr = new FileReader("myio\\b.txt", Charset.forName("GBK"));
FileWriter fw = new FileWriter("myio\\e.txt",Charset.forName("UTF-8"));
int b;
while ((b = fr.read()) != -1){
    fw.write(b);
}
fw.close();
fr.close();
```

```ruby
/*
     利用字节流读取文件中的数据，每次读一整行，而且不能出现乱码

     //1.字节流在读取中文的时候，是会出现乱码的，但是字符流可以搞定
     //2.字节流里面是没有读一整行的方法的，只有字符缓冲流才能搞定
 */

BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("myio\\a.txt")));
String line;
while ((line = br.readLine()) != null){
    System.out.println(line);
}
br.close();

```

**1．转换流的名字是什么?**

字符转换输入流:InputStreamReader

字符转换输出流:OutputStreamWriter

**2．转换流的作用是什么?**

指定字符集读写数据(JDK11之后已淘汰)

字节流想要使用字符流中的方法了

## 序列化流

写出/读入对象

构造方法

public objectoutputstream(outputstream out)  把基本流包装成高级流

成员方法

public final void writeobject(object obj)  把对象序列化（写出）到文件中去

```ruby
/*
*
* Serializable接口里面是没有抽象方法，标记型接口
* 一旦实现了这个接口，那么就表示当前的Student类可以被序列化
* 理解：
*       一个物品的合格证
* */
public class Student implements Serializable {

//1.创建对象
Student stu = new Student("zhangsan",23);

//2.创建序列化流的对象/对象操作输出流
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("myio\\a.txt"));

//3.写出数据
oos.writeObject(stu);

//4.释放资源
oos.close();
```


利用反序列化流/对象操作输入流:把文件中中的对象读到程序当中

构造方法：
    public ObjectInputStream(InputStream out)         把基本流变成高级流

成员方法：
    public Object readObject()                        把序列化到本地文件中的对象，读取到程序中来

```ruby
//1.创建反序列化流的对象
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("myio\\a.txt"));

//2.读取数据
Student o = (Student) ois.readObject();

//3.打印对象
System.out.println(o);

//4.释放资源
ois.close();
```

```ruby
//transient：瞬态关键字
//作用：不会把当前属性序列化到本地文件当中
private transient String address;
```

## 序列化流/反序列化流的细节汇总

1.使用序列化流将对象写到文件时，需要让Javabean类实现Serializable接口 
否则，会出现NotSerializableException异常

2.序列化流写到文件中的数据是不能修改的，一旦修改就无法再次读回来了

3.序列化对象后，修改了Javabean类，再次反序列化，会不会有问题?

会出问题，会抛出InvalidClassException异常

解决方案:给Javabean类添加serialVersionUID（序列号、版本号)

4.如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢?

解决方案:给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程

```ruby
/*需求：
    将多个自定义对象序列化到文件中，但是对象的个数不确定，该如何操作呢？(用集合)
*/

//1.序列化多个对象
Student s1 = new Student("zhangsan",23,"南京");
Student s2 = new Student("lisi",24,"重庆");
Student s3 = new Student("wangwu",25,"北京");

ArrayList<Student> list = new ArrayList<>();
list.add(s1);
list.add(s2);
list.add(s3);

ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("day28-code\\a.txt"));
oos.writeObject(list);

oos.close();
```

```ruby
//1.创建反序列化流的对象
 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("day28-code\\a.txt"));

 //2.读取数据
 ArrayList<Student> list = (ArrayList<Student>) ois.readObject();

 for (Student student : list) {
     System.out.println(student);
 }

 //3.释放资源
 ois.close();
```

## 打印流

分类:打印流一般是指:PrintStream,PrintWriter两个类

特点1:打印流只操作文件目的地，不操作数据源

特点2:特有的写出方法可以实现，数据原样写出

例如:打印:97  文件中:97 
打印: true 文件中: true

特点3:特有的写出方法，可以实现自动刷新，自动换行

打印一次数据=写出＋换行＋刷新

### 字节打印流

构造方法:

|  public PrintStream(OutputStream/File/String)          |  关联字节输出流/文件/文件路径|
|  public PrintStream(String fileName, Charset charset)   | 指定字符编码|
|  public PrintStream(OutputStreamout, boolean autoFlush) | 自动刷新|
|  public PrintStream(OutputStream out, boolean autoFlush, String encoding) |   指定字符编码且自动刷新|

字节流底层没有缓冲区，开不开自动刷新都一样

成员方法：

|  public void write(int b)            |常规方法：规则跟之前一样，将指定的字节写出|
|  public void println(Xxx xx)         |特有方法：打印任意数据，自动刷新，自动换行|
|  public void print(Xxx xx)           |特有方法：打印任意数据，不换行|
|  public void printf(String format, Object... args)   |特有方法：带有占位符的打印语句，不换行|

```ruby
//1.创建字节打印流的对象
PrintStream ps = new PrintStream(new FileOutputStream("myio\\a.txt"), true, Charset.forName("UTF-8"));
//2.写出数据
ps.println(97);//写出 + 自动刷新 + 自动换行
ps.print(true);
ps.println();
ps.printf("%s爱上了%s","阿珍","阿强");
//3.释放资源
ps.close();
```

### 字符打印流

![image](https://user-images.githubusercontent.com/88382462/222643036-cdef6ea5-10ad-40b4-8c0d-113cc7d07259.png)

构造方法

 |  public PrintWriter(Write/File/String)           | 关联字节输出流/文件/文件路径|
 |  public PrintWriter(String fileName, Charset charset)   | 指定字符编码|
 |  public PrintWriter(Write, boolean autoFlush) | 自动刷新|
 |  public PrintWriter(Write out, boolean autoFlush, String encoding)    |指定字符编码且自动刷新|

字符流底层有缓冲区，想要自动刷新需要开启

成员方法：

 |  public void write(int b)            |常规方法：规则跟之前一样，将指定的字节写出|
 |  public void println(Xxx xx)         |特有方法：打印任意数据，自动刷新，自动换行|
 |  public void print(Xxx xx)           |特有方法：打印任意数据，不换行|
 |  public void printf(String format, Object... args)   |特有方法：带有占位符的打印语句，不换行|


```ruby
//1.创建字符打印流的对象
PrintWriter pw = new PrintWriter(new FileWriter("myio\\a.txt"),true);

//2.写出数据
pw.println("今天你终于叫我名字了，虽然叫错了，但是没关系，我马上改");
pw.print("你好你好");
pw.printf("%s爱上了%s","阿珍","阿强");
//3.释放资源
pw.close();
```

System.out.print的原理: 使用打印流:

```ruby
/*
*       打印流的应用场景
* */

//获取打印流的对象，此打印流在虚拟机启动的时候，由虚拟机创建，默认指向控制台
//特殊的打印流，系统中的标准输出流,是不能关闭，在系统中是唯一的。
PrintStream ps = System.out;

//调用打印流中的方法println
//写出数据，自动换行，自动刷新
ps.println("123");

//ps.close();

ps.println("你好你好");

System.out.println("456");
```

**打印流有几种?各有什么特点?**

有字节打印流和字符打印流两种

**打印流不操作数据源，只能操作目的地**

字节打印流:默认自动刷新，特有的println自动换行

字符打印流:自动刷新需要开启，特有的println自动换行


## 压缩流/解压流

![image](https://user-images.githubusercontent.com/88382462/222645673-a7b7d147-addd-4078-b862-34d8f85cb9b7.png)

```ruby
//定义一个方法用来解压
public static void unzip(File src,File dest) throws IOException {
    //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中
    //创建一个解压缩流用来读取压缩包中的数据
    ZipInputStream zip = new ZipInputStream(new FileInputStream(src));
    //要先获取到压缩包里面的每一个zipentry对象
    //表示当前在压缩包中获取到的文件或者文件夹
    ZipEntry entry;
    while((entry = zip.getNextEntry()) != null){
        System.out.println(entry);
        if(entry.isDirectory()){
            //文件夹：需要在目的地dest处创建一个同样的文件夹
            File file = new File(dest,entry.toString());
            file.mkdirs();
        }else{
            //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）
            FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));
            int b;
            while((b = zip.read()) != -1){
                //写到目的地
                fos.write(b);
            }
            fos.close();
            //表示在压缩包中的一个文件处理完毕了。
            zip.closeEntry();
        }
    }

    zip.close();
}
```

压缩单个文件

```ruby
/*
*   作用：压缩
*   参数一：表示要压缩的文件
*   参数二：表示压缩包的位置
* */
public static void toZip(File src,File dest) throws IOException {
    //1.创建压缩流关联压缩包
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,"tql.zip")));
    //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹
    //参数：压缩包里面的路径
    ZipEntry entry = new ZipEntry("aaa\\bbb\\a.txt");
    //3.把ZipEntry对象放到压缩包当中
    zos.putNextEntry(entry);
    //4.把src文件中的数据写到压缩包当中
    FileInputStream fis = new FileInputStream(src);
    int b;
    while((b = fis.read()) != -1){
        zos.write(b);
    }
    zos.closeEntry();
    zos.close();
}
```

```ruby
public static void main(String[] args) throws IOException {
    /*
     *   压缩流
     *      需求：
     *          把D:\\aaa文件夹压缩成一个压缩包
     * */


    //1.创建File对象表示要压缩的文件夹
    File src = new File("D:\\aaa");
    //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）
    File destParent = src.getParentFile();//D:\\
    //3.创建File对象表示压缩包的路径
    File dest = new File(destParent,src.getName() + ".zip");
    //4.创建压缩流关联压缩包
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));
    //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中
    toZip(src,zos,src.getName());//aaa
    //6.释放资源
    zos.close();
}

/*
*   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中
*   参数一：数据源
*   参数二：压缩流
*   参数三：压缩包内部的路径
* */
public static void toZip(File src,ZipOutputStream zos,String name) throws IOException {
    //1.进入src文件夹
    File[] files = src.listFiles();
    //2.遍历数组
    for (File file : files) {
        if(file.isFile()){
            //3.判断-文件，变成ZipEntry对象，放入到压缩包当中
            ZipEntry entry = new ZipEntry(name + "\\" + file.getName());//aaa\\no1\\a.txt
            zos.putNextEntry(entry);
            //读取文件中的数据，写到压缩包
            FileInputStream fis = new FileInputStream(file);
            int b;
            while((b = fis.read()) != -1){
                zos.write(b);
            }
            fis.close();
            zos.closeEntry();
        }else{
            //4.判断-文件夹，递归
            toZip(file,zos,name + "\\" + file.getName());
            //     no1            aaa   \\   no1
        }
    }
}
```

## Commons-io

Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。

作用:提高IO流的开发效率。

![image](https://user-images.githubusercontent.com/88382462/222667859-dcad521b-9c2c-413e-b799-455d656f9a5e.png)

Commons-io使用步骤

在项目中创建一个文件夹:lib

将jar包复制粘贴到lib文件夹

右键点击jar包，选择Add as Library ->点击OK

在类中导包使用

Commons-io 常见方法:

|FileUtils类（文件/文件夹相关）		|说明|
|---|---|
|static void copyFile(File srcFile，File destFile)		|复制文件|
|static void copyDirectory(File srcDir，File destDir)		|复制文件夹|
|static void copyDirectoryToDirectory(File srcDir，File destDir)		|复制文件夹|
|static void deleteDirectory(File directory)		|删除文件夹|
|static 	void cleanDirectory(File directory)	|清空文件夹|
|static 	String readFileTostring(File file，Charset encoding)	|读取文件中的数据变成成字符串|
|static 	void write(File file，CharSequence data，string encoding)	|写出数据|


|IoUtils类（流相关相关）	|说明|
|---|---|
|public static int copy(Inputstream input，outputstream output)	|复制文件|
|public static int copyLarge(Reader input,Writer output)	|复制大文件|
|public static String readLines(Reader input)	|读取数据|
|public static void write(String data，outputStream output)	|写出数据|

```ruby
File src = new File("myio\\a.txt");
File dest = new File("myio\\copy.txt");
FileUtils.copyFile(src,dest);

File src = new File("D:\\aaa");
File dest = new File("D:\\bbb");
FileUtils.copyDirectoryToDirectory(src,dest);

File src = new File("D:\\bbb");
FileUtils.cleanDirectory(src);
```

## HuTool工具包

![image](https://user-images.githubusercontent.com/88382462/222671737-4aff5792-d720-4cc0-973d-34bb55fb2c71.png)

|相关类|	说明|
|---|---|
|Ioutil	|流操作工具类|
|Fileutil	|文件读写和操作的工具类|
|FileTypeUtil	|文件类型判断工具类|
|watchMonitor	|目录、文件监听|
|classPathResource	|针对ClassPath中资源的访问封装|
|FileReader	|封装文件读取|
|Filewriter	|封装文件写入|

官网：
	https://hutool.cn/
API文档：
	https://apidoc.gitee.com/dromara/hutool/
中文使用文档：
	https://hutool.cn/docs/#/

```ruby
/*
    FileUtil类:
            file：根据参数创建一个file对象
            touch：根据参数创建文件

            writeLines：把集合中的数据写出到文件中，覆盖模式。
            appendLines：把集合中的数据写出到文件中，续写模式。
            readLines：指定字符编码，把文件中的数据，读到集合中。
            readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中

            copy：拷贝文件或者文件夹
*/

    File file1 = FileUtil.file("D:\\", "aaa", "bbb", "a.txt");
    System.out.println(file1);//D:\aaa\bbb\a.txt

    File touch = FileUtil.touch(file1);
    System.out.println(touch);

    ArrayList<String> list = new ArrayList<>();
    list.add("aaa");
    list.add("aaa");
    list.add("aaa");

    File file2 = FileUtil.writeLines(list, "D:\\a.txt", "UTF-8");
    System.out.println(file2);

    ArrayList<String> list1 = new ArrayList<>();
    list.add("aaa");
    list.add("aaa");
    list.add("aaa");
    File file3 = FileUtil.appendLines(list1, "D:\\a.txt", "UTF-8");
    System.out.println(file3);

    List<String> list2 = FileUtil.readLines("D:\\a.txt", "UTF-8");
    System.out.println(list);
```

## 练习

网络爬虫获取假数据

爬取数据
```ruby
/*
*   爬取网络中的数据,返回字符串
*   形参:网址
*   返回值:爬取到的数据
*
*
* */
public static String webCrawler(String net) throws IOException {
	//定义SringBulider拼接爬取到的数据
	StringBuilder sb = new StringBuilder();
	//创建一个URL对象
	URL url = new URL(net);
	//连接上这个网址
	URLConnection conn = url.openConnection();
	//读取数据
	InputStreamReader isr = new InputStreamReader(conn.getInputStream());
	int ch;
	while ((ch = isr.read()) != -1){
		sb.append((char)ch);
	}
	//释放资源
	isr.close();
	return sb.toString();
}
```

根据正则表达式处理数据

```ruby
/*
* 作用:根据正则表达式获取里面符合规则的数据
* 参数一:
*       完整的字符串
*  参数二:
*       正则表达式
* 参数三:
*       获取的是第几组数据
*
* 返回值:
*       想要的数据
*
* */
private static ArrayList<String> getData(String str, String regex , int index) {
		//创建集合存取数据
		ArrayList<String> list = new ArrayList<>();
		//根据正则表达式获取数据
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(str);
		while (matcher.find()) {
				String group = matcher.group(index);
				list.add(group);
		}
		return list;
}
```

利用糊涂包简化代码

```ruby
//1.定义网址
...
//2.爬取数据
String familyNameStr = HttpUtil.get(familyNameNet);
String boyNameStr = HttpUtil.get(boyNameNet);
String girlNameStr = HttpUtil.get(girlNameNet);

//3.利用正则表达式获取数据
List<String> familyNameTempList = ReUtil.findAll( "(.{4})(，|。)", familyNameStr , 1);
List<String> boyNameTempList = ReUtil.findAll( "([\\u4E00-\\u9FA5]{2})(、|。)", boyNameStr , 1);
List<String> girlNameTempList = ReUtil.findAll("(.. ){4}..", girlNameStr, 0);

//4.处理数据
...

//5.生成数据
//生成数据
//糊涂包的相对路径不是相对于当前项目而言的,而是相对于class文件而言的
ArrayList<String> list = getInfos(familyNameList, boyNameList, girlNameList, 70, 30);
Collections.shuffle(list);

FileUtil.writeLines(list , "names.txt", StandardCharsets.UTF_8);
```

# 配置文件

好处1:可以把软件的设置永久化存储

好处2:如果我们要修改参数，不需要改动代码，直接修改配置文件就可以了

## properties配置文件

properties是一个双列集合集合，拥有Map集合所有的特点。

重点∶有一些特有的方法，可以把集合中的数据，按照键值对的形式写到配置文件当中。

也可以把配置文件中的数据，读取到集合中来。

```ruby
//1.创建集合的对象
Properties prop = new Properties();

//2.添加数据
//细节：虽然我们可以往Properties当中添加任意的数据类型，但是一般只会往里面添加字符串类型的数据
prop.put("aaa","111");
prop.put("bbb","222");
prop.put("ccc","333");
prop.put("ddd","444");

//3.遍历集合
Set<Object> keys = prop.keySet();
for (Object key : keys) {
	Object value = prop.get(key);
	System.out.println(key + "=" + value);
}

Set<Map.Entry<Object, Object>> entries = prop.entrySet();
for (Map.Entry<Object, Object> entry : entries) {
	Object key = entry.getKey();
	Object value = entry.getValue();
	System.out.println(key + "=" + value);
}
```

store保存

```ruby
//1.创建集合
Properties prop = new Properties();

//2.添加数据
prop.put("aaa","bbb");
prop.put("bbb","ccc");
prop.put("ddd","eee");
prop.put("fff","iii");

//3.把集合中的数据以键值对的形式写到本地文件当中
FileOutputStream fos = new FileOutputStream("day30-code\\a.properties");
prop.store(fos,"test");
fos.close();
```

load读取

```java
//1.创建集合
Properties prop = new Properties();
//2.读取本地Properties文件里面的数据
FileInputStream fis = new FileInputStream("day30-code\\a.properties");
prop.load(fis);
fis.close();

//3.打印集合
System.out.println(prop);
```

# 多线程

1．什么是多线程?

有了多线程，我们就可以让程序同时做多件事情

2．多线程的作用?

提高效率

3．多线程的应用场景?

只要你想让多个事情同时运行就需要用到多线程

比如:软件中的耗时操作、所有的聊天软件、所有的服务器

## 并发和并行

并发:在同一时刻，有多个指令在单个CPU上交替执行

并行:在同一时刻，有多个指令在多个CPu上同时执行

## 多线程的实现方式

1.继承Thread类的方式进行实现

2.实现Runnable接口的方式进行实现

3.利用Callable接口和Future接口方式实现

```ruby
/*
* 多线程的第一种启动方式：
*   1. 自己定义一个类继承Thread
*   2. 重写run方法
*   3. 创建子类的对象，并启动线程
* */


MyThread t1 = new MyThread();
MyThread t2 = new MyThread();

t1.setName("线程1");
t2.setName("线程2");

t1.start();
t2.start();

public class MyThread extends Thread{

    @Override
    public void run() {
        //书写线程要执行代码
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "HelloWorld");
        }
    }
}
```

```ruby
/*
 * 多线程的第二种启动方式：
 *   1.自己定义一个类实现Runnable接口
 *   2.重写里面的run方法
 *   3.创建自己的类的对象
 *   4.创建一个Thread类的对象，并开启线程
 * */


//创建MyRun的对象
//表示多线程要执行的任务
MyRun mr = new MyRun();

//创建线程对象
Thread t1 = new Thread(mr);
Thread t2 = new Thread(mr);

//给线程设置名字
t1.setName("线程1");
t2.setName("线程2");


//开启线程
t1.start();
t2.start();
	
public class MyRun implements Runnable{

    @Override
    public void run() {
        //书写线程要执行的代码
        for (int i = 0; i < 100; i++) {
            //获取到当前线程的对象
            /*Thread t = Thread.currentThread();
            System.out.println(t.getName() + "HelloWorld!");*/
            System.out.println(Thread.currentThread().getName() + "HelloWorld!");
        }
    }
}
	
```

```ruby
/*
*   多线程的第三种实现方式：
*       特点：可以获取到多线程运行的结果
*
*       1. 创建一个类MyCallable实现Callable接口
*       2. 重写call （是有返回值的，表示多线程运行的结果）
*
*       3. 创建MyCallable的对象（表示多线程要执行的任务）
*       4. 创建FutureTask的对象（作用管理多线程运行的结果）
*       5. 创建Thread类的对象，并启动（表示线程）
* */

//创建MyCallable的对象（表示多线程要执行的任务）
MyCallable mc = new MyCallable();
//创建FutureTask的对象（作用管理多线程运行的结果）
FutureTask<Integer> ft = new FutureTask<>(mc);
//创建线程的对象
Thread t1 = new Thread(ft);
//启动线程
t1.start();

//获取多线程运行的结果
Integer result = ft.get();
System.out.println(result);

		
public class MyCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        //求1~100之间的和
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum = sum + i;
        }
        return sum;
    }
}
```
+ 三种实现方式的对比
  + 实现Runnable、Callable接口
    + 好处: 扩展性强，实现该接口的同时还可以继承其他的类
    + 缺点: 编程相对复杂，不能直接使用Thread类中的方法
  + 继承Thread类
    + 好处: 编程比较简单，可以直接使用Thread类中的方法
    + 缺点: 可以扩展性较差，不能再继承其他的类

## 成员方法

| 方法名                        | 说明                 |
  | -------------------------- | ------------------ |
  | void  setName(String name) | 将此线程的名称更改为等于参数name |
  | String  getName()          | 返回此线程的名称           |
  | Thread  currentThread()    | 返回对当前正在执行的线程对象的引用  |
 | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |
  | final int getPriority()                 | 返回此线程的优先级                         |
  | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |
| void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |
|public static void yield()| 出让线程/礼让线程|
|public static void join() |插入线程/插队线程|

### name
- name细节：
	- 1、如果我们没有给线程设置名字，线程也是有默认的名字的
			- 格式：Thread-X（X序号，从0开始的）
	- 2、如果我们要给线程设置名字，可以用set方法进行设置，也可以构造方法设置

```ruby
//1.创建线程的对象
MyThread t1 = new MyThread("飞机");
MyThread t2 = new MyThread("坦克");

//2.开启线程
t1.start();
t2.start();
```

### currentThread

- currentThread细节：
	- 当JVM虚拟机启动之后，会自动的启动多条线程
	- 其中有一条线程就叫做main线程
	- 他的作用就是去调用main方法，并执行里面的代码
	- 在以前，我们写的所有的代码，其实都是运行在main线程当中

```ruby
//哪条线程执行到这个方法，此时获取的就是哪条线程的对象
Thread t = Thread.currentThread();
String name = t.getName();
System.out.println(name);//main
```
### sleep

- sleep细节：
	- 1、哪条线程执行到这个方法，那么哪条线程就会在这里停留对应的时间
	- 2、方法的参数：就表示睡眠的时间，单位毫秒
	- 3、当时间到了之后，线程会自动的醒来，继续执行下面的其他代码

```ruby
System.out.println("11111111111");
Thread.sleep(5000);
System.out.println("22222222222");
```
### 线程优先级

```ruby
//创建线程要执行的参数对象
MyRunnable mr = new MyRunnable();
//创建线程对象
Thread t1 = new Thread(mr,"飞机");
Thread t2 = new Thread(mr,"坦克");

t1.setPriority(1);
t2.setPriority(10);

t1.start();
t2.start();
```

### 守护线程

- 细节：
	- 当其他的非守护线程执行完毕之后，守护线程会陆续结束
- 通俗易懂：
	- 当女神线程结束了，那么备胎也没有存在的必要了


```ruby
MyThread1 t1 = new MyThread1();
MyThread2 t2 = new MyThread2();

t1.setName("女神");
t2.setName("备胎");

//把第二个线程设置为守护线程（备胎线程）
t2.setDaemon(true);

t1.start();
t2.start();
```

### 出让线程和插入线程

出让线程:尽可能让结果均匀

```ruby
public void run() {//"飞机"  "坦克"
	for (int i = 1; i <= 100; i++) {

		System.out.println(getName() + "@" + i);
		//表示出让当前CPU的执行权
		Thread.yield();
	}
}
```

插入线程:把这个线程插入到当前线程之前

```ruby
MyThread t = new MyThread();
t.setName("土豆");
t.start();

//表示把t这个线程，插入到当前线程之前。
//t:土豆
//当前线程: main线程
t.join();

//执行在main线程当中的
for (int i = 0; i < 10; i++) {
	System.out.println("main线程" + i);
}
```

## 线程生命周期

![image](https://user-images.githubusercontent.com/88382462/223608801-1b8bb065-b960-4f33-9b08-03525f8ab253.png)

## 线程安全的问题和线程同步

### 卖票

- 案例需求

  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票

- 实现步骤

  - 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;

  - 在SellTicket类中重写run()方法实现卖票，代码步骤如下

  - 判断票数大于0，就卖票，并告知是哪个窗口卖的
  - 卖了票之后，总票数要减1
  - 票卖没了，线程停止
  - 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下
  - 创建SellTicket类的对象
  - 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
  - 启动线程

- 代码实现

  ```java
  public class SellTicket implements Runnable {
      private int tickets = 100;
      //在SellTicket类中重写run()方法实现卖票，代码步骤如下
      @Override
      public void run() {
          while (true) {
              if(ticket <= 0){
                      //卖完了
                      break;
                  }else{
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
          }
      }
  }
  public class SellTicketDemo {
      public static void main(String[] args) {
          //创建SellTicket类的对象
          SellTicket st = new SellTicket();
          //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
          Thread t1 = new Thread(st,"窗口1");
          Thread t2 = new Thread(st,"窗口2");
          Thread t3 = new Thread(st,"窗口3");
          //启动线程
          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```


### 卖票案例的问题

- 卖票出现了问题

  - 相同的票出现了多次

  - 出现了负数的票

- 问题产生原因

  线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题


### 同步代码块解决数据安全问题

- 安全问题出现的条件

  - 是多线程环境

  - 有共享数据

  - 有多条语句操作共享数据

- 如何解决多线程安全问题呢?

  - 基本思想：让程序没有安全问题的环境

- 怎么实现呢?

  - 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

  - Java提供了同步代码块的方式来解决

- 同步代码块格式：

  ```java
  synchronized(任意对象) { 
  	多条语句操作共享数据的代码 
  }
  ```

  synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁

- 同步的好处和弊端  

  - 好处：解决了多线程的数据安全问题

  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率

- 代码演示

```ruby
public void run() {
	  while (true) {
		  synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁
			  //t1进来后，就会把这段代码给锁起来
			  if (tickets > 0) {
				  try {
					  Thread.sleep(100);
					  //t1休息100毫秒
				  } catch (InterruptedException e) {
					  e.printStackTrace();
				  }
				  //窗口1正在出售第100张票
				  System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票");
				  tickets--; //tickets = 99;
			  }
		  }
		  //t1出来了，这段代码的锁就被释放了
	  }
  }
```

### 同步方法解决数据安全问题

- 同步方法的格式

  同步方法：就是把synchronized关键字加到方法上

  ```java
  修饰符 synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```

  同步方法的锁对象是什么呢?

  ​	this

- 静态同步方法

  同步静态方法：就是把synchronized关键字加到静态方法上

  ```java
  修饰符 static synchronized 返回值类型 方法名(方法参数) { 
  	方法体；
  }
  ```

  同步静态方法的锁对象是什么呢?

  ​	类名.class

```ruby
int ticket = 0;
@Override
public void run() {
	//1.循环
	while (true) {
		//2.同步代码块（同步方法）
		if (method()) break;
	}
}
//this
private synchronized boolean method() {
	//3.判断共享数据是否到了末尾，如果到了末尾
	if (ticket == 100) {
		return true;
	} else {
		//4.判断共享数据是否到了末尾，如果没有到末尾
		try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		ticket++;
		System.out.println(Thread.currentThread().getName() + "在卖第" + ticket + "张票！！！");
	}
	return false;
}

/*
   需求：
		某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票
		利用同步方法完成
		技巧：同步代码块
*/

MyRunnable mr = new MyRunnable();
Thread t1 = new Thread(mr);
Thread t2 = new Thread(mr);
Thread t3 = new Thread(mr);
t1.setName("窗口1");
t2.setName("窗口2");
t3.setName("窗口3");
t1.start();
t2.start();
t3.start();
```

StringBulider是线程不安全的如果要在多线程中使用,使用StringBuffer

### Lock锁
虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock
Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化
- ReentrantLock构造方法
  | 方法名             | 说明                   |
  | --------------- | -------------------- |
  | ReentrantLock() | 创建一个ReentrantLock的实例 |
- 加锁解锁方法
  | 方法名           | 说明   |
  | ------------- | ---- |
  | void lock()   | 获得锁  |
  | void unlock() | 释放锁  |
- 代码演示
  ```java
  public class Ticket implements Runnable {
      //票的数量
      private int ticket = 100;
      private Object obj = new Object();
      private ReentrantLock lock = new ReentrantLock();
      @Override
      public void run() {
          while (true) {
              //synchronized (obj){//多个线程必须使用同一把锁.
              try {
			  	  //上锁
                  lock.lock();
                  if (ticket <= 0) {
                      //卖完了
                      break;
                  } else {
                      Thread.sleep(100);
                      ticket--;
                      System.out.println(Thread.currentThread().getName() + "在卖票,还剩下" + ticket + "张票");
                  }
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } finally {
			  	  //开锁
                  lock.unlock();
              }
              // }
          }
      }
  }
  public class Demo {
      public static void main(String[] args) {
          Ticket ticket = new Ticket();
          Thread t1 = new Thread(ticket);
          Thread t2 = new Thread(ticket);
          Thread t3 = new Thread(ticket);
          t1.setName("窗口一");
          t2.setName("窗口二");
          t3.setName("窗口三");
          t1.start();
          t2.start();
          t3.start();
      }
  }
  ```

### 2.6死锁

+ 概述

  线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

+ 什么情况下会产生死锁

  1. 资源有限
  2. 同步嵌套

+ 代码演示

  ```java
  public class Demo {
      public static void main(String[] args) {
          Object objA = new Object();
          Object objB = new Object();
          new Thread(()->{
              while(true){
                  synchronized (objA){
                      //线程一
                      synchronized (objB){
                          System.out.println("小康同学正在走路");
                      }
                  }
              }
          }).start();
          new Thread(()->{
              while(true){
                  synchronized (objB){
                      //线程二
                      synchronized (objA){
                          System.out.println("小薇同学正在走路");
                      }
                  }
              }
          }).start();
      }
  }
  ```

## 生产者消费者

### 生产者和消费者模式概述【应用】

- 概述

  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

  所谓生产者消费者问题，实际上主要是包含了两类线程：

  ​	一类是生产者线程用于生产数据

  ​	一类是消费者线程用于消费数据

  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为

  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

- Object类的等待和唤醒方法

  | 方法名              | 说明                                       |
  | ---------------- | ---------------------------------------- |
  | void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |
  | void notify()    | 唤醒正在等待对象监视器的单个线程                         |
  | void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |


- 消费者等待:
![image](https://user-images.githubusercontent.com/88382462/223616106-43c45fef-6542-41f2-8809-0d5149e2fbf3.png)

- 生产者等待
![image](https://user-images.githubusercontent.com/88382462/223616291-46e7c7d3-b3de-4f50-870b-f39a0f67ed7c.png)

厨师
```ruby
public class Cook extends Thread{
    @Override
    public void run() {
        /*
        * 1.循环
        * 2.同步代码块
        * 3.判断共享数据是否到了末尾(到了末尾)
        * 4.判断共享数据是否到了末尾(没到末尾,执行核心逻辑)
        *
        * */
        while (true){
            synchronized (Desk.lock){
                if(Desk.count == 0){
                    //3.判断共享数据是否到了末尾(到了末尾)
                    break;
                }else {
                    //4.判断共享数据是否到了末尾(没到末尾,执行核心逻辑)
                    if(Desk.foodFlag == 1){
                        //等待
                        try {
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }else {
                        //做
                        System.out.println("做一碗饭");
                        //改变桌子状态
                        Desk.foodFlag = 1;
                        //唤醒消费者
                        Desk.lock.notifyAll();
                    }
                }
            }
        }
    }
}

```

吃货

```ruby
public class Foodie extends Thread{
    @Override
    public void run() {
        while (true){
            synchronized (Desk.lock){
                if(Desk.count == 0 ){
                    //3.判断共享数据是否到了末尾(到了末尾)
                    break;
                }else {
                    //4.判断共享数据是否到了末尾(没到末尾,执行核心逻辑)
                    //判断桌子上是否有面条

                    if(Desk.foodFlag == 0){
                        //没有,等待
                        try {
                            Desk.lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }else {
                        //有,开吃
                        //吃的总数减一
                        Desk.count -- ;
                        System.out.println("吃,还能再吃"+Desk.count+"碗");
                        //吃完唤醒厨师继续做
                        Desk.lock.notifyAll();
                        //改变桌子的状态
                        Desk.foodFlag = 0;
                    }
                }
            }
        }
    }
}
```

桌子
```ruby
public class Desk {
    /*
    * 作用:控制生产者和消费者执行
    * */
    public static int foodFlag = 0;

    //总个数
    public static int count = 10 ;

    //锁对象
    public static Object lock = new Object();
}
```

测试类

```ruby
public class Test {
    public static void main(String[] args) {

        //创建线程对象
        Cook cook = new Cook();
        Foodie foodie = new Foodie();

        //开启线程
        cook.start();
        foodie.start();
    }
}
```

### 阻塞队列基本使用

+ 阻塞队列继承结构

  ![06_阻塞队列继承结构](https://user-images.githubusercontent.com/88382462/223385070-95b33f4b-28ed-4dde-9773-0456ea56d426.png)


+ 常见BlockingQueue:

   ArrayBlockingQueue: 底层是数组,有界

   LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值

+ BlockingQueue的核心方法:

   put(anObject): 将参数放入队列,如果放不进去会阻塞

   take(): 取出第一个数据,取不到会阻塞

+ 代码示例

  ```java
  public class Demo02 {
      public static void main(String[] args) throws Exception {
          // 创建阻塞队列的对象,容量为 1
          ArrayBlockingQueue<String> arrayBlockingQueue = new ArrayBlockingQueue<>(1);
          // 存储元素
          arrayBlockingQueue.put("汉堡包");
          // 取元素
          System.out.println(arrayBlockingQueue.take());
          System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞
          System.out.println("程序结束了");
      }
  }
  ```

### 阻塞队列实现等待唤醒机制

+ 案例需求

  + 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务

      1.构造方法中接收一个阻塞队列对象

      2.在run方法中循环向阻塞队列中添加包子

      3.打印添加结果

  + 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务

       1.构造方法中接收一个阻塞队列对象

       2.在run方法中循环获取阻塞队列中的包子

       3.打印获取结果

  + 测试类(Demo)：里面有main方法，main方法中的代码步骤如下

      创建阻塞队列对象

      创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象

      分别开启两个线程

+ 代码实现

  ```java
  public class Cooker extends Thread {
  
      private ArrayBlockingQueue<String> bd;
  
      public Cooker(ArrayBlockingQueue<String> bd) {
          this.bd = bd;
      }
  //    生产者步骤：
  //            1，判断桌子上是否有汉堡包
  //    如果有就等待，如果没有才生产。
  //            2，把汉堡包放在桌子上。
  //            3，叫醒等待的消费者开吃。
  
      @Override
      public void run() {
          while (true) {
              try {
                  bd.put("汉堡包");
                  System.out.println("厨师放入一个汉堡包");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  public class Foodie extends Thread {
      private ArrayBlockingQueue<String> bd;
  
      public Foodie(ArrayBlockingQueue<String> bd) {
          this.bd = bd;
      }
  
      @Override
      public void run() {
  //        1，判断桌子上是否有汉堡包。
  //        2，如果没有就等待。
  //        3，如果有就开吃
  //        4，吃完之后，桌子上的汉堡包就没有了
  //                叫醒等待的生产者继续生产
  //        汉堡包的总数量减一
  
          //套路:
          //1. while(true)死循环
          //2. synchronized 锁,锁对象要唯一
          //3. 判断,共享数据是否结束. 结束
          //4. 判断,共享数据是否结束. 没有结束
          while (true) {
              try {
                  String take = bd.take();
                  System.out.println("吃货将" + take + "拿出来吃了");
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
  
      }
  }
  
  public class Demo {
      public static void main(String[] args) {
          ArrayBlockingQueue<String> bd = new ArrayBlockingQueue<>(1);
  
          Foodie f = new Foodie(bd);
          Cooker c = new Cooker(bd);
  
          f.start();
          c.start();
      }
  }
  ```





















